



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1, mkdocs-material-4.6.3">
    
    
      
        <title>Transactions and Testing - LightInject</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.adb8469c.css">
      
      
    
    
      <script src="../assets/javascripts/modernizr.86422ebf.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#transaction-management" tabindex="0" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href=".." title="LightInject" aria-label="LightInject" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              LightInject
            </span>
            <span class="md-header-nav__topic">
              
                Transactions and Testing
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" aria-label="search" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/seesharper/lightinject/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    GitHub
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href=".." title="LightInject" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    LightInject
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/seesharper/lightinject/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    GitHub
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href=".." title="Home" class="md-nav__link">
      Home
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item">
    <a href="../designpatterns/" title="Patterns" class="md-nav__link">
      Patterns
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      Extensions
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Extensions
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../interception/" title="Interception" class="md-nav__link">
      Interception
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../autofactory/" title="AutoFactory" class="md-nav__link">
      AutoFactory
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../annotation/" title="Annotation" class="md-nav__link">
      Annotation
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      Integrations
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Integrations
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../xunit/" title="xUnit" class="md-nav__link">
      xUnit
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../web/" title="Web" class="md-nav__link">
      Web
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../mvc/" title="Mvc" class="md-nav__link">
      Mvc
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../wcf/" title="WCF" class="md-nav__link">
      WCF
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../webapi/" title="Web Api" class="md-nav__link">
      Web Api
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../signalr/" title="SignalR" class="md-nav__link">
      SignalR
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../nancy/" title="Nancy" class="md-nav__link">
      Nancy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../microsoft.aspnetcore.hosting/" title="AspNetCore" class="md-nav__link">
      AspNetCore
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../microsoft.dependencyinjection/" title="Microsoft DI" class="md-nav__link">
      Microsoft DI
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5" checked>
    
    <label class="md-nav__link" for="nav-5">
      Blog
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Blog
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../webapirequestlogging/" title="Web Api Request Logging" class="md-nav__link">
      Web Api Request Logging
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        Transactions and Testing
      </label>
    
    <a href="./" title="Transactions and Testing" class="md-nav__link md-nav__link--active">
      Transactions and Testing
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#commands-and-queries" class="md-nav__link">
    Commands and Queries
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#queries" class="md-nav__link">
    Queries
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#commands" class="md-nav__link">
    Commands
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#why-not-an-orm" class="md-nav__link">
    Why not an ORM?
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#customers" class="md-nav__link">
    Customers
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#passing-data-through-layers" class="md-nav__link">
    Passing data through layers
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#data-access-layer" class="md-nav__link">
    Data Access Layer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#business-layer" class="md-nav__link">
    Business Layer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#api-layer" class="md-nav__link">
    API Layer
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#composition-root" class="md-nav__link">
    Composition Root
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#testing-query-handlers" class="md-nav__link">
    Testing query handlers
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#transactions" class="md-nav__link">
    Transactions
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#inserting-data" class="md-nav__link">
    Inserting data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multiple-command-handlers" class="md-nav__link">
    Multiple command handlers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#automatic-rollback" class="md-nav__link">
    Automatic rollback
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#testing-controllers" class="md-nav__link">
    Testing Controllers
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../aspnetcoreunittesting/" title="AspNetCore unit testing" class="md-nav__link">
      AspNetCore unit testing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../blog-dotnet-steps/" title="Reflection in C# scripts" class="md-nav__link">
      Reflection in C# scripts
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      Side Projects
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        Side Projects
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../lightmock/" title="LightMock" class="md-nav__link">
      LightMock
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      About
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        About
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../licence/" title="Licence" class="md-nav__link">
      Licence
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#commands-and-queries" class="md-nav__link">
    Commands and Queries
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#queries" class="md-nav__link">
    Queries
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#commands" class="md-nav__link">
    Commands
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#why-not-an-orm" class="md-nav__link">
    Why not an ORM?
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#customers" class="md-nav__link">
    Customers
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#passing-data-through-layers" class="md-nav__link">
    Passing data through layers
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#data-access-layer" class="md-nav__link">
    Data Access Layer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#business-layer" class="md-nav__link">
    Business Layer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#api-layer" class="md-nav__link">
    API Layer
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#composition-root" class="md-nav__link">
    Composition Root
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#testing-query-handlers" class="md-nav__link">
    Testing query handlers
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#transactions" class="md-nav__link">
    Transactions
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#inserting-data" class="md-nav__link">
    Inserting data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multiple-command-handlers" class="md-nav__link">
    Multiple command handlers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#automatic-rollback" class="md-nav__link">
    Automatic rollback
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#testing-controllers" class="md-nav__link">
    Testing Controllers
  </a>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/seesharper/lightinject/edit/master/docs/transactions.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="transaction-management">Transaction Management<a class="headerlink" href="#transaction-management" title="Permanent link">&para;</a></h1>
<p>In this example we will be looking into how to deal with connections and transactions in a Web application. We will also discuss how to implement automatic rollback for integration tests. Our testing framework will be <strong>xUnit</strong> and together with <strong>LightInject</strong> this will hopefully turn into a very smooth testing experience.</p>
<h2 id="commands-and-queries">Commands and Queries<a class="headerlink" href="#commands-and-queries" title="Permanent link">&para;</a></h2>
<p>There are many ways to manage the interaction with the database and in this application we are going to implement something that has come to be known as the Command-Query pattern. The basic idea here is that we have one interface (<strong>IQueryHandler</strong>) for everything that comes out of the database and another interface (<strong>ICommandHandler</strong>)for everything that goes into the database. The fact that we are dealing with the same set of interfaces for all interaction with the database means that we can very easily add features through the use of decorators. </p>
<p>I am not going to cover everything with regards to command and queries here, but we will look into the interfaces we need to implement in order to shuffle data back and forth to the database.</p>
<h3 id="queries">Queries<a class="headerlink" href="#queries" title="Permanent link">&para;</a></h3>
<p>The following interface represents a class that can handle a query and return some kind of result.</p>
<div class="codehilite"><pre><span></span><code>public interface IQueryHandler&lt;in TQuery, TResult&gt; where TQuery : IQuery&lt;TResult&gt;
{    
    Task&lt;TResult&gt; HandleAsync(TQuery query);
}
</code></pre></div>


<p>You might wonder about the <strong>IQuery&lt;TResult&gt;</strong> generic contraint. This is just an interface to give type inference a helping hand as we move on to the next interface. </p>
<p>The IQueryExecutor represents a class that can execute any query.</p>
<div class="codehilite"><pre><span></span><code>public interface IQueryExecutor
{     
    Task&lt;TResult&gt; ExecuteAsync&lt;TResult&gt;(IQuery&lt;TResult&gt; query);
}
</code></pre></div>


<p>This is where the <strong>IQuery&lt;TResult&gt;</strong> generic contraint comes into play. Without the contraint we would have to specify the type of result when calling the <strong>ExecuteAsync</strong> method.</p>
<div class="codehilite"><pre><span></span><code>var result = queryExecutor.ExecuteAsync&lt;SomeResultType&gt;(somequery);
</code></pre></div>


<p>With the query class "implementing" the IQuery&lt;TResult&gt; interface we can instead do this</p>
<div class="codehilite"><pre><span></span><code>var result = queryExecutor.ExecuteAsync(somequery);
</code></pre></div>


<h3 id="commands">Commands<a class="headerlink" href="#commands" title="Permanent link">&para;</a></h3>
<p>The following interface represents a class that can handle a command where the command can be any class.</p>
<div class="codehilite"><pre><span></span><code>    public interface ICommandHandler&lt;in TCommand&gt;
    {   
        Task HandleAsync(TCommand command);
    }
</code></pre></div>


<p>Will be seeing examples of both queries and commands throughout this example.</p>
<h2 id="why-not-an-orm">Why not an ORM?<a class="headerlink" href="#why-not-an-orm" title="Permanent link">&para;</a></h2>
<p>The best answer I can give you is that I have already been there and felt the pain that eventually comes sneaking upon you. A little at first and then more and more as things gets more complicated. In fact, I have actually written an inhouse ORM back in the days and writing a Linq provider for instance, certainly represents the Mount Everest of programming. Not because Linq is so hard, but because you have to deal with all the mismatches between the relational model and the object model. ORM's tries to free you from understanding SQL and it is such a failed abstraction. Eventually at some point, you find yourself in a situation where you are trying to come up with a Linq expression that generates the SQL you've already written. Bottom line, bite the bullet and learn SQL.</p>
<h2 id="customers">Customers<a class="headerlink" href="#customers" title="Permanent link">&para;</a></h2>
<p>The first task is to create a query handler that can retrieve customers from the database based on their origin (country).</p>
<p>The SQL for ths look like this:</p>
<div class="codehilite"><pre><span></span><code><span class="k">SELECT</span> 
    <span class="n">CustomerId</span><span class="p">,</span>
    <span class="n">CompanyName</span>
<span class="k">FROM</span> 
    <span class="n">Customers</span>
<span class="k">WHERE</span> 
    <span class="n">Country</span> <span class="o">=</span> <span class="o">@</span><span class="n">Country</span><span class="p">;</span>
</code></pre></div>


<p>With the SQL in place, we are ready to implement the query handler.</p>
<div class="codehilite"><pre><span></span><code>public class CustomersQueryHandler : IQueryHandler&lt;CustomersQuery, Customer[]&gt;
{
    private readonly IDbConnection dbConnection;

    public CustomersQueryHandler(IDbConnection dbConnection)
    {
        this.dbConnection = dbConnection;
    }

    public async Task&lt;Customer[]&gt; HandleAsync(CustomersQuery query)
    {
        var result = await dbConnection.QueryAsync&lt;CustomerRow&gt;(SQL.CustomersByCountry, query);
        return result.ToArray();
    }
}
</code></pre></div>


<blockquote>
<p>Note: Query and command handlers does not dictate that the data is stored in a relational database. It might just as well be stored in a file or another type of database such as a document database.</p>
</blockquote>
<p>This query handler has just one dependency, the <strong>IDbConnection</strong> off which Dapper provides the <strong>QueryAsync</strong> method used to execute the query.
The query (<strong>CustomersQuery</strong>) looks like this</p>
<div class="codehilite"><pre><span></span><code>public class CustomersQuery : IQuery&lt;Customer[]&gt;
{
    public string Country { get; set; }
}
</code></pre></div>


<h2 id="passing-data-through-layers">Passing data through layers<a class="headerlink" href="#passing-data-through-layers" title="Permanent link">&para;</a></h2>
<p>Okay, so we have our application that consists of different layers. </p>
<ul>
<li>Data Access Layer (query and command handlers)</li>
<li>Business Layer (services using the data access layer)</li>
<li>Public API (typically a REST based API using services from the business layer)</li>
</ul>
<h3 id="data-access-layer">Data Access Layer<a class="headerlink" href="#data-access-layer" title="Permanent link">&para;</a></h3>
<p>This is where we actually interact with the underlying data store which for most applications even today means a relational database. These databases store relational data and is not very well suited for storing objects and we should treat the database accordingly. Relational databases does not store objects, they store rows of data. 
This is why we represent the result from <strong>Dapper</strong> as a set of <strong>CustomerRow</strong> instances. </p>
<h3 id="business-layer">Business Layer<a class="headerlink" href="#business-layer" title="Permanent link">&para;</a></h3>
<p>This layer consists of the services that in turn will be using the data access layer. This is also the place to put any kind of business logic related to our services.  By mocking the data access layer we can test this functionality without hitting the database.</p>
<h3 id="api-layer">API Layer<a class="headerlink" href="#api-layer" title="Permanent link">&para;</a></h3>
<p>This is our public API which in this sample application is exposed as a RESTful API using Web Api.  Try to keep this layer as thin as possible. It should not deal with any kind of business logic, but it should for instance deal with making sure that we return the correct status codes according to REST best practices. </p>
<p>So should each layer have its own representation of the same data? </p>
<p>My answer is this: Be pragmatic about this. If the representation looks identical throughout the various layers, you might as well reuse the same class for different layers. Once you need to add JsonIgnore attributes to ensure that database-only properties does not get exposed in the Web API, you might consider another representation.  It is also likely that the representations for reading and writing will differ so there is a lot to consider her. There is also a performance penalty involved here since we need to constantly map the "same" data between layers. </p>
<p>There might also be situations where the service layer just acts as a pass-t through layer and it that case it might be just fine to use the query/command handlers directly in our controllers. </p>
<h2 id="composition-root">Composition Root<a class="headerlink" href="#composition-root" title="Permanent link">&para;</a></h2>
<p>The composition root is where we register services into the container.</p>
<div class="codehilite"><pre><span></span><code>serviceRegistry.Register&lt;IQueryExecutor, QueryExecutor&gt;(new PerContainerLifetime());
            serviceRegistry.RegisterQueryHandlers();

            // We register the connection that it is disposed when the scope ends.
            // The scope here is per web request.
            serviceRegistry.Register(factory =&gt; CreateConnection(), new PerScopeLifetime());
</code></pre></div>


<p>We register the <strong>IDbConnection</strong> with the <strong>PerScopeLifetime</strong> which means that we get the same connection within a scope. The scope is usually per web request, but it can also be per test method as we will see in a minute.<br />
This is actually a nice aspect of the scoping mechanism in LightInject. We tell a service to be per scope without providing any details about how the scope is started or ended.</p>
<h2 id="testing-query-handlers">Testing query handlers<a class="headerlink" href="#testing-query-handlers" title="Permanent link">&para;</a></h2>
<p>Before we dive into how to handle transactions, we are going to look at how to test our new query handler. <strong>LightInject</strong> provides an extension(<strong>LightInject.xUnit</strong>) that makes it possible to inject services into test methods.</p>
<div class="codehilite"><pre><span></span><code>[Theory, Scoped, InjectData]
public async Task ShouldGetCustomersFromGermany(IQueryExecutor queryExecutor)
{
    var query = new CustomersQuery {Country = &quot;Germany&quot;};
    var result = await queryExecutor.ExecuteAsync(query);
    Assert.Equal(11, result.Length);
}
</code></pre></div>


<p>The <strong>Scoped</strong> attribute tells <strong>LightInject</strong> to wrap a scope around this test method. When the test method ends, the scope will end as well and that will in turn cause the <strong>IDbConnection</strong> to be disposed since that service is registered with the <strong>PerScopeLifetime</strong>. </p>
<p>The <strong>InjectData</strong> attribute simply tells <strong>LightInject</strong> to inject method arguments and can be thought off as a more sophisticated version of the <strong>InlineData</strong> attribute usually seen in <strong>xUnit</strong> theory based tests.</p>
<p><strong>LightInject.xUnit</strong> creates a container instance behind the scenes and uses that instance to inject services into the test methods. The default behavior in <strong>LightInject</strong> is to look for composition roots in the same assembly as the requested service. This is part of the fallback mechanism and means that we don't really need to explicitly configure the container in the test class although it is possible to do so by declaring the following static method.</p>
<div class="codehilite"><pre><span></span><code>public static void Configure(IServiceContainer container)
{
    container.RegisterFrom&lt;CompositionRoot&gt;();
}
</code></pre></div>


<p>We can also use the <strong>InjectData</strong> attribute so specify inline data in addition to the service being injected.</p>
<div class="codehilite"><pre><span></span><code>[Theory, Scoped]
[InjectData(&quot;France&quot;, 11)]
[InjectData(&quot;Germany&quot;, 11)]
[InjectData(&quot;Norway&quot;, 1)]
public async Task ShouldGetCustomers(IQueryExecutor queryExecutor, string country, int expectedCount)
{
    var result = await queryExecutor.ExecuteAsync(new CustomersQuery() { Country = country });
    Assert.Equal(expectedCount, result.Length);
}
</code></pre></div>


<h2 id="transactions">Transactions<a class="headerlink" href="#transactions" title="Permanent link">&para;</a></h2>
<p>We are going to build upon the standard <strong>IDbConnection</strong> and <strong>IDbTransaction</strong> interfaces and provide a way to transparently apply transactions to command handlers. </p>
<p><strong>Requirements:</strong> </p>
<ul>
<li>Transactions should as short lived as possible.</li>
<li>Only one transaction per scope (web request)</li>
<li>Support sequential and nested execution of command handlers within the same transaction. </li>
<li>Allow integration tests to roll back changes when the test ends.</li>
</ul>
<p>This might seem like a tall order and the solution might look a bit controversial, but bare with me on this one and you will see that the implementation is actually quite simple. </p>
<h3 id="inserting-data">Inserting data<a class="headerlink" href="#inserting-data" title="Permanent link">&para;</a></h3>
<p>Before we start to think about transactions, we need something that writes to the database. A simple insert should do the trick.</p>
<div class="codehilite"><pre><span></span><code>public class AddCustomerCommandHandler : ICommandHandler&lt;AddCustomerCommand&gt;
{
    private readonly IDbConnection dbConnection;

    public AddCustomerCommandHandler(IDbConnection dbConnection)
    {
        this.dbConnection = dbConnection;
    }

    public async Task HandleAsync(AddCustomerCommand command)
    {
        await dbConnection.ExecuteAsync(SQL.InsertCustomer, command);
    }
}
</code></pre></div>


<p>The command handler takes care of executing a simple insert into the <strong>Customers</strong> table using the <strong>ExecuteAsync</strong> extension method provided by <strong>Dapper</strong>. The  <strong>AddCustomerCommand</strong>  is just a simple POCO class that contains the data to be inserted.</p>
<div class="codehilite"><pre><span></span><code>public class AddCustomerCommand
{
    public string CustomerId { get; set; }

    public string CompanyName { get; set; }
}
</code></pre></div>


<p>The SQL looks like this:</p>
<div class="codehilite"><pre><span></span><code><span class="k">INSERT</span> <span class="k">INTO</span> <span class="n">Customers</span> <span class="p">(</span><span class="n">CustomerId</span><span class="p">,</span> <span class="n">CompanyName</span><span class="p">)</span>
<span class="k">VALUES</span> <span class="p">(</span><span class="o">@</span><span class="n">CustomerId</span><span class="p">,</span> <span class="o">@</span><span class="n">CompanyName</span><span class="p">)</span>
</code></pre></div>


<p>Wrapping command handlers inside a transaction is just a matter of applying a simple decorator.</p>
<div class="codehilite"><pre><span></span><code>public class TransactionalCommandHandler&lt;TCommand&gt; : ICommandHandler&lt;TCommand&gt;
{
    private readonly IDbConnection dbConnection;
    private readonly ICommandHandler&lt;TCommand&gt; commandHandler;

    public TransactionalCommandHandler(IDbConnection dbConnection, ICommandHandler&lt;TCommand&gt; commandHandler)
    {
        this.dbConnection = dbConnection;
        this.commandHandler = commandHandler;
    }

    public async Task HandleAsync(TCommand command)
    {
        using (var transaction = dbConnection.BeginTransaction())
        {
            await commandHandler.HandleAsync(command);
            transaction.Commit();
        }                
    }
}
</code></pre></div>


<p>With a single line of code in the composition root , we can now apply this decorator to all command handlers.</p>
<div class="codehilite"><pre><span></span><code>serviceRegistry.Decorate(typeof(ICommandHandler&lt;&gt;), typeof(TransactionalCommandHandler&lt;&gt;));
</code></pre></div>


<h3 id="multiple-command-handlers">Multiple command handlers<a class="headerlink" href="#multiple-command-handlers" title="Permanent link">&para;</a></h3>
<p>Within a single scope (web request), we might have to execute more than one command handler, either sequentially or nested within each other. Since we now have an all-purpose decorator (<strong>TransactionalCommandHandler</strong>) that starts a new transaction before each underlying command handler, we need to make sure that only one transaction exists within the scope (web request).</p>
<p>We do this by implementing yet another decorator and this time a decorator for the <strong>IDbConnection</strong> interface.</p>
<div class="codehilite"><pre><span></span><code>public class ConnectionDecorator : IDbConnection
{
    private readonly IDbConnection dbConnection;
    private readonly Lazy&lt;TransactionDecorator&gt; dbTransaction;        

    public ConnectionDecorator(IDbConnection dbConnection)
    {
        this.dbConnection = dbConnection;
        dbTransaction =
            new Lazy&lt;TransactionDecorator&gt;(() =&gt; new TransactionDecorator(this, dbConnection.BeginTransaction()));
    }

    public void Dispose()
    {
        if (dbTransaction.IsValueCreated)
        {
            dbTransaction.Value.EndTransaction();
        }
        dbConnection.Dispose();
    }

    public IDbTransaction BeginTransaction()
    {
        dbTransaction.Value.IncrementTransactionCount();
        return dbTransaction.Value;           
    }

    public IDbTransaction BeginTransaction(IsolationLevel il)
    {
        return BeginTransaction();
    }

    public void Close()
    {
        dbConnection.Close();
    }

    public void ChangeDatabase(string databaseName)
    {
        dbConnection.ChangeDatabase(databaseName);
    }

    public IDbCommand CreateCommand()
    {
        return dbConnection.CreateCommand();
    }

    public void Open()
    {
        dbConnection.Open();
    }

    public string ConnectionString
    {
        get { return dbConnection.ConnectionString; }
        set { dbConnection.ConnectionString = value; }
    }

    public int ConnectionTimeout
    {
        get { return dbConnection.ConnectionTimeout; }
    }

    public string Database
    {
        get { return dbConnection.Database; }
    }

    public ConnectionState State
    {
        get { return dbConnection.State; }
    }
}
</code></pre></div>


<p>Most of the methods and properties here just call into the underlying <strong>IDbConnection</strong>, except for the <strong>Dispose</strong> and <strong>BeginTransaction</strong> methods that we will explain in a minute. </p>
<p>But first the code for the <strong>TransactionDecorator</strong></p>
<div class="codehilite"><pre><span></span><code>public class TransactionDecorator : IDbTransaction
{
    private readonly IDbTransaction dbTransaction;
    private int transactionCount;
    private int commitCount;
    public TransactionDecorator(IDbConnection dbConnection, IDbTransaction dbTransaction)
    {
        Connection = dbConnection;
        this.dbTransaction = dbTransaction;
    }

    public void IncrementTransactionCount()
    {
        transactionCount++;
    }

    public void EndTransaction()
    {
        if (commitCount == transactionCount)
        {
            dbTransaction.Commit();
        }
        else
        {
            dbTransaction.Rollback();
        }
        dbTransaction.Dispose();
    }

    public void Dispose() { }

    public virtual void Commit()
    {
        commitCount++;
    }

    public void Rollback() { }

    public IDbConnection Connection { get; }

    public IsolationLevel IsolationLevel =&gt; dbTransaction.IsolationLevel;
}
</code></pre></div>


<p>Okay, it is time to what is going on here. Hang on!</p>
<p>When the <strong>BeginTransaction</strong> method is executed we create a new <strong>IDbTransaction</strong>  and wraps that transaction inside a <strong>TransactionDecorator</strong>. This transaction is provided through a <strong>Lazy&lt;T&gt;</strong> that makes sure that we only create a single transaction no matter how many times the <strong>BeginTransaction</strong> method is called. 
We also increment the "<strong>transactionCount</strong>"  which basically reflects the number of calls to the <strong>BeginTransaction</strong> method.</p>
<p>The "<strong>transactionCount</strong>" is then used inside the <strong>EndTransaction</strong> method to decide if we should perform a commit or a rollback.  The rule here is simple. In order for the transaction to be committed, we need the <strong>commitCount</strong> to be equal to the <strong>transactionCount</strong>. If they are not equal it means that a BeginTransaction was executed without a commit. In that case we do a rollback.</p>
<p>The <strong>EndTransaction</strong> method is called from the <strong>Dispose</strong> method inside the the <strong>ConnectionDecorator</strong> that first checks if we actually have a transaction at all. If so, we execute the <strong>EndTransaction</strong> method and finally disposes the underlying connection.</p>
<p>The connection is as mentioned before disposed when the scope (web request) ends because it is registered with the <strong>PerScopeLifetime</strong>.</p>
<p>Plugging all this goodness into our code is a simple as </p>
<div class="codehilite"><pre><span></span><code>serviceRegistry.Decorate&lt;IDbConnection, ConnectionDecorator&gt;();
</code></pre></div>


<p>We can now execute nested command handlers as well as command handlers sequentially and still have them operate within the same transaction that either gets committed or rolled back when the connection is disposed.</p>
<h3 id="automatic-rollback">Automatic rollback<a class="headerlink" href="#automatic-rollback" title="Permanent link">&para;</a></h3>
<p>Integration tests that writes to the database should perform a rollback when the test ends. This is now just a matter of adding another decorator that simply executes a rollback rather than a commit.</p>
<div class="codehilite"><pre><span></span><code>public class RollbackCommandHandler&lt;TCommand&gt; : ICommandHandler&lt;TCommand&gt;
{
    private readonly IDbConnection dbConnection;
    private readonly ICommandHandler&lt;TCommand&gt; commandHandler;

    public RollbackCommandHandler(IDbConnection dbConnection, ICommandHandler&lt;TCommand&gt; commandHandler)
    {
        this.dbConnection = dbConnection;
        this.commandHandler = commandHandler;
    }

    public async Task HandleAsync(TCommand command)
    {
        using (var transaction = dbConnection.BeginTransaction())
        {
            await commandHandler.HandleAsync(command);
            transaction.Rollback();
        }
    }
}
</code></pre></div>


<p>This decorator only lives in the test project and we can apply the decorator by implementing a static <strong>Configure</strong> method in the test class.</p>
<div class="codehilite"><pre><span></span><code>public static void Configure(IServiceContainer container)
{
    container.RegisterFrom&lt;CompositionRoot&gt;();
    container.Decorate(typeof(ICommandHandler&lt;&gt;), typeof(RollbackCommandHandler&lt;&gt;));
}
</code></pre></div>


<p>We can now finally write a test that verifies that a new customer has been written to the database.</p>
<div class="codehilite"><pre><span></span><code>[Theory, Scoped, InjectData]
public async Task ShouldAddCustomer(ICommandExecutor commandExecutor, IQueryExecutor queryExecutor)
{
    await commandExecutor.ExecuteAsync(new AddCustomerCommand {CustomerId = &quot;AAPL&quot;, CompanyName = &quot;Apple Inc&quot;});
    var newCustomer = await queryExecutor.ExecuteAsync(new CustomerQuery {CustomerId = &quot;AAPL&quot;});
    Assert.Equal(&quot;Apple Inc&quot;, newCustomer.CompanyName);
}
</code></pre></div>


<p>Since the transaction is not ended until the test ends, we can still query the database for the newly inserted customer and verify that is was inserted.</p>
<h2 id="testing-controllers">Testing Controllers<a class="headerlink" href="#testing-controllers" title="Permanent link">&para;</a></h2>
<p>Testing the public API in a Web API application means testing the controllers and by using the <strong>Microsoft.Owin.Testing</strong> package we can create an in-memory server that lets us test our Owin based web application end to end. </p>
<p>Lets just quickly take a look at the controller we are going to test.</p>
<div class="codehilite"><pre><span></span><code>public class CustomersController : ApiController
{
    private readonly IQueryExecutor queryExecutor;        

    public CustomersController(IQueryExecutor queryExecutor)
    {
        this.queryExecutor = queryExecutor;            
    }

    public async Task&lt;IHttpActionResult&gt; Get(string country)
    {            
        var customers = await queryExecutor.ExecuteAsync(new CustomersQuery {Country = country});            
        return Ok(customers);
    }
}
</code></pre></div>


<p>A typical test for this controller would look like this.</p>
<div class="codehilite"><pre><span></span><code>[Fact]
public async Task ShouldGetCustomersUsingTestServer()
{
    using (var server = TestServer.Create&lt;Startup&gt;())
    {
        HttpClient client = server.HttpClient;
        HttpResponseMessage response = await client.GetAsync(&quot;api/customers?country=Germany&quot;);
        string content = await response.Content.ReadAsStringAsync();
        Customer[] customers = JsonConvert.DeserializeObject&lt;Customer[]&gt;(content);
        Assert.Equal(11, customers.Length);
    }
}
</code></pre></div>


<p>Let's create an extension method to help us shorten this code a bit.</p>
<div class="codehilite"><pre><span></span><code>public static class HttpClientExtensions
{
    public static async Task&lt;Response&lt;TResult&gt;&gt; GetAsync&lt;TResult&gt;(this HttpClient client, string requestUri)
    {

        var responseMessage = await client.GetAsync(requestUri).ConfigureAwait(false);
        Response&lt;TResult&gt; response = new Response&lt;TResult&gt;() {Message = responseMessage};
        if (responseMessage.IsSuccessStatusCode)
        {
            var content = await responseMessage.Content.ReadAsStringAsync().ConfigureAwait(false);
            response.Value = JsonConvert.DeserializeObject&lt;TResult&gt;(content);
        }
        return response;
    }
}
</code></pre></div>


<p>This extension method returns the response as a Response&lt;T&gt; that contains the <strong>HttpResponseMessage</strong> and the typed result object. This means that we can do asserts on the actual result in addition to data related to the request such as the <strong>HttpStatusCode</strong>.</p>
<div class="codehilite"><pre><span></span><code>[Fact]
public async Task ShouldGetCustomersUsingExtensionMethod()
{
    using (var server = TestServer.Create&lt;Startup&gt;())
    {
        HttpClient client = server.HttpClient;
        var response = await client.GetAsync&lt;Customer[]&gt;(&quot;api/customers?country=Germany&quot;);
        Assert.Equal(11, response.Value.Length);
    }
}
</code></pre></div>


<p>The nice thing about the <strong>TestServer</strong> is that it allows us to pass the <strong>Startup</strong> class to be used for the test. This means that we can pass a startup class that might be specific to the test.  The startup class for this application looks like this.</p>
<div class="codehilite"><pre><span></span><code>public class Startup
{
    public Startup()
    {
        Container = new ServiceContainer();            
    }

    public void Configuration(IAppBuilder app)
    {
        var config = new HttpConfiguration();
        Configure(Container);
        ConfigureMediaFormatter(config);
        ConfigureHttpRoutes(config);
        Container.RegisterApiControllers();
        Container.EnableWebApi(config);
        app.UseWebApi(config);
    }

    private static void ConfigureMediaFormatter(HttpConfiguration configuration)
    {
        configuration.Formatters.Clear();
        configuration.Formatters.Add(new JsonMediaTypeFormatter());
    }

    private static void ConfigureHttpRoutes(HttpConfiguration config)
    {
        config.Routes.MapHttpRoute(
            name: &quot;API Default&quot;,
            routeTemplate: &quot;api/{controller}/{id}&quot;,
            defaults: new { id = RouteParameter.Optional });
    }

    public virtual void Configure(IServiceContainer serviceContainer)
    {
        serviceContainer.RegisterFrom&lt;CompositionRoot&gt;();        
    }

    public IServiceContainer Container { get; }         
}
</code></pre></div>


<p>The thing to notice here is that we have a virtual <strong>Configure</strong> method that makes it possible to inherit from this class in a test project and override the way we configure the container.  We also expose the container used by Web Api so that we can get access to it in an inherited startup class.</p>
<p>The next class is a base class for testing controllers that makes it possible to specify the startup class type as a generic argument to the class itself.</p>
<div class="codehilite"><pre><span></span><code>public abstract class ControllerTestBase&lt;TStartup&gt; where TStartup : Startup, new()
{
    public static void Configure(IServiceContainer container)
    {
        var startup = new TStartup();
        container.Register(factory =&gt; TestServer.Create(builder =&gt; startup.Configuration(builder)), new PerScopeLifetime());
        container.Register(CreateHttpClient);
    }

    private static HttpClient CreateHttpClient(IServiceFactory container)
    {
        var testServer = container.GetInstance&lt;TestServer&gt;();
        var httpClient = new HttpClient(testServer.Handler);
        httpClient.BaseAddress = testServer.BaseAddress;
        return httpClient;
    }
}
</code></pre></div>


<p>This base class now makes it possible to specify the startup class and it also allows us to inject the <strong>HttpClient</strong> instance. </p>
<div class="codehilite"><pre><span></span><code>public class ControllerTests : ControllerTestBase&lt;Startup&gt;
{
    [Theory, Scoped, InjectData]
    public async Task ShouldGetCustomersUsingInjectedClient(HttpClient client)
    {
        var response = await client.GetAsync&lt;Customer[]&gt;(&quot;api/customers?country=Germany&quot;);
        Assert.Equal(11, response.Value.Length);
    }
}
</code></pre></div>


<p>Being good REST citizens, we should also make sure that we return the correct status code along with the content. Say now that we want to test that the service returns 204-NoContent if no customers are found for the given country. 
We could do this by making sure that we have the appropriate  test data in the database or we could mock the <strong>IQueryExecutor</strong> and have it return an empty list without even touching the database.</p>
<p>By extending the <strong>HttpClient</strong> we can really simplify the way to mock services used in the test.</p>
<div class="codehilite"><pre><span></span><code>public class TestClient : HttpClient
{
    private readonly IServiceRegistry serviceRegistry;

    public TestClient(IServiceRegistry serviceRegistry, HttpMessageHandler handler) : base(handler)
    {
        this.serviceRegistry = serviceRegistry;
    }

    public Mock&lt;TService&gt; Mock&lt;TService&gt;() where TService:class 
    {
        var mock = new Mock&lt;TService&gt;();

        serviceRegistry.Override(registration =&gt; registration.ServiceType == typeof(TService),
            (factory, registration) =&gt; CreateMockRegistration(mock));

        return mock;
    }

    private static ServiceRegistration CreateMockRegistration&lt;TService&gt;(Mock&lt;TService&gt; mock) where TService:class
    {
        return new ServiceRegistration() {ServiceType = typeof(TService), Value = mock.Object };
    }
}
</code></pre></div>


<p>This class basically replaces the existing <strong>IQueryExecutor</strong> registration with a mock instance and makes it possible to mock services very easily.</p>
<div class="codehilite"><pre><span></span><code>[Theory, Scoped, InjectData]
public async Task ShouldReturnNoContent(TestClient client)
{
    var mock = client.Mock&lt;IQueryExecutor&gt;();
    mock.Setup(m =&gt; m.ExecuteAsync(It.IsAny&lt;IQuery&lt;Customer[]&gt;&gt;())).ReturnsAsync(new Customer[] {});

    var response = await client.GetAsync&lt;Customer[]&gt;(&quot;api/customers?country=Germany&quot;);

    Assert.Equal(HttpStatusCode.NoContent, response.Message.StatusCode);
}
</code></pre></div>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../webapirequestlogging/" title="Web Api Request Logging" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Web Api Request Logging
              </span>
            </div>
          </a>
        
        
          <a href="../aspnetcoreunittesting/" title="AspNetCore unit testing" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                AspNetCore unit testing
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org" target="_blank" rel="noopener">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.c33a9706.js"></script>
      
      <script>app.initialize({version:"1.1",url:{base:".."}})</script>
      
    
  </body>
</html>