{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installing \u00b6 LightInject provides two distribution models via NuGet Binary \u00b6 PM> Install-Package LightInject This adds a reference to the LightInject.dll in the target project. Source \u00b6 PM> Install-Package LightInject.Source This will install a single file (LightInject.cs) into the current project. Creating a container \u00b6 var container = new LightInject . ServiceContainer (); The container implements IDisposable and should be disposed after usage has completed. It can also be used inside of a using statement for a constrained scope. Default services \u00b6 public interface IFoo {} public class Foo : IFoo {} container . Register < IFoo , Foo >(); var instance = container . GetInstance < IFoo >(); Assert . IsInstanceOfType ( instance , typeof ( Foo )); Named services \u00b6 public class Foo : IFoo {} public class AnotherFoo : IFoo {} container . Register < IFoo , Foo >(); container . Register < IFoo , AnotherFoo >( \"AnotherFoo\" ); var instance = container . GetInstance < IFoo >( \"AnotherFoo\" ); Assert . IsInstanceOfType ( instance , typeof ( AnotherFoo )); If only one named registration exists, LightInject is capable of resolving this as the default service. container . Register < IFoo , AnotherFoo >( \"AnotherFoo\" ); var instance = container . GetInstance < IFoo >(); Assert . IsInstanceOfType ( instance , typeof ( AnotherFoo )); Unresolved services \u00b6 LightInject can resolve services that are not registered with the container using the RegisterFallback method. var container = new ServiceContainer (); container . RegisterFallback (( type , s ) => true , request => new Foo ()); var foo = container . GetInstance < IFoo >(); The first argument to the RegisterFallback method makes it possible to possible to decide if the service can be \"late-resolved\". The second argument is a ServiceRequest instance that provides the requested service type and service name. IEnumerable<T> \u00b6 When we register multiple services with the same service type, LightInject is capable of resolving these services as an IEnumerable<T> . public class Foo : IFoo {} public class AnotherFoo : IFoo {} container . Register < IFoo , Foo >(); container . Register < IFoo , AnotherFoo >( \"AnotherFoo\" ); var instances = container . GetInstance < IEnumerable < IFoo >>(); Assert . AreEqual ( 2 , instances . Count ()); Alternatively using the GetAllInstances method. var instances = container . GetAllInstances < IFoo >(); Assert . AreEqual ( 2 , instances . Count ()); In addition, LightInject supports the following IEnumerable<T> sub-types. Array ICollection<T> IList<T> IReadOnlyCollection<T> (Net 4.5 and Windows Runtime); IReadOnlyList<T> (Net 4.5 and Windows Runtime) By default, LightInject will resolve all services that are compatible with the requested element type. container . Register < Foo >(); container . Register < DerivedFoo >(); var instances = container . GetAllInstances < Foo >(); Assert . AreEqual ( 2 , instances . Count ()); This behavior can be overridden using the EnableVariance container option. var container = new ServiceContainer ( new ContainerOptions { EnableVariance = false }); container . Register < Foo >(); container . Register < DerivedFoo >(); var instances = container . GetAllInstances < Foo >(); Assert . AreEqual ( 1 , instances . Count ()); We can also selectively decide to apply variance only for certain IEnumerable<T> services. options . VarianceFilter = ( enumerableType ) => enumerableType . GetGenericArguments ()[ 0 ] == typeof ( IFoo ); Ordering \u00b6 Sometimes the ordering of the resolved services are important and LightInject solves this by ordering services by their service name. container . Register < IFoo , Foo1 >( \"A\" ); container . Register < IFoo , Foo2 >( \"B\" ); container . Register < IFoo , Foo3 >( \"C\" ); var instances = container . GetAllInstances < IFoo >(). ToArray (); Assert . IsType < Foo1 >( instances [ 0 ]); Assert . IsType < Foo2 >( instances [ 1 ]); Assert . IsType < Foo3 >( instances [ 2 ]); We can also register multiple implementations for a given service type using the RegisterOrdered method. var container = CreateContainer (); container . RegisterOrdered ( typeof ( IFoo ), new [] { typeof ( Foo1 ), typeof ( Foo2 ), typeof ( Foo3 )}, type => new PerContainerLifetime ()); var instances = container . GetAllInstances < IFoo >(). ToArray (); Assert . IsType < Foo1 >( instances [ 0 ]); Assert . IsType < Foo2 >( instances [ 1 ]); Assert . IsType < Foo3 >( instances [ 2 ]); The RegisterOrdered method gives each implementation a service name that can be used for ordering when resolving these services. By default the service name is formatted like 001 , 002 and so on. If we need so change this convention, we can do this by passing a format function to the RegisterOrdered method. container . RegisterOrdered ( typeof ( IFoo <>), new [] { typeof ( Foo1 <>), typeof ( Foo2 <>), typeof ( Foo3 <>) }, type => new PerContainerLifetime (), i => $ \"A{i.ToString().PadLeft(3,'0')}\" ); var services = container . AvailableServices . Where ( sr => sr . ServiceType == typeof ( IFoo <>)) . OrderBy ( sr => sr . ServiceName ). ToArray (); Assert . Equal ( \"A001\" , services [ 0 ]. ServiceName ); Assert . Equal ( \"A002\" , services [ 1 ]. ServiceName ); Assert . Equal ( \"A003\" , services [ 2 ]. ServiceName ); Values \u00b6 Registers the value as a constant. container . RegisterInstance < string >( \"SomeValue\" ); var value = container . GetInstance < string >(); Assert . AreEqual ( \"SomeValue, value); Compilation \u00b6 LightInject uses dynamic code compilation either in the form of System.Reflection.Emit or compiled expression trees. When a service is requested from the container, the code needed for creating the service instance is generated and compiled and a delegate for that code is stored for lookup later on so that we only compile it once. These delegates are stored in an AVL tree that ensures maximal performance when looking up a delegate for a given service type. If fact, looking up these delegates is what sets the top performing containers apart. Most high performance container emits approximately the same code, but the approach to storing these delegates may differ. LightInject provides lock-free service lookup meaning that no locks are involved for getting a service instance after its initial generation and compilation. The only time LightInject actually creates a lock is when generating the code for a given service. That does however mean a potential lock contention problem when many concurrent requests asks for services for the first time. LightInject deals with this potential problem by providing an API for compilation typically used when an application starts. The following example shows how to compile all registered services. container . Compile (); One thing to be aware of is that not all services are backed by its own delegate. Consider the following service: public class Foo { public Foo ( Bar bar ) { Bar = bar ; } } Registered and resolved like this: container . Register < Foo >(); container . Register < Bar >(); var foo = container . GetInstance < Foo >(); In this case we only create a delegate for resolving Foo since that is the only service that is directly requested from the container. The code for creating the Bar instance is embedded inside the code for creating the Foo instance and hence there is only one delegate created. We call Foo a root service since it is directly requested from the container. In fact lets just have a look at the IL generated for creating the Foo instance. newobj Void .ctor() // Bar newobj Void .ctor(LightInject.SampleLibrary.IBar) //Foo What happens here is that a new instance of Bar is created and pushed onto the stack and then we create the Foo instance. This is the code that the delegate for Foo points to. The reason for such a relatively detailed explanation is to illustrate that we don't always create a delegate for a given service and by simply doing a container.Compile() we might create a lot of delegates that is never actually executed. Probably no big deal as long as we don't have tens of thousands of services, but just something to be aware of. LightInject does not attempt to identify root services as that would be very difficult for various reasons. We can instead use a predicate when compiling services up front. container . Compile ( sr => sr . ServiceType == typeof ( Foo )); Open Generics \u00b6 LightInject cannot compile open generic services since the actual generic arguments are not known at \"compile\" time. We can however specify the generic arguments like this: container . Compile < Foo < int >>() LightInject will create a log entry every time a new delegate is created so that information can be used to identify root services that could be compiled up front. In addition to this, a log entry (warning) is also created when trying to compile an open generic service up front. Lifetime \u00b6 The default behavior in LightInject is to treat all objects as transients unless otherwise specified. container . Register < IFoo , Foo >(); var firstInstance = container . GetInstance < IFoo >(); var secondInstance = container . GetInstance < IFoo >(); Assert . AreNotSame ( firstInstance , secondInstance ); PerScopeLifetime \u00b6 Ensures that only one instance of a given service can exists within a scope. The container will call the Dispose method on all disposable objects created within the scope. container . Register < IFoo , Foo >( new PerScopeLifetime ()); using ( container . BeginScope ()) { var firstInstance = container . GetInstance < IFoo >(); var secondInstance = container . GetInstance < IFoo >(); Assert . AreSame ( firstInstance , secondInstance ); } Note: An InvalidOperationException is thrown if a service registered with the PerScopeLifetime is requested outside the scope. PerContainerLifetime \u00b6 Ensures that only one instance of a given service can exist within the container. The container will call the Dispose method on all disposable objects when the container itself is disposed. using ( container = new ServiceContainer ()) { container . Register < IFoo , Foo >( new PerContainerLifetime ()); var firstInstance = container . GetInstance < IFoo >(); var secondInstance = container . GetInstance < IFoo >(); Assert . AreSame ( firstInstance , secondInstance ); } PerRequestLifeTime \u00b6 A new instance is created for each request and the container calls Dispose when the scope ends. This lifetime is used when the conrete class implements IDisposable . container . Register < IFoo , Foo >( new PerRequestLifeTime ()); using ( container . BeginScope ()) { var firstInstance = container . GetInstance < IFoo >(); var secondInstance = container . GetInstance < IFoo >(); Assert . AreNotSame ( firstInstance , secondInstance ); } Note: An InvalidOperationException is thrown if a service registered with the PerRequestLifeTime is requested outside the scope. Custom lifetime \u00b6 A custom lifetime is created by implementing the ILifetime interface internal interface ILifetime { object GetInstance ( Func < object > instanceFactory , Scope currentScope ); } The following example shows to create a custom lifetime that ensures only one instance per thread. public class PerThreadLifetime : ILifetime { ThreadLocal < object > instances = new ThreadLocal < object >(); public object GetInstance ( Func < object > instanceFactory , Scope currentScope ) { if ( instances . value == null ) { instances . value = instanceFactory (); } return instances . value ; } } That is all it takes to create a custom lifetime, but what about disposable services? public class PerThreadLifetime : ILifetime { ThreadLocal < object > instances = new ThreadLocal < object >(); public object GetInstance ( Func < object > instanceFactory , Scope currentScope ) { if ( instances . value == null ) { object instance = instanceFactory (); IDisposable disposable = instance as IDisposable ; if ( disposable != null ) { if ( currentScope == null ) { throw new InvalidOperationException ( \"Attempt to create an disposable object without a current scope . \") } currentScope . TrackInstance ( disposable ); } instances . value = instance ; } return instance . value ; } } Important \u00b6 A lifetime object controls the lifetime of a single service and can never be shared for multiple service registrations. Wrong ILifetime lifetime = new PerContainerLifeTime (); container . Register < IFoo , Foo >( lifetime ); container . Register < IBar , Bar >( lifetime ); Right container . Register < IFoo , Foo >( new PerContainerLifeTime ()); container . Register < IBar , Bar >( new PerContainerLifeTime ()); A lifetime object is also shared across threads and that is something we must take into consideration when developing new lifetime implementations. Async and Await \u00b6 By default scopes are managed per thread which means that when the container looks for the current scope, it will look for a scope that is associated with the current thread. With the introduction of the async/await pattern chances are that the code that is requesting a service instance is running on another thread. To illustrate this lets consider an example that is going to cause an instance to be resolved on another thread. We start of by creating an interface that returns a Task<IBar> public interface IAsyncFoo { Task < IBar > GetBar (); } Next we implement this interface in such a way that the IBar instance is requested on another thread. public class AsyncFoo : IAsyncFoo { private readonly Lazy < IBar > lazyBar ; public AsyncFoo ( Lazy < IBar > lazyBar ) { this . lazyBar = lazyBar ; } public async Task < IBar > GetBar () { await Task . Delay ( 10 ); return lazyBar . Value ; <-- This code is executed on another thread ( continuation ). } } The we register the dependency ( IBar ) with the PerScopeLifetime that is going to cause the container to ask for the current scope so that the instance can be registered with that scope. var container = new ServiceContainer (); container . Register < IBar , Bar >( new PerScopeLifetime ()); container . Register < IAsyncFoo , AsyncFoo >(); using ( container . BeginScope ()) { var instance = container . GetInstance < IAsyncFoo >(); ExceptionAssert . Throws < AggregateException >(() => instance . GetBar (). Wait ()); } This will throw an exception that states the following: Attempt to create a scoped instance without a current scope. The reason that this is happening is that the current scope is associated with the thread that created it and when the continuation executes, we are essentially requesting an instance on another thread. To deal with this issue, LightInject now supports scopes across the logical CallContext . var container = new ServiceContainer (); container . ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider (); container . Register < IBar , Bar >( new PerScopeLifetime ()); container . Register < IAsyncFoo , AsyncFoo >(); using ( container . BeginScope ()) { var instance = container . GetInstance < IAsyncFoo >(); var bar = instance . GetBar (). Result ; Assert . IsInstanceOfType ( bar , typeof ( IBar )); } Note that the PerLogicalCallContextScopeManagerProvider is only available when running under .Net 4.5. For more information, please refer to the following article by Stephen Cleary. Scope \u00b6 The purpose of the scope is to track the services created within the scope. For instance, the PerScopeLifetime uses the scope to ensure that we only create a single service instance even if it requested multiple times. One of the most canonical examples would be in a web application where we need to inject IDbConnection into different services. Let say that we have an OrderController and we need two services to process the order. public class CustomerService : ICustomerService { public CustomerService ( IDbConnection dbConnection ) { } } public class OrderService : IOrderService { public OrderService ( IDbConnection dbConnection ) { } } public class OrderController { public OrderController ( ICustomerService customerService , IOrderService orderService ) { } } As we can see the OrderController depends on both the CustomerService and the OrderService which are both dependant upon an IDbConnection . By registering the IDbConnection as a scoped service we ensure two things. Only a single instance of IDbConnection will ever be created inside a scope. The IDbConnection instance is disposed when the scope ends. container . RegisterScoped < IDbConnection >( factory => new ProviderSpecificConnection ()); So when and how do we start these scopes? She short answer is that most of the time, we don't. For instance, in AspNetCore, the scopes are started and ended by the AspNetCore infrastructure so we don't have to think about that when developing web application. A scope is started when the web request starts and it ended when the web request ends. It is really that simple, one request equals one scope. So in LightInject , we register a scoped service using RegisterScoped without really thinking about when and how the scopes are started and ended. In a web application this usually means a web request, but for other applications it can mean something else. Maybe for a UI application it means a page/window/form or something similar. To start a scope manually we can create scope using the BeginScope method using ( container . BeginScope ()) { var dbConnection = container . GetInstance < IDbConnection >(); } Note: The Scope implement IDisposable and should always be wrapped in a using block to ensure its disposal In this example we start a new scope and retrieve the service from the container which means that LightInject uses the \"current\" scope to resolve the service. This is only supported for backwards compatibility and should be avoided if possible. The recommended approach is to retrieve services directly from the scope. using ( var scope = container . BeginScope ()) { var dbConnection = scope . GetInstance < IDbConnection >(); } Since we are retrieving the service directly from the scope, the current scope is ignored and we simply use the scope from which the service was requested. This is not only much faster, but it is also a much safer way to deal with scopes. This also allows for multiple active scopes. using ( var outerScope = container . BeginScope ()) { using ( var innerScope = container . BeginScope ()) { var outerDbConnection = outerScope . GetInstance < IDbConnection >(); var innerDbConnection = innerScope . GetInstance < IDbConnection >(); } } In addition to the PerScopeLifetime which ensures disposal and a single instance within a scope, we also have the PerRequestLifetime . This lifetime behaves just a transient meaning that we get a new instance for every time it is requested with the only difference to transients being that instances are disposed when the scope ends. Note: The PerRequestLifetime has NO relation to the notion of a web request. If we don't need access to an ambient scope, we can disable this in the ContainerOptions var container = new ServiceContainer ( o => o . EnableCurrentScope = false ); This also improves performance ever so slightly as we don't need to maintain a current scope when scopes are started and ended. Dependencies \u00b6 Constructor Injection \u00b6 public interface IFoo {} public interface IBar {} public class Foo : IFoo { public Foo ( IBar bar ) { Bar = bar ; } public IBar Bar { get ; private set ; } } public class Bar : IBar {} Implicit service registration \u00b6 Registers a service without specifying any information about how to resolve the constructor dependencies of the implementing type. container . Register < IFoo , Foo >(); container . Register < IBar , Bar >(); var foo = ( Foo ) container . GetInstance < IFoo >(); Assert . IsInstanceOfType ( foo . Bar , typeof ( Bar )); Note: In the case where the implementing type(Foo) has more than one constructor, LightInject will choose the constructor with the most parameters. For fine grained control of the injected constructor dependencies, we can provide a factory that makes it possible to create an instance of a given constructor dependency. container . RegisterConstructorDependency < IBar >(( factory , parameterInfo ) => new Bar ()); This tells the container to inject a new Bar instance whenever it sees an IBar constructor dependency. Explicit service registration \u00b6 Registers a service by providing explicit information about how to create the service instance and how to resolve the constructor dependencies. \u200b \u200b container.Register (); \u200b container.Register (factory => new Foo(factory.GetInstance )); \u200b var foo = (Foo)container.GetInstance (); \u200b Assert.IsNotNull(foo.Bar); Parameters \u00b6 Parameters are used when we want to supply one or more values when the service is resolved. public class Foo : IFoo { public Foo ( int value ) { Value = value ; } public int Value { get ; private set ; } } container . Register < int , IFoo >(( arg , factory ) => new Foo ( arg )); var foo = ( Foo ) container . GetInstance < int , IFoo >( 42 ); Assert . AreEqual ( 42 , foo . Value ); We can also do a combination of supplied values and dependencies. public class Foo : IFoo { public Foo ( int value , IBar bar ) { Value = value ; } public int Value { get ; private set ; } public IBar Bar { get ; private set ; } } container . Register < IBar , Bar >(); container . Register < int , IFoo >(( factory , value ) => new Foo ( value , factory . GetInstance < IBar >())); var foo = ( Foo ) container . GetInstance < int , IFoo >( 42 ); Assert . AreEqual ( 42 , foo . Value ); Assert . IsNotNull ( foo . Bar ); Optional arguments \u00b6 LightInject will allow for default values to be used when a constructor dependency cannot be resolved. public class Foo { public Foo ( string value = \"42\" ) { Value = value ; } public string Value { get ; } } We can still resolve Foo even though we have not registered a string service. var container = new ServiceContainer ( options => options . EnableOptionalArguments = true ); container . Register < Foo >(); var instance = container . GetInstance < Foo >(); Assert . AreEqual ( \"42\" , instance . Value ) Note that the use cases for optional dependencies should be rare and are to be used with caution. Property Injection \u00b6 public interface IFoo {} public interface IBar {} public class Foo : IFoo { public IBar Bar { get ; set ; } } public class Bar : IBar {} Implicit service registration \u00b6 Registers the service without specifying any information about how to resolve the property dependencies. container . Register < IFoo , Foo >(); container . Register < IBar , Bar >(); var foo = ( Foo ) container . GetInstance < IFoo >(); Assert . IsNotNull ( foo . bar ); Note:* LightInject considers all read/write properties a dependency, but implements a loose strategy around property dependencies, meaning that it will NOT* throw an exception in the case of an unresolved property dependency. For fine grained control of the injected property dependencies, we can provide a factory that makes it possible to create an instance of a given property dependency. container . RegisterPropertyDependency < IBar >(( factory , propertyInfo ) => new Bar ()); This tells the container to inject a new Bar instance whenever it sees an IBar property dependency. Explicit service registration \u00b6 Registers a service by providing explicit information about how to create the service instance and how to resolve the property dependencies. container . Register < IBar , Bar >(); container . Register < IFoo >( factory => new Foo () { Bar = factory . GetInstance < IBar >()}) var foo = ( Foo ) container . GetInstance < IFoo >(); Assert . IsNotNull ( foo . bar ); Property injection on existing instances. \u00b6 In the cases where we don't control the creation of the service instance, LightInject can inject property dependencies into an existing instance. container . Register < IBar , Bar >(); var foo = new Foo (); container . InjectProperties ( foo ); Assert . IsNotNull ( foo ); Disabling ProperyInjection \u00b6 Property injection is enabled by default in LightInject , but it can be disabled like this. var container = new ServiceContainer ( new ContainerOptions { EnablePropertyInjection = false }); It is actually recommended to turn off property injection unless it is really needed. Backward compatibility is the only reason that this is not the default. Initializers \u00b6 Use the Initialize method to perform service instance initialization/post-processing. container . Register < IFoo , FooWithPropertyDependency >(); container . Initialize ( registration => registration . ServiceType == typeof ( IFoo ), ( factory , instance ) => (( FooWithPropertyDependency ) instance ). Bar = new Bar ()); var foo = ( FooWithProperyDependency ) container . GetInstance < IFoo >(); Assert . IsInstanceOfType ( foo . Bar , typeof ( Bar )); Assembly Scanning \u00b6 LightInject is capable of registering services by looking at the types of a given assembly. container . RegisterAssembly ( typeof ( IFoo ). Assembly ) To filter out the services to be registered with the container, we can provide a predicate that makes it possible to inspect the service type and the implementing type. container . RegisterAssembly ( typeof ( IFoo ). Assembly , ( serviceType , implementingType ) => serviceType . NameSpace == \"SomeNamespace\" ); It is also possible to scan a set assembly files based on a search pattern. container . RegisterAssembly ( \"SomeAssemblyName*.dll\" ); When scanning assemblies, LightInject will register services using a service name that by default is the implementing type name. This behavior can be changed by specifying a function delegate to provide the name based on the service type and the implementing type. container . RegisterAssembly ( typeof ( IFoo ). Assembly , () => new PerContainerLifetime (), ( serviceType , implementingType ) => serviceType . NameSpace == \"SomeNamespace\" , ( serviceType , implementingType ) => \"Provide custom service name here\" ); We can also change this behavior globally for all registrations by implementing the IServiceNameProvider interface. public class CustomServiceNameProvider : IServiceNameProvider { public string GetServiceName ( Type serviceType , Type implementingType ) { return \"Provide custom service name here\" ; } } To change the default behavior for all registrations we simply change this dependency on the container before we start scanning assemblies. container . ServiceNameProvider = new CustomServiceNameProvider (); Composition Root \u00b6 When LightInject scans an assembly it will look for an implementation of the ICompositionRoot interface. public class SampleCompositionRoot : ICompositionRoot { public void Compose ( IServiceRegistry serviceRegistry ) { serviceRegistry . Register ( typeof ( IFoo ), typeof ( Foo )); } } If one or more implementations of the ICompositionRoot interface is found, they will be created and executed. Note: Any other services contained within the target assembly that is not registered in the composition root, will NOT be registered. Rather that having a single composition root that basically needs to reference all other assemblies, having multiple composition roots makes it possible to group services naturally together. Another advantage of registering services in a ICompositionRoot , is that they can easily be reused in automated tests. Lazy Composition Roots \u00b6 LightInject is capable of registering services on a need to have basis. For a large application that has a lot of services, it might not be the best solution to register all these services up front as this could seriously hurt the startup time of our application due to extensive assembly loading. If an unregistered service is requested, LightInject will scan the assembly where this service is contained. CompositionRootAttribute \u00b6 When an assembly is being scanned, LightInject will look for implementations of the ICompositionRoot interface. For large assemblies that contains many type, this might be an expensive operation. The CompositionRootAttribute is an assembly level attribute that simply helps LightInject to locate the compostion root. [assembly: CompositionRootType(typeof(SampleCompositionRoot))] RegisterFrom \u00b6 Allows explicit execution of a composition root. container . RegisterFrom < SampleCompositionRoot >(); Generics \u00b6 public interface IFoo < T > {}; public class Foo < T > : IFoo < T > {}; The container creates the closed generic type based on the service request. container . Register ( typeof ( IFoo <>), typeof ( Foo <>)); var instance = container . GetInstance ( typeof ( IFoo < int >)); Assert . IsInstanceOfType ( instance , typeof ( Foo < int >)); Constraints \u00b6 LightInject enforces generic constrains Lazy<T> \u00b6 LightInject can resolve a service as an instance of Lazy<T> when we want to postpone resolving the underlying service until it is needed. public interface IFoo {} public class Foo : IFoo {} container . Register < IFoo , Foo >(); var lazyFoo = container . GetInstance < Lazy < IFoo >>(); Assert . IsNotNull ( lazyFoo . Value ); Function Factories \u00b6 Function factories allows services to resolved as a function delegate that in turn is capable of returning the underlying service instance. We can think of this as an alternative to the Service Locator (anti)pattern. public interface IFoo {} public class Foo : IFoo {} container . Register < IFoo , Foo >(); var func = container . GetInstance < Func < IFoo >>(); var foo = func (); Assert . IsNotNull ( foo ); Note: A function factory is effectively a delegate that redirects back to the corresponding GetInstance method on the service container. Named Factories \u00b6 The container returns a function delegate that represents calling the GetInstance method with \"SomeFoo\" as the service name argument. container . Register < IFoo , Foo >( \"SomeFoo\" ); var func = container . GetInstance < Func < IFoo >>( \"SomeFoo\" ); var foo = func (); Assert . IsNotNull ( foo ); Parameters \u00b6 Function factories can also take parameters that will be used create the service instance. public class Foo : IFoo { public Foo ( int value ) { Value = value ; } public int Value { get ; private set ; } } container . Register < int , IFoo >(( factory , value ) => new Foo ( value )); var fooFactory = container . GetInstance < Func < int , IFoo >>(); var foo = ( Foo ) fooFactory ( 42 ); Assert . AreEqual ( foo . Value , 42 ); Note : The service must be explicitly registered in order for the container to resolve it as a parameterized function factory. IDisposable \u00b6 The only way to deal with disposable objects when using function factories, is to let the service type inherit from IDisposable. public interface IFoo : IDisposable {} public class Foo : IFoo {} container . Register < IFoo , Foo >(); var fooFactory = container . GetInstance < Func < IFoo >>(); using ( IFoo foo = fooFactory ()) { } <-- Instance is disposed here Note: Although this is common practice even in the BCL , this kind of interfaces are often referred to as leaky abstractions . Typed Factories \u00b6 A typed factory is a class that wraps the function factory that is used to create the underlying service instance. As opposed to just function factories, typed factories provides better expressiveness to the consumer of the factory. public interface IFooFactory { IFoo GetFoo (); } public class FooFactory : IFooFactory { private Func < IFoo > createFoo ; public FooFactory ( Func < IFoo > createFoo ) { this . createFoo = createFoo ; } public IFoo GetFoo () { return createFoo (); } } container . Register < IFoo , Foo >(); container . Register < IFooFactory , FooFactory >( new PerContainerLifetime ()); var fooFactory = container . GetInstance < IFooFactory >(); var foo = fooFactory . GetFoo (); Assert . IsNotNull ( foo ); Note: Register typed factories with the PerContainerLifetime unless a compelling reason exists to choose a different lifetime. Parameters \u00b6 Types factories can also wrap a parameterized function factory and allows us to pass arguments. public class Foo : IFoo { public Foo ( int value ) { Value = value ; } public int Value { get ; private set ; } } public interface IFooFactory { IFoo GetFoo ( int value ); } public class FooFactory : IFooFactory { private Func < int , IFoo > createFoo ; public FooFactory ( Func < int , IFoo > createFoo ) { this . createFoo = createFoo ; } public IFoo GetFoo ( int value ) { return createFoo ( value ); } } container . Register < int , IFoo >(( factory , value ) => new Foo ( value )); container . Register < IFooFactory , FooFactory >( new PerContainerLifetime ()); var typedFooFactory = container . GetInstance < IFooFactory >(); var foo = typedFooFactory . GetFoo ( 42 ); Assert . AreEqual ( foo . Value , 42 ); IDisposable \u00b6 Working with typed factories gives us the possibility to release disposable services registered as transients without exposing a leaky abstraction. public interface IFooFactory { IFoo GetFoo ( int value ); void Release ( IFoo foo ); } public class FooFactory : IFooFactory { private Func < IFoo > createFoo ; public FooFactory ( Func < IFoo > createFoo ) { this . createFoo = createFoo ; } public IFoo GetFoo ( int value ) { return createFoo ( value ); } public void Release ( IFoo foo ) { var disposable = foo as IDisposable ; if ( disposable != null ) { disposable . Dispose (); } } } Recursive dependency detection \u00b6 A recursive dependency graph is when a service depends directly or indirectly on itself. public class FooWithRecursiveDependency : IFoo { public FooWithRecursiveDependency ( IFoo foo ) { } } The following code will throw an InvalidOperationException stating that there are existing recursive dependencies. container . Register ( typeof ( IFoo ), typeof ( FooWithRecursiveDependency )); container . GetInstance < IFoo >() Internals \u00b6 When running under the .Net platform, LightInject is capable of creating instances of classes that has the internal modifier. The only requirement is that the internal class exposes a public constructor. internal class InternalFooWithPublicConstructor : IFoo { public InternalFooWithPublicConstructor () {} } Logging \u00b6 Sometimes it might be useful to obtain information about what is going on inside the container and LightInject provides a very simple log abstraction that is used to log information and warnings from within the container. var containerOptions = new ContainerOptions (); containerOptions . LogFactory = ( type ) => logEntry => Console . WriteLine ( logEntry . Message ); Unit Testing \u00b6 Sometimes it might be useful to use the service container within our unit tests. LightInject also provides the LightInject.xUnit extension that enables dependencies to be injected into test methods. One side effect of using that extension is that it is tightly coupled to xUnit and it we have less control with regards to container instances. Instead consider this simple base class public class ContainerFixture : IDisposable { public ContainerFixture () { var container = CreateContainer (); Configure ( container ); container . RegisterFrom < CompositionRoot >(); ServiceFactory = container . BeginScope (); InjectPrivateFields (); } private void InjectPrivateFields () { var privateInstanceFields = this . GetType (). GetFields ( BindingFlags . Public | BindingFlags . NonPublic | BindingFlags . Instance ); foreach ( var privateInstanceField in privateInstanceFields ) { privateInstanceField . SetValue ( this , GetInstance ( ServiceFactory , privateInstanceField )); } } internal Scope ServiceFactory { get ; } public void Dispose () => ServiceFactory . Dispose (); public TService GetInstance < TService >( string name = \"\" ) => ServiceFactory . GetInstance < TService >( name ); private object GetInstance ( IServiceFactory factory , FieldInfo field ) => ServiceFactory . TryGetInstance ( field . FieldType ) ?? ServiceFactory . GetInstance ( field . FieldType , field . Name ); internal virtual IServiceContainer CreateContainer () => new ServiceContainer (); internal virtual void Configure ( IServiceRegistry serviceRegistry ) {} } This can be use with any test framework as long as it creates a new instance of the test class for each test method and that it calls Dispose after the test completes. For xUnit this is the default behaviour. Injecting services now becomes incredible easy. Just declare the service to test as a private field like this. public class SampleTests : ContainerFixture { private ICalculator calculator ; [Fact] public void ShouldAddNumbers () { calculator . Add ( 2 , 2 ). ShouldBe ( 2 ); } } If we need to configure the container before executing the test, we can do that by simply overriding the Configure method. This could for instance be used to register mock services into the container. public class SampleTests : ContainerFixture { private ICalculator calculator ; [Fact] public void ShouldAddNumbers () { calculator . Add ( 2 , 2 ). ShouldBe ( 2 ); } internal override Configure ( IServiceRegistry serviceRegistry ) { // Add registrations related to testing here } }","title":"Home"},{"location":"#installing","text":"LightInject provides two distribution models via NuGet","title":"Installing"},{"location":"#binary","text":"PM> Install-Package LightInject This adds a reference to the LightInject.dll in the target project.","title":"Binary"},{"location":"#source","text":"PM> Install-Package LightInject.Source This will install a single file (LightInject.cs) into the current project.","title":"Source"},{"location":"#creating-a-container","text":"var container = new LightInject . ServiceContainer (); The container implements IDisposable and should be disposed after usage has completed. It can also be used inside of a using statement for a constrained scope.","title":"Creating a container"},{"location":"#default-services","text":"public interface IFoo {} public class Foo : IFoo {} container . Register < IFoo , Foo >(); var instance = container . GetInstance < IFoo >(); Assert . IsInstanceOfType ( instance , typeof ( Foo ));","title":"Default services"},{"location":"#named-services","text":"public class Foo : IFoo {} public class AnotherFoo : IFoo {} container . Register < IFoo , Foo >(); container . Register < IFoo , AnotherFoo >( \"AnotherFoo\" ); var instance = container . GetInstance < IFoo >( \"AnotherFoo\" ); Assert . IsInstanceOfType ( instance , typeof ( AnotherFoo )); If only one named registration exists, LightInject is capable of resolving this as the default service. container . Register < IFoo , AnotherFoo >( \"AnotherFoo\" ); var instance = container . GetInstance < IFoo >(); Assert . IsInstanceOfType ( instance , typeof ( AnotherFoo ));","title":"Named services"},{"location":"#unresolved-services","text":"LightInject can resolve services that are not registered with the container using the RegisterFallback method. var container = new ServiceContainer (); container . RegisterFallback (( type , s ) => true , request => new Foo ()); var foo = container . GetInstance < IFoo >(); The first argument to the RegisterFallback method makes it possible to possible to decide if the service can be \"late-resolved\". The second argument is a ServiceRequest instance that provides the requested service type and service name.","title":"Unresolved services"},{"location":"#ienumerablet","text":"When we register multiple services with the same service type, LightInject is capable of resolving these services as an IEnumerable<T> . public class Foo : IFoo {} public class AnotherFoo : IFoo {} container . Register < IFoo , Foo >(); container . Register < IFoo , AnotherFoo >( \"AnotherFoo\" ); var instances = container . GetInstance < IEnumerable < IFoo >>(); Assert . AreEqual ( 2 , instances . Count ()); Alternatively using the GetAllInstances method. var instances = container . GetAllInstances < IFoo >(); Assert . AreEqual ( 2 , instances . Count ()); In addition, LightInject supports the following IEnumerable<T> sub-types. Array ICollection<T> IList<T> IReadOnlyCollection<T> (Net 4.5 and Windows Runtime); IReadOnlyList<T> (Net 4.5 and Windows Runtime) By default, LightInject will resolve all services that are compatible with the requested element type. container . Register < Foo >(); container . Register < DerivedFoo >(); var instances = container . GetAllInstances < Foo >(); Assert . AreEqual ( 2 , instances . Count ()); This behavior can be overridden using the EnableVariance container option. var container = new ServiceContainer ( new ContainerOptions { EnableVariance = false }); container . Register < Foo >(); container . Register < DerivedFoo >(); var instances = container . GetAllInstances < Foo >(); Assert . AreEqual ( 1 , instances . Count ()); We can also selectively decide to apply variance only for certain IEnumerable<T> services. options . VarianceFilter = ( enumerableType ) => enumerableType . GetGenericArguments ()[ 0 ] == typeof ( IFoo );","title":"IEnumerable&lt;T&gt;"},{"location":"#ordering","text":"Sometimes the ordering of the resolved services are important and LightInject solves this by ordering services by their service name. container . Register < IFoo , Foo1 >( \"A\" ); container . Register < IFoo , Foo2 >( \"B\" ); container . Register < IFoo , Foo3 >( \"C\" ); var instances = container . GetAllInstances < IFoo >(). ToArray (); Assert . IsType < Foo1 >( instances [ 0 ]); Assert . IsType < Foo2 >( instances [ 1 ]); Assert . IsType < Foo3 >( instances [ 2 ]); We can also register multiple implementations for a given service type using the RegisterOrdered method. var container = CreateContainer (); container . RegisterOrdered ( typeof ( IFoo ), new [] { typeof ( Foo1 ), typeof ( Foo2 ), typeof ( Foo3 )}, type => new PerContainerLifetime ()); var instances = container . GetAllInstances < IFoo >(). ToArray (); Assert . IsType < Foo1 >( instances [ 0 ]); Assert . IsType < Foo2 >( instances [ 1 ]); Assert . IsType < Foo3 >( instances [ 2 ]); The RegisterOrdered method gives each implementation a service name that can be used for ordering when resolving these services. By default the service name is formatted like 001 , 002 and so on. If we need so change this convention, we can do this by passing a format function to the RegisterOrdered method. container . RegisterOrdered ( typeof ( IFoo <>), new [] { typeof ( Foo1 <>), typeof ( Foo2 <>), typeof ( Foo3 <>) }, type => new PerContainerLifetime (), i => $ \"A{i.ToString().PadLeft(3,'0')}\" ); var services = container . AvailableServices . Where ( sr => sr . ServiceType == typeof ( IFoo <>)) . OrderBy ( sr => sr . ServiceName ). ToArray (); Assert . Equal ( \"A001\" , services [ 0 ]. ServiceName ); Assert . Equal ( \"A002\" , services [ 1 ]. ServiceName ); Assert . Equal ( \"A003\" , services [ 2 ]. ServiceName );","title":"Ordering"},{"location":"#values","text":"Registers the value as a constant. container . RegisterInstance < string >( \"SomeValue\" ); var value = container . GetInstance < string >(); Assert . AreEqual ( \"SomeValue, value);","title":"Values"},{"location":"#compilation","text":"LightInject uses dynamic code compilation either in the form of System.Reflection.Emit or compiled expression trees. When a service is requested from the container, the code needed for creating the service instance is generated and compiled and a delegate for that code is stored for lookup later on so that we only compile it once. These delegates are stored in an AVL tree that ensures maximal performance when looking up a delegate for a given service type. If fact, looking up these delegates is what sets the top performing containers apart. Most high performance container emits approximately the same code, but the approach to storing these delegates may differ. LightInject provides lock-free service lookup meaning that no locks are involved for getting a service instance after its initial generation and compilation. The only time LightInject actually creates a lock is when generating the code for a given service. That does however mean a potential lock contention problem when many concurrent requests asks for services for the first time. LightInject deals with this potential problem by providing an API for compilation typically used when an application starts. The following example shows how to compile all registered services. container . Compile (); One thing to be aware of is that not all services are backed by its own delegate. Consider the following service: public class Foo { public Foo ( Bar bar ) { Bar = bar ; } } Registered and resolved like this: container . Register < Foo >(); container . Register < Bar >(); var foo = container . GetInstance < Foo >(); In this case we only create a delegate for resolving Foo since that is the only service that is directly requested from the container. The code for creating the Bar instance is embedded inside the code for creating the Foo instance and hence there is only one delegate created. We call Foo a root service since it is directly requested from the container. In fact lets just have a look at the IL generated for creating the Foo instance. newobj Void .ctor() // Bar newobj Void .ctor(LightInject.SampleLibrary.IBar) //Foo What happens here is that a new instance of Bar is created and pushed onto the stack and then we create the Foo instance. This is the code that the delegate for Foo points to. The reason for such a relatively detailed explanation is to illustrate that we don't always create a delegate for a given service and by simply doing a container.Compile() we might create a lot of delegates that is never actually executed. Probably no big deal as long as we don't have tens of thousands of services, but just something to be aware of. LightInject does not attempt to identify root services as that would be very difficult for various reasons. We can instead use a predicate when compiling services up front. container . Compile ( sr => sr . ServiceType == typeof ( Foo ));","title":"Compilation"},{"location":"#open-generics","text":"LightInject cannot compile open generic services since the actual generic arguments are not known at \"compile\" time. We can however specify the generic arguments like this: container . Compile < Foo < int >>() LightInject will create a log entry every time a new delegate is created so that information can be used to identify root services that could be compiled up front. In addition to this, a log entry (warning) is also created when trying to compile an open generic service up front.","title":"Open Generics"},{"location":"#lifetime","text":"The default behavior in LightInject is to treat all objects as transients unless otherwise specified. container . Register < IFoo , Foo >(); var firstInstance = container . GetInstance < IFoo >(); var secondInstance = container . GetInstance < IFoo >(); Assert . AreNotSame ( firstInstance , secondInstance );","title":"Lifetime"},{"location":"#perscopelifetime","text":"Ensures that only one instance of a given service can exists within a scope. The container will call the Dispose method on all disposable objects created within the scope. container . Register < IFoo , Foo >( new PerScopeLifetime ()); using ( container . BeginScope ()) { var firstInstance = container . GetInstance < IFoo >(); var secondInstance = container . GetInstance < IFoo >(); Assert . AreSame ( firstInstance , secondInstance ); } Note: An InvalidOperationException is thrown if a service registered with the PerScopeLifetime is requested outside the scope.","title":"PerScopeLifetime"},{"location":"#percontainerlifetime","text":"Ensures that only one instance of a given service can exist within the container. The container will call the Dispose method on all disposable objects when the container itself is disposed. using ( container = new ServiceContainer ()) { container . Register < IFoo , Foo >( new PerContainerLifetime ()); var firstInstance = container . GetInstance < IFoo >(); var secondInstance = container . GetInstance < IFoo >(); Assert . AreSame ( firstInstance , secondInstance ); }","title":"PerContainerLifetime"},{"location":"#perrequestlifetime","text":"A new instance is created for each request and the container calls Dispose when the scope ends. This lifetime is used when the conrete class implements IDisposable . container . Register < IFoo , Foo >( new PerRequestLifeTime ()); using ( container . BeginScope ()) { var firstInstance = container . GetInstance < IFoo >(); var secondInstance = container . GetInstance < IFoo >(); Assert . AreNotSame ( firstInstance , secondInstance ); } Note: An InvalidOperationException is thrown if a service registered with the PerRequestLifeTime is requested outside the scope.","title":"PerRequestLifeTime"},{"location":"#custom-lifetime","text":"A custom lifetime is created by implementing the ILifetime interface internal interface ILifetime { object GetInstance ( Func < object > instanceFactory , Scope currentScope ); } The following example shows to create a custom lifetime that ensures only one instance per thread. public class PerThreadLifetime : ILifetime { ThreadLocal < object > instances = new ThreadLocal < object >(); public object GetInstance ( Func < object > instanceFactory , Scope currentScope ) { if ( instances . value == null ) { instances . value = instanceFactory (); } return instances . value ; } } That is all it takes to create a custom lifetime, but what about disposable services? public class PerThreadLifetime : ILifetime { ThreadLocal < object > instances = new ThreadLocal < object >(); public object GetInstance ( Func < object > instanceFactory , Scope currentScope ) { if ( instances . value == null ) { object instance = instanceFactory (); IDisposable disposable = instance as IDisposable ; if ( disposable != null ) { if ( currentScope == null ) { throw new InvalidOperationException ( \"Attempt to create an disposable object without a current scope . \") } currentScope . TrackInstance ( disposable ); } instances . value = instance ; } return instance . value ; } }","title":"Custom lifetime"},{"location":"#important","text":"A lifetime object controls the lifetime of a single service and can never be shared for multiple service registrations. Wrong ILifetime lifetime = new PerContainerLifeTime (); container . Register < IFoo , Foo >( lifetime ); container . Register < IBar , Bar >( lifetime ); Right container . Register < IFoo , Foo >( new PerContainerLifeTime ()); container . Register < IBar , Bar >( new PerContainerLifeTime ()); A lifetime object is also shared across threads and that is something we must take into consideration when developing new lifetime implementations.","title":"Important"},{"location":"#async-and-await","text":"By default scopes are managed per thread which means that when the container looks for the current scope, it will look for a scope that is associated with the current thread. With the introduction of the async/await pattern chances are that the code that is requesting a service instance is running on another thread. To illustrate this lets consider an example that is going to cause an instance to be resolved on another thread. We start of by creating an interface that returns a Task<IBar> public interface IAsyncFoo { Task < IBar > GetBar (); } Next we implement this interface in such a way that the IBar instance is requested on another thread. public class AsyncFoo : IAsyncFoo { private readonly Lazy < IBar > lazyBar ; public AsyncFoo ( Lazy < IBar > lazyBar ) { this . lazyBar = lazyBar ; } public async Task < IBar > GetBar () { await Task . Delay ( 10 ); return lazyBar . Value ; <-- This code is executed on another thread ( continuation ). } } The we register the dependency ( IBar ) with the PerScopeLifetime that is going to cause the container to ask for the current scope so that the instance can be registered with that scope. var container = new ServiceContainer (); container . Register < IBar , Bar >( new PerScopeLifetime ()); container . Register < IAsyncFoo , AsyncFoo >(); using ( container . BeginScope ()) { var instance = container . GetInstance < IAsyncFoo >(); ExceptionAssert . Throws < AggregateException >(() => instance . GetBar (). Wait ()); } This will throw an exception that states the following: Attempt to create a scoped instance without a current scope. The reason that this is happening is that the current scope is associated with the thread that created it and when the continuation executes, we are essentially requesting an instance on another thread. To deal with this issue, LightInject now supports scopes across the logical CallContext . var container = new ServiceContainer (); container . ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider (); container . Register < IBar , Bar >( new PerScopeLifetime ()); container . Register < IAsyncFoo , AsyncFoo >(); using ( container . BeginScope ()) { var instance = container . GetInstance < IAsyncFoo >(); var bar = instance . GetBar (). Result ; Assert . IsInstanceOfType ( bar , typeof ( IBar )); } Note that the PerLogicalCallContextScopeManagerProvider is only available when running under .Net 4.5. For more information, please refer to the following article by Stephen Cleary.","title":"Async and Await"},{"location":"#scope","text":"The purpose of the scope is to track the services created within the scope. For instance, the PerScopeLifetime uses the scope to ensure that we only create a single service instance even if it requested multiple times. One of the most canonical examples would be in a web application where we need to inject IDbConnection into different services. Let say that we have an OrderController and we need two services to process the order. public class CustomerService : ICustomerService { public CustomerService ( IDbConnection dbConnection ) { } } public class OrderService : IOrderService { public OrderService ( IDbConnection dbConnection ) { } } public class OrderController { public OrderController ( ICustomerService customerService , IOrderService orderService ) { } } As we can see the OrderController depends on both the CustomerService and the OrderService which are both dependant upon an IDbConnection . By registering the IDbConnection as a scoped service we ensure two things. Only a single instance of IDbConnection will ever be created inside a scope. The IDbConnection instance is disposed when the scope ends. container . RegisterScoped < IDbConnection >( factory => new ProviderSpecificConnection ()); So when and how do we start these scopes? She short answer is that most of the time, we don't. For instance, in AspNetCore, the scopes are started and ended by the AspNetCore infrastructure so we don't have to think about that when developing web application. A scope is started when the web request starts and it ended when the web request ends. It is really that simple, one request equals one scope. So in LightInject , we register a scoped service using RegisterScoped without really thinking about when and how the scopes are started and ended. In a web application this usually means a web request, but for other applications it can mean something else. Maybe for a UI application it means a page/window/form or something similar. To start a scope manually we can create scope using the BeginScope method using ( container . BeginScope ()) { var dbConnection = container . GetInstance < IDbConnection >(); } Note: The Scope implement IDisposable and should always be wrapped in a using block to ensure its disposal In this example we start a new scope and retrieve the service from the container which means that LightInject uses the \"current\" scope to resolve the service. This is only supported for backwards compatibility and should be avoided if possible. The recommended approach is to retrieve services directly from the scope. using ( var scope = container . BeginScope ()) { var dbConnection = scope . GetInstance < IDbConnection >(); } Since we are retrieving the service directly from the scope, the current scope is ignored and we simply use the scope from which the service was requested. This is not only much faster, but it is also a much safer way to deal with scopes. This also allows for multiple active scopes. using ( var outerScope = container . BeginScope ()) { using ( var innerScope = container . BeginScope ()) { var outerDbConnection = outerScope . GetInstance < IDbConnection >(); var innerDbConnection = innerScope . GetInstance < IDbConnection >(); } } In addition to the PerScopeLifetime which ensures disposal and a single instance within a scope, we also have the PerRequestLifetime . This lifetime behaves just a transient meaning that we get a new instance for every time it is requested with the only difference to transients being that instances are disposed when the scope ends. Note: The PerRequestLifetime has NO relation to the notion of a web request. If we don't need access to an ambient scope, we can disable this in the ContainerOptions var container = new ServiceContainer ( o => o . EnableCurrentScope = false ); This also improves performance ever so slightly as we don't need to maintain a current scope when scopes are started and ended.","title":"Scope"},{"location":"#dependencies","text":"","title":"Dependencies"},{"location":"#constructor-injection","text":"public interface IFoo {} public interface IBar {} public class Foo : IFoo { public Foo ( IBar bar ) { Bar = bar ; } public IBar Bar { get ; private set ; } } public class Bar : IBar {}","title":"Constructor Injection"},{"location":"#implicit-service-registration","text":"Registers a service without specifying any information about how to resolve the constructor dependencies of the implementing type. container . Register < IFoo , Foo >(); container . Register < IBar , Bar >(); var foo = ( Foo ) container . GetInstance < IFoo >(); Assert . IsInstanceOfType ( foo . Bar , typeof ( Bar )); Note: In the case where the implementing type(Foo) has more than one constructor, LightInject will choose the constructor with the most parameters. For fine grained control of the injected constructor dependencies, we can provide a factory that makes it possible to create an instance of a given constructor dependency. container . RegisterConstructorDependency < IBar >(( factory , parameterInfo ) => new Bar ()); This tells the container to inject a new Bar instance whenever it sees an IBar constructor dependency.","title":"Implicit service registration"},{"location":"#explicit-service-registration","text":"Registers a service by providing explicit information about how to create the service instance and how to resolve the constructor dependencies. \u200b \u200b container.Register (); \u200b container.Register (factory => new Foo(factory.GetInstance )); \u200b var foo = (Foo)container.GetInstance (); \u200b Assert.IsNotNull(foo.Bar);","title":"Explicit service registration"},{"location":"#parameters","text":"Parameters are used when we want to supply one or more values when the service is resolved. public class Foo : IFoo { public Foo ( int value ) { Value = value ; } public int Value { get ; private set ; } } container . Register < int , IFoo >(( arg , factory ) => new Foo ( arg )); var foo = ( Foo ) container . GetInstance < int , IFoo >( 42 ); Assert . AreEqual ( 42 , foo . Value ); We can also do a combination of supplied values and dependencies. public class Foo : IFoo { public Foo ( int value , IBar bar ) { Value = value ; } public int Value { get ; private set ; } public IBar Bar { get ; private set ; } } container . Register < IBar , Bar >(); container . Register < int , IFoo >(( factory , value ) => new Foo ( value , factory . GetInstance < IBar >())); var foo = ( Foo ) container . GetInstance < int , IFoo >( 42 ); Assert . AreEqual ( 42 , foo . Value ); Assert . IsNotNull ( foo . Bar );","title":"Parameters"},{"location":"#optional-arguments","text":"LightInject will allow for default values to be used when a constructor dependency cannot be resolved. public class Foo { public Foo ( string value = \"42\" ) { Value = value ; } public string Value { get ; } } We can still resolve Foo even though we have not registered a string service. var container = new ServiceContainer ( options => options . EnableOptionalArguments = true ); container . Register < Foo >(); var instance = container . GetInstance < Foo >(); Assert . AreEqual ( \"42\" , instance . Value ) Note that the use cases for optional dependencies should be rare and are to be used with caution.","title":"Optional arguments"},{"location":"#property-injection","text":"public interface IFoo {} public interface IBar {} public class Foo : IFoo { public IBar Bar { get ; set ; } } public class Bar : IBar {}","title":"Property Injection"},{"location":"#implicit-service-registration_1","text":"Registers the service without specifying any information about how to resolve the property dependencies. container . Register < IFoo , Foo >(); container . Register < IBar , Bar >(); var foo = ( Foo ) container . GetInstance < IFoo >(); Assert . IsNotNull ( foo . bar ); Note:* LightInject considers all read/write properties a dependency, but implements a loose strategy around property dependencies, meaning that it will NOT* throw an exception in the case of an unresolved property dependency. For fine grained control of the injected property dependencies, we can provide a factory that makes it possible to create an instance of a given property dependency. container . RegisterPropertyDependency < IBar >(( factory , propertyInfo ) => new Bar ()); This tells the container to inject a new Bar instance whenever it sees an IBar property dependency.","title":"Implicit service registration"},{"location":"#explicit-service-registration_1","text":"Registers a service by providing explicit information about how to create the service instance and how to resolve the property dependencies. container . Register < IBar , Bar >(); container . Register < IFoo >( factory => new Foo () { Bar = factory . GetInstance < IBar >()}) var foo = ( Foo ) container . GetInstance < IFoo >(); Assert . IsNotNull ( foo . bar );","title":"Explicit service registration"},{"location":"#property-injection-on-existing-instances","text":"In the cases where we don't control the creation of the service instance, LightInject can inject property dependencies into an existing instance. container . Register < IBar , Bar >(); var foo = new Foo (); container . InjectProperties ( foo ); Assert . IsNotNull ( foo );","title":"Property injection on existing instances."},{"location":"#disabling-properyinjection","text":"Property injection is enabled by default in LightInject , but it can be disabled like this. var container = new ServiceContainer ( new ContainerOptions { EnablePropertyInjection = false }); It is actually recommended to turn off property injection unless it is really needed. Backward compatibility is the only reason that this is not the default.","title":"Disabling ProperyInjection"},{"location":"#initializers","text":"Use the Initialize method to perform service instance initialization/post-processing. container . Register < IFoo , FooWithPropertyDependency >(); container . Initialize ( registration => registration . ServiceType == typeof ( IFoo ), ( factory , instance ) => (( FooWithPropertyDependency ) instance ). Bar = new Bar ()); var foo = ( FooWithProperyDependency ) container . GetInstance < IFoo >(); Assert . IsInstanceOfType ( foo . Bar , typeof ( Bar ));","title":"Initializers"},{"location":"#assembly-scanning","text":"LightInject is capable of registering services by looking at the types of a given assembly. container . RegisterAssembly ( typeof ( IFoo ). Assembly ) To filter out the services to be registered with the container, we can provide a predicate that makes it possible to inspect the service type and the implementing type. container . RegisterAssembly ( typeof ( IFoo ). Assembly , ( serviceType , implementingType ) => serviceType . NameSpace == \"SomeNamespace\" ); It is also possible to scan a set assembly files based on a search pattern. container . RegisterAssembly ( \"SomeAssemblyName*.dll\" ); When scanning assemblies, LightInject will register services using a service name that by default is the implementing type name. This behavior can be changed by specifying a function delegate to provide the name based on the service type and the implementing type. container . RegisterAssembly ( typeof ( IFoo ). Assembly , () => new PerContainerLifetime (), ( serviceType , implementingType ) => serviceType . NameSpace == \"SomeNamespace\" , ( serviceType , implementingType ) => \"Provide custom service name here\" ); We can also change this behavior globally for all registrations by implementing the IServiceNameProvider interface. public class CustomServiceNameProvider : IServiceNameProvider { public string GetServiceName ( Type serviceType , Type implementingType ) { return \"Provide custom service name here\" ; } } To change the default behavior for all registrations we simply change this dependency on the container before we start scanning assemblies. container . ServiceNameProvider = new CustomServiceNameProvider ();","title":"Assembly Scanning"},{"location":"#composition-root","text":"When LightInject scans an assembly it will look for an implementation of the ICompositionRoot interface. public class SampleCompositionRoot : ICompositionRoot { public void Compose ( IServiceRegistry serviceRegistry ) { serviceRegistry . Register ( typeof ( IFoo ), typeof ( Foo )); } } If one or more implementations of the ICompositionRoot interface is found, they will be created and executed. Note: Any other services contained within the target assembly that is not registered in the composition root, will NOT be registered. Rather that having a single composition root that basically needs to reference all other assemblies, having multiple composition roots makes it possible to group services naturally together. Another advantage of registering services in a ICompositionRoot , is that they can easily be reused in automated tests.","title":"Composition Root"},{"location":"#lazy-composition-roots","text":"LightInject is capable of registering services on a need to have basis. For a large application that has a lot of services, it might not be the best solution to register all these services up front as this could seriously hurt the startup time of our application due to extensive assembly loading. If an unregistered service is requested, LightInject will scan the assembly where this service is contained.","title":"Lazy Composition Roots"},{"location":"#compositionrootattribute","text":"When an assembly is being scanned, LightInject will look for implementations of the ICompositionRoot interface. For large assemblies that contains many type, this might be an expensive operation. The CompositionRootAttribute is an assembly level attribute that simply helps LightInject to locate the compostion root. [assembly: CompositionRootType(typeof(SampleCompositionRoot))]","title":"CompositionRootAttribute"},{"location":"#registerfrom","text":"Allows explicit execution of a composition root. container . RegisterFrom < SampleCompositionRoot >();","title":"RegisterFrom"},{"location":"#generics","text":"public interface IFoo < T > {}; public class Foo < T > : IFoo < T > {}; The container creates the closed generic type based on the service request. container . Register ( typeof ( IFoo <>), typeof ( Foo <>)); var instance = container . GetInstance ( typeof ( IFoo < int >)); Assert . IsInstanceOfType ( instance , typeof ( Foo < int >));","title":"Generics"},{"location":"#constraints","text":"LightInject enforces generic constrains","title":"Constraints"},{"location":"#lazyt","text":"LightInject can resolve a service as an instance of Lazy<T> when we want to postpone resolving the underlying service until it is needed. public interface IFoo {} public class Foo : IFoo {} container . Register < IFoo , Foo >(); var lazyFoo = container . GetInstance < Lazy < IFoo >>(); Assert . IsNotNull ( lazyFoo . Value );","title":"Lazy&lt;T&gt;"},{"location":"#function-factories","text":"Function factories allows services to resolved as a function delegate that in turn is capable of returning the underlying service instance. We can think of this as an alternative to the Service Locator (anti)pattern. public interface IFoo {} public class Foo : IFoo {} container . Register < IFoo , Foo >(); var func = container . GetInstance < Func < IFoo >>(); var foo = func (); Assert . IsNotNull ( foo ); Note: A function factory is effectively a delegate that redirects back to the corresponding GetInstance method on the service container.","title":"Function Factories"},{"location":"#named-factories","text":"The container returns a function delegate that represents calling the GetInstance method with \"SomeFoo\" as the service name argument. container . Register < IFoo , Foo >( \"SomeFoo\" ); var func = container . GetInstance < Func < IFoo >>( \"SomeFoo\" ); var foo = func (); Assert . IsNotNull ( foo );","title":"Named Factories"},{"location":"#parameters_1","text":"Function factories can also take parameters that will be used create the service instance. public class Foo : IFoo { public Foo ( int value ) { Value = value ; } public int Value { get ; private set ; } } container . Register < int , IFoo >(( factory , value ) => new Foo ( value )); var fooFactory = container . GetInstance < Func < int , IFoo >>(); var foo = ( Foo ) fooFactory ( 42 ); Assert . AreEqual ( foo . Value , 42 ); Note : The service must be explicitly registered in order for the container to resolve it as a parameterized function factory.","title":"Parameters"},{"location":"#idisposable","text":"The only way to deal with disposable objects when using function factories, is to let the service type inherit from IDisposable. public interface IFoo : IDisposable {} public class Foo : IFoo {} container . Register < IFoo , Foo >(); var fooFactory = container . GetInstance < Func < IFoo >>(); using ( IFoo foo = fooFactory ()) { } <-- Instance is disposed here Note: Although this is common practice even in the BCL , this kind of interfaces are often referred to as leaky abstractions .","title":"IDisposable"},{"location":"#typed-factories","text":"A typed factory is a class that wraps the function factory that is used to create the underlying service instance. As opposed to just function factories, typed factories provides better expressiveness to the consumer of the factory. public interface IFooFactory { IFoo GetFoo (); } public class FooFactory : IFooFactory { private Func < IFoo > createFoo ; public FooFactory ( Func < IFoo > createFoo ) { this . createFoo = createFoo ; } public IFoo GetFoo () { return createFoo (); } } container . Register < IFoo , Foo >(); container . Register < IFooFactory , FooFactory >( new PerContainerLifetime ()); var fooFactory = container . GetInstance < IFooFactory >(); var foo = fooFactory . GetFoo (); Assert . IsNotNull ( foo ); Note: Register typed factories with the PerContainerLifetime unless a compelling reason exists to choose a different lifetime.","title":"Typed Factories"},{"location":"#parameters_2","text":"Types factories can also wrap a parameterized function factory and allows us to pass arguments. public class Foo : IFoo { public Foo ( int value ) { Value = value ; } public int Value { get ; private set ; } } public interface IFooFactory { IFoo GetFoo ( int value ); } public class FooFactory : IFooFactory { private Func < int , IFoo > createFoo ; public FooFactory ( Func < int , IFoo > createFoo ) { this . createFoo = createFoo ; } public IFoo GetFoo ( int value ) { return createFoo ( value ); } } container . Register < int , IFoo >(( factory , value ) => new Foo ( value )); container . Register < IFooFactory , FooFactory >( new PerContainerLifetime ()); var typedFooFactory = container . GetInstance < IFooFactory >(); var foo = typedFooFactory . GetFoo ( 42 ); Assert . AreEqual ( foo . Value , 42 );","title":"Parameters"},{"location":"#idisposable_1","text":"Working with typed factories gives us the possibility to release disposable services registered as transients without exposing a leaky abstraction. public interface IFooFactory { IFoo GetFoo ( int value ); void Release ( IFoo foo ); } public class FooFactory : IFooFactory { private Func < IFoo > createFoo ; public FooFactory ( Func < IFoo > createFoo ) { this . createFoo = createFoo ; } public IFoo GetFoo ( int value ) { return createFoo ( value ); } public void Release ( IFoo foo ) { var disposable = foo as IDisposable ; if ( disposable != null ) { disposable . Dispose (); } } }","title":"IDisposable"},{"location":"#recursive-dependency-detection","text":"A recursive dependency graph is when a service depends directly or indirectly on itself. public class FooWithRecursiveDependency : IFoo { public FooWithRecursiveDependency ( IFoo foo ) { } } The following code will throw an InvalidOperationException stating that there are existing recursive dependencies. container . Register ( typeof ( IFoo ), typeof ( FooWithRecursiveDependency )); container . GetInstance < IFoo >()","title":"Recursive dependency detection"},{"location":"#internals","text":"When running under the .Net platform, LightInject is capable of creating instances of classes that has the internal modifier. The only requirement is that the internal class exposes a public constructor. internal class InternalFooWithPublicConstructor : IFoo { public InternalFooWithPublicConstructor () {} }","title":"Internals"},{"location":"#logging","text":"Sometimes it might be useful to obtain information about what is going on inside the container and LightInject provides a very simple log abstraction that is used to log information and warnings from within the container. var containerOptions = new ContainerOptions (); containerOptions . LogFactory = ( type ) => logEntry => Console . WriteLine ( logEntry . Message );","title":"Logging"},{"location":"#unit-testing","text":"Sometimes it might be useful to use the service container within our unit tests. LightInject also provides the LightInject.xUnit extension that enables dependencies to be injected into test methods. One side effect of using that extension is that it is tightly coupled to xUnit and it we have less control with regards to container instances. Instead consider this simple base class public class ContainerFixture : IDisposable { public ContainerFixture () { var container = CreateContainer (); Configure ( container ); container . RegisterFrom < CompositionRoot >(); ServiceFactory = container . BeginScope (); InjectPrivateFields (); } private void InjectPrivateFields () { var privateInstanceFields = this . GetType (). GetFields ( BindingFlags . Public | BindingFlags . NonPublic | BindingFlags . Instance ); foreach ( var privateInstanceField in privateInstanceFields ) { privateInstanceField . SetValue ( this , GetInstance ( ServiceFactory , privateInstanceField )); } } internal Scope ServiceFactory { get ; } public void Dispose () => ServiceFactory . Dispose (); public TService GetInstance < TService >( string name = \"\" ) => ServiceFactory . GetInstance < TService >( name ); private object GetInstance ( IServiceFactory factory , FieldInfo field ) => ServiceFactory . TryGetInstance ( field . FieldType ) ?? ServiceFactory . GetInstance ( field . FieldType , field . Name ); internal virtual IServiceContainer CreateContainer () => new ServiceContainer (); internal virtual void Configure ( IServiceRegistry serviceRegistry ) {} } This can be use with any test framework as long as it creates a new instance of the test class for each test method and that it calls Dispose after the test completes. For xUnit this is the default behaviour. Injecting services now becomes incredible easy. Just declare the service to test as a private field like this. public class SampleTests : ContainerFixture { private ICalculator calculator ; [Fact] public void ShouldAddNumbers () { calculator . Add ( 2 , 2 ). ShouldBe ( 2 ); } } If we need to configure the container before executing the test, we can do that by simply overriding the Configure method. This could for instance be used to register mock services into the container. public class SampleTests : ContainerFixture { private ICalculator calculator ; [Fact] public void ShouldAddNumbers () { calculator . Add ( 2 , 2 ). ShouldBe ( 2 ); } internal override Configure ( IServiceRegistry serviceRegistry ) { // Add registrations related to testing here } }","title":"Unit Testing"},{"location":"annotation/","text":"Annotation \u00b6 LightInject supports annotation of properties and constructor parameters through an extension LightInject. PM> Install-Package LightInject.Annotation By using the InjectAttribute we can be more explicit about the services that gets injected into properties and constructor dependencies. Note: As opposed to all other types within LightInject , the InjectAttribute is marked with the public access modifier so that is can be used outside the assembly that contains the service container. This creates a dependency from our services to the assembly containing the attribute, but we still don't need to reference any of the specific types in LightInject making this an affordable sacrifice when it comes to services referencing container specific types. Property Injection \u00b6 To enable annotated property injection, we must execute the following line before we start requesting services from the container. container.EnableAnnotatedPropertyInjection(); The container now only try to inject dependencies for properties that is annotated with the InjectAttribute . The container will throw an InvalidOperationException if the annotated property dependency is unable to be resolved. public class FooWithAnnotatedProperyDependency : IFoo { [Inject] public IBar Bar { get; set; } } Given that we have a registration for the IBar dependency, it will be injected into the Bar property. container.Register<IFoo, FooWithAnnotatedProperyDependency>(); container.Register<IBar, Bar>(); var instance = (FooWithAnnotatedProperyDependency)container.GetInstance<IFoo>(); Assert.IsNotNull(instance.Bar); If we have multiple registrations of the same interface, we can also use the InjectAttribute to specify the service to be injected. public class FooWithNamedAnnotatedProperyDependency : IFoo { [Inject(\"AnotherBar\")] public IBar Bar { get; set; } } The container will inject the service that matches the specified service name. container.Register<IFoo, FooWithNamedAnnotatedProperyDependency>(); container.Register<IBar, Bar>(\"SomeBar\"); container.Register<IBar, AnotherBar>(\"AnotherBar\"); var instance = (FooWithNamedAnnotatedProperyDependency)container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance.Bar, typeof(AnotherBar)); Constructor Injection \u00b6 To enable annotated constructor injection, we must execute the following line before we start requesting services from the container. container.EnableAnnotatedConstructorInjection(); LightInject does consider all constructor parameters to be required dependencies and will try to satisfy all dependencies regardless of being annotated with the InjectAttribute . We can however use the InjectAttribute to specify the named service to be injected. public class FooWithNamedAnnotatedDependency : IFoo { public FooWithNamedAnnotatedDependency([Inject(ServiceName=\"AnotherBar\")]IBar bar) { Bar = bar; } public IBar Bar { get; private set; } } The container will inject the service that matches the specified service name. container.Register<IFoo, FooWithNamedAnnotatedDependency>(); container.Register<IBar, Bar>(\"SomeBar\"); container.Register<IBar, AnotherBar>(\"AnotherBar\"); var instance = (FooWithNamedAnnotatedDependency)container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));","title":"Annotation"},{"location":"annotation/#annotation","text":"LightInject supports annotation of properties and constructor parameters through an extension LightInject. PM> Install-Package LightInject.Annotation By using the InjectAttribute we can be more explicit about the services that gets injected into properties and constructor dependencies. Note: As opposed to all other types within LightInject , the InjectAttribute is marked with the public access modifier so that is can be used outside the assembly that contains the service container. This creates a dependency from our services to the assembly containing the attribute, but we still don't need to reference any of the specific types in LightInject making this an affordable sacrifice when it comes to services referencing container specific types.","title":"Annotation"},{"location":"annotation/#property-injection","text":"To enable annotated property injection, we must execute the following line before we start requesting services from the container. container.EnableAnnotatedPropertyInjection(); The container now only try to inject dependencies for properties that is annotated with the InjectAttribute . The container will throw an InvalidOperationException if the annotated property dependency is unable to be resolved. public class FooWithAnnotatedProperyDependency : IFoo { [Inject] public IBar Bar { get; set; } } Given that we have a registration for the IBar dependency, it will be injected into the Bar property. container.Register<IFoo, FooWithAnnotatedProperyDependency>(); container.Register<IBar, Bar>(); var instance = (FooWithAnnotatedProperyDependency)container.GetInstance<IFoo>(); Assert.IsNotNull(instance.Bar); If we have multiple registrations of the same interface, we can also use the InjectAttribute to specify the service to be injected. public class FooWithNamedAnnotatedProperyDependency : IFoo { [Inject(\"AnotherBar\")] public IBar Bar { get; set; } } The container will inject the service that matches the specified service name. container.Register<IFoo, FooWithNamedAnnotatedProperyDependency>(); container.Register<IBar, Bar>(\"SomeBar\"); container.Register<IBar, AnotherBar>(\"AnotherBar\"); var instance = (FooWithNamedAnnotatedProperyDependency)container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));","title":"Property Injection"},{"location":"annotation/#constructor-injection","text":"To enable annotated constructor injection, we must execute the following line before we start requesting services from the container. container.EnableAnnotatedConstructorInjection(); LightInject does consider all constructor parameters to be required dependencies and will try to satisfy all dependencies regardless of being annotated with the InjectAttribute . We can however use the InjectAttribute to specify the named service to be injected. public class FooWithNamedAnnotatedDependency : IFoo { public FooWithNamedAnnotatedDependency([Inject(ServiceName=\"AnotherBar\")]IBar bar) { Bar = bar; } public IBar Bar { get; private set; } } The container will inject the service that matches the specified service name. container.Register<IFoo, FooWithNamedAnnotatedDependency>(); container.Register<IBar, Bar>(\"SomeBar\"); container.Register<IBar, AnotherBar>(\"AnotherBar\"); var instance = (FooWithNamedAnnotatedDependency)container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));","title":"Constructor Injection"},{"location":"aspnetcoreunittesting/","text":"AspNetCore Unit Testing \u00b6 Disclaimer: No Visual Studio 2017 was ever started during the writing of this post. This post is going to show how to unit test controllers in AspNetCore. We are going to do everything using nothing but the dotnet cli and VS Code. Let's start off by creating a new Web API application. dotnet new webapi That's going to set up a minimal Web API application containing a ValuesController To simplify the example we just return a single string value Next we are going to implement a service that we will inject into the ValuesController public interface IService { string GetValue (); } public class Service : IService { public string GetValue () { return \"Hello world\" ; } } Next step is to inject our service into the ValueController [Route(\"api/[controller] \")] public class ValueController : Controller { private readonly IService _service ; public ValueController ( IService service ) => _service = service ; // GET api/values [HttpGet] public string Get () { return _service . GetValue (); } } Finally we need to register our service in the Startup class. public void ConfigureServices(IServiceCollection services) { services.AddSingleton<IService,Service>(); services.AddMvc(); } We are now all set and ready for some unit testing. Unit Testing \u00b6 To test our controller we will create a test project dotnet new xunit We will test our controller using the TestServer from the Microsoft.AspNetCore.TestHost package dotnet add package Microsoft.AspNetCore.TestHost Let's create our first test public class ControllerTests { [Fact] public async Task ShouldGetValue () { using ( var testServer = CreateTestServer ()) { var client = testServer . CreateClient (); var value = await client . GetStringAsync ( \"api/value\" ); Assert . Equal ( \"Hello world\" , value ); } } private TestServer CreateTestServer () { var builder = new WebHostBuilder () . UseStartup < Startup >(); return new TestServer ( builder ); } } Configurable Server \u00b6 Let's imagine that we want to test our controller using a mock implementation of IService . We need to provide a way to override the default container registration before the server is started. The first step here is to add the ConfigureAdditionalServices method to the Startup class. public void ConfigureServices ( IServiceCollection services ) { services . AddSingleton < IService , Service >(); services . AddMvc (); ConfigureAdditionalServices ( services ); } protected virtual void ConfigureAdditionalServices ( IServiceCollection services ) { } The ConfigureAdditionalServices method gets called after all other services are registered giving us a chance to modify the configuration. We can now simply inherit from the Startup class and make it configurable. public class ConfigurableStartup : Startup { private readonly Action < IServiceCollection > configureAction ; public ConfigurableStartup ( IConfiguration configuration , Action < IServiceCollection > configureAction ) : base ( configuration ) => this . configureAction = configureAction ; protected override void ConfigureAdditionalServices ( IServiceCollection services ) { configureAction ( services ); } } While we could mock services right here in this class, we will make it more versatile by just injecting the configureAtion delegate allowing this class to be used in different scenarios. public class ConfigurableServer : TestServer { public ConfigurableServer ( Action < IServiceCollection > configureAction = null ) : base ( CreateBuilder ( configureAction )) { } private static IWebHostBuilder CreateBuilder ( Action < IServiceCollection > configureAction ) { if ( configureAction == null ) { configureAction = ( sc ) => {}; } var builder = new WebHostBuilder () . ConfigureServices ( sc => sc . AddSingleton < Action < IServiceCollection >>( configureAction )) . UseStartup < ConfigurableStartup >(); return builder ; } } Now this might need a little explanation. First we optionally pass inn the configureAction delegate and passes that delegate to the CreateBuilder method that creates the IWebHostBuilder instance that is again passed to the base constructor. The IWebHostBuilder has this ConfigureServices method that can be used to register services that is required by the startup class itself. In this case the ConfigurableStartup class takes the configureAction delegate as a constructor argument and we simply register the delegate as a singleton. Mocking \u00b6 With our new ConfigurableServer in place we can start to do some pretty interesting things with regards to mocking services inside our server. But first, let's install Moq dotnet add package moq We can now use the configureAction passed to the ConfigurableServer to replace the originally registered service. public async Task ShouldGetMockValue () { var serviceMock = new Mock < IService >(); serviceMock . Setup ( m => m . GetValue ()). Returns ( \"Hello mockworld\" ); var serviceDescriptor = new ServiceDescriptor ( typeof ( IService ), serviceMock . Object ); using ( var testServer = new ConfigurableServer ( sc => sc . Replace ( serviceDescriptor ))) { var client = testServer . CreateClient (); var value = await client . GetStringAsync ( \"api/value\" ); Assert . Equal ( \"Hello mockworld\" , value ); } } Want to comment? File an issue here :)","title":"AspNetCore unit testing"},{"location":"aspnetcoreunittesting/#aspnetcore-unit-testing","text":"Disclaimer: No Visual Studio 2017 was ever started during the writing of this post. This post is going to show how to unit test controllers in AspNetCore. We are going to do everything using nothing but the dotnet cli and VS Code. Let's start off by creating a new Web API application. dotnet new webapi That's going to set up a minimal Web API application containing a ValuesController To simplify the example we just return a single string value Next we are going to implement a service that we will inject into the ValuesController public interface IService { string GetValue (); } public class Service : IService { public string GetValue () { return \"Hello world\" ; } } Next step is to inject our service into the ValueController [Route(\"api/[controller] \")] public class ValueController : Controller { private readonly IService _service ; public ValueController ( IService service ) => _service = service ; // GET api/values [HttpGet] public string Get () { return _service . GetValue (); } } Finally we need to register our service in the Startup class. public void ConfigureServices(IServiceCollection services) { services.AddSingleton<IService,Service>(); services.AddMvc(); } We are now all set and ready for some unit testing.","title":"AspNetCore Unit Testing"},{"location":"aspnetcoreunittesting/#unit-testing","text":"To test our controller we will create a test project dotnet new xunit We will test our controller using the TestServer from the Microsoft.AspNetCore.TestHost package dotnet add package Microsoft.AspNetCore.TestHost Let's create our first test public class ControllerTests { [Fact] public async Task ShouldGetValue () { using ( var testServer = CreateTestServer ()) { var client = testServer . CreateClient (); var value = await client . GetStringAsync ( \"api/value\" ); Assert . Equal ( \"Hello world\" , value ); } } private TestServer CreateTestServer () { var builder = new WebHostBuilder () . UseStartup < Startup >(); return new TestServer ( builder ); } }","title":"Unit Testing"},{"location":"aspnetcoreunittesting/#configurable-server","text":"Let's imagine that we want to test our controller using a mock implementation of IService . We need to provide a way to override the default container registration before the server is started. The first step here is to add the ConfigureAdditionalServices method to the Startup class. public void ConfigureServices ( IServiceCollection services ) { services . AddSingleton < IService , Service >(); services . AddMvc (); ConfigureAdditionalServices ( services ); } protected virtual void ConfigureAdditionalServices ( IServiceCollection services ) { } The ConfigureAdditionalServices method gets called after all other services are registered giving us a chance to modify the configuration. We can now simply inherit from the Startup class and make it configurable. public class ConfigurableStartup : Startup { private readonly Action < IServiceCollection > configureAction ; public ConfigurableStartup ( IConfiguration configuration , Action < IServiceCollection > configureAction ) : base ( configuration ) => this . configureAction = configureAction ; protected override void ConfigureAdditionalServices ( IServiceCollection services ) { configureAction ( services ); } } While we could mock services right here in this class, we will make it more versatile by just injecting the configureAtion delegate allowing this class to be used in different scenarios. public class ConfigurableServer : TestServer { public ConfigurableServer ( Action < IServiceCollection > configureAction = null ) : base ( CreateBuilder ( configureAction )) { } private static IWebHostBuilder CreateBuilder ( Action < IServiceCollection > configureAction ) { if ( configureAction == null ) { configureAction = ( sc ) => {}; } var builder = new WebHostBuilder () . ConfigureServices ( sc => sc . AddSingleton < Action < IServiceCollection >>( configureAction )) . UseStartup < ConfigurableStartup >(); return builder ; } } Now this might need a little explanation. First we optionally pass inn the configureAction delegate and passes that delegate to the CreateBuilder method that creates the IWebHostBuilder instance that is again passed to the base constructor. The IWebHostBuilder has this ConfigureServices method that can be used to register services that is required by the startup class itself. In this case the ConfigurableStartup class takes the configureAction delegate as a constructor argument and we simply register the delegate as a singleton.","title":"Configurable Server"},{"location":"aspnetcoreunittesting/#mocking","text":"With our new ConfigurableServer in place we can start to do some pretty interesting things with regards to mocking services inside our server. But first, let's install Moq dotnet add package moq We can now use the configureAction passed to the ConfigurableServer to replace the originally registered service. public async Task ShouldGetMockValue () { var serviceMock = new Mock < IService >(); serviceMock . Setup ( m => m . GetValue ()). Returns ( \"Hello mockworld\" ); var serviceDescriptor = new ServiceDescriptor ( typeof ( IService ), serviceMock . Object ); using ( var testServer = new ConfigurableServer ( sc => sc . Replace ( serviceDescriptor ))) { var client = testServer . CreateClient (); var value = await client . GetStringAsync ( \"api/value\" ); Assert . Equal ( \"Hello mockworld\" , value ); } } Want to comment? File an issue here :)","title":"Mocking"},{"location":"autofactory/","text":"AutoFactory \u00b6 LightInject.AutoFactory enables automatic implementation of factory interfaces. Installing \u00b6 LightInject.AutoFactory provides two distribution models via NuGet Binary \u00b6 PM> Install-Package LightInject.AutoFactory This adds a reference to the LightInject.AutoFactory.dll in the target project. Source \u00b6 PM> Install-Package LightInject.AutoFactory.Source This will install a single file, LightInject.AutoFactory.cs in the target project. Factory \u00b6 The following interface represents a factory class used to resolve IFoo instances. public interface IFoo {} public class Foo : IFoo {} public interface IFooFactory { IFoo GetFoo(); } Instead of having to manually implement the IFooFactory interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented. You can enable this functionality by calling EnableAutoFactories on the container. container.Register<IFoo, Foo>(); container.EnableAutoFactories(); container.RegisterAutoFactory<IFooFactory>(); var factory = container.GetInstance<IFooFactory>(); var foo = factory.GetFoo(); Parameters \u00b6 public interface IFoo {} public class Foo : IFoo { public Foo(int value) {} } public interface IFooFactory { IFoo GetFoo(int value); } Runtime arguments can now be passed to the factory method. container.Register<int, IFoo>((factory, value) => new Foo(value)); container.EnableAutoFactories(); container.RegisterAutoFactory<IFooFactory>(); var factory = container.GetInstance<IFooFactory>(); var foo = factory.GetFoo(42); Named Services \u00b6 public interface IFoo {} public class Foo : IFoo {} public class AnotherFoo : IFoo {} public interface IFooFactory { IFoo GetFoo(); IFoo GetAnotherFoo(); } The name of the factory method is used to identify named services. container.Register<IFoo, Foo>(); container.Register<IFoo, Foo>(\"AnotherFoo\"); container.EnableAutoFactories(); container.RegisterAutoFactory<IFooFactory>(); var factory = container.GetInstance<IFooFactory>(); var foo = factory.GetFoo(); var anotherFoo = factory.GetAnotherFoo(); Open Generics \u00b6 public interface IFoo<T> {} public class Foo<T> : IFoo<T> {} public interface IFooFactory { IFoo<T> GetFoo<T>(); } The generic type arguments from the factory method are used to create the service instance. container.Register(typeof(IFoo<>), typeof(Foo<>)); container.EnableAutoFactories(); container.RegisterAutoFactory<IFooFactory>(); var factory = container.GetInstance<IFooFactory>(); var foo = factory.GetFoo<int>();","title":"AutoFactory"},{"location":"autofactory/#autofactory","text":"LightInject.AutoFactory enables automatic implementation of factory interfaces.","title":"AutoFactory"},{"location":"autofactory/#installing","text":"LightInject.AutoFactory provides two distribution models via NuGet","title":"Installing"},{"location":"autofactory/#binary","text":"PM> Install-Package LightInject.AutoFactory This adds a reference to the LightInject.AutoFactory.dll in the target project.","title":"Binary"},{"location":"autofactory/#source","text":"PM> Install-Package LightInject.AutoFactory.Source This will install a single file, LightInject.AutoFactory.cs in the target project.","title":"Source"},{"location":"autofactory/#factory","text":"The following interface represents a factory class used to resolve IFoo instances. public interface IFoo {} public class Foo : IFoo {} public interface IFooFactory { IFoo GetFoo(); } Instead of having to manually implement the IFooFactory interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented. You can enable this functionality by calling EnableAutoFactories on the container. container.Register<IFoo, Foo>(); container.EnableAutoFactories(); container.RegisterAutoFactory<IFooFactory>(); var factory = container.GetInstance<IFooFactory>(); var foo = factory.GetFoo();","title":"Factory"},{"location":"autofactory/#parameters","text":"public interface IFoo {} public class Foo : IFoo { public Foo(int value) {} } public interface IFooFactory { IFoo GetFoo(int value); } Runtime arguments can now be passed to the factory method. container.Register<int, IFoo>((factory, value) => new Foo(value)); container.EnableAutoFactories(); container.RegisterAutoFactory<IFooFactory>(); var factory = container.GetInstance<IFooFactory>(); var foo = factory.GetFoo(42);","title":"Parameters"},{"location":"autofactory/#named-services","text":"public interface IFoo {} public class Foo : IFoo {} public class AnotherFoo : IFoo {} public interface IFooFactory { IFoo GetFoo(); IFoo GetAnotherFoo(); } The name of the factory method is used to identify named services. container.Register<IFoo, Foo>(); container.Register<IFoo, Foo>(\"AnotherFoo\"); container.EnableAutoFactories(); container.RegisterAutoFactory<IFooFactory>(); var factory = container.GetInstance<IFooFactory>(); var foo = factory.GetFoo(); var anotherFoo = factory.GetAnotherFoo();","title":"Named Services"},{"location":"autofactory/#open-generics","text":"public interface IFoo<T> {} public class Foo<T> : IFoo<T> {} public interface IFooFactory { IFoo<T> GetFoo<T>(); } The generic type arguments from the factory method are used to create the service instance. container.Register(typeof(IFoo<>), typeof(Foo<>)); container.EnableAutoFactories(); container.RegisterAutoFactory<IFooFactory>(); var factory = container.GetInstance<IFooFactory>(); var foo = factory.GetFoo<int>();","title":"Open Generics"},{"location":"blog-dotnet-steps/","text":"Reflection in C# scripts \u00b6 I have been using C# scripting as a tool for writing build scripts for many years now. At first it was ScriptCs using Sublime Text as the editor. There was no intellisense or debugging capabilities, but still it was insanely powerful to have all the sweetness of C# available in a simple script file. In addition to using C# scripts in a variety of ways, I am also responsible for a handful of pull requests over at the dotnet-script repo. Together, Filip , my self and several other contributors have created a C# script runner that runs on .Net Core with support for inline NuGet packages, debugging and much more. You should check it out \ud83d\ude00 This post is not really about the evolution of C# scripting, but rather about how I went about creating dotnet-steps which is a super simple way of composing \"steps\" in a C# script. \"A small step for man kind, but a HUGE leap for build scripts\" For a build script it is pretty common to have various steps such as build , test , pack , deploy and so forth. These steps can then be composed together to form the flow of the build script and we can also execute the script in such a way that we can cherrypick the step(s) to be executed. There are plenty of tools that provides similar concepts. Cake - Full fledged build system with all batteries included. Bullseye - Clean and simple \"targets\" runner written as a console application. Nuke - Build scripts written as console application These tools all have their own sort of DSL to declare and chain composable chucks of code together. Cake \u00b6 Task ( \"Run-Unit-Tests\" ) . IsDependentOn ( \"Build\" ) . Does (() => { NUnit ( \"./src/**/bin/\" + configuration + \"/*.Tests.dll\" ); }); Bullseye \u00b6 Target ( \"default\" , DependsOn ( \"drink-tea\" , \"walk-dog\" )); Target ( \"make-tea\" , () => Console . WriteLine ( \"Tea made.\" )); Target ( \"drink-tea\" , DependsOn ( \"make-tea\" ), () => Console . WriteLine ( \"Ahh... lovely!\" )); Target ( \"walk-dog\" , () => Console . WriteLine ( \"Walkies!\" )); Nuke \u00b6 Target Compile => _ => _ . Executes (() => { }); Target Pack => _ => _ . DependsOn ( Compile ) . Executes (() => { }); Target Test => _ => _ . DependsOn ( Compile ) . Executes (() => { }); Target Full => _ => _ . DependsOn ( Pack , Test ); My personal favourite among these three is the Nuke syntax. There are no use of strings to declare targets or to reference target dependencies. It is just plain and simple C# in a type safe manner. Question is, can we do even simpler? Written as a C# script without the need for a host console application or a special runner. The syntax I was aiming for was something like Step Compile = () = WriteLine ( nameof ( Compile )); Step Pack = () => { Compile (); WriteLine ( nameof ( Pack )); } Step Test = () => { Compile (); WriteLine ( nameof ( Test )); } Step Full = () => { Pack (); Test (); } await ExecuteSteps ( Args ); As we can see there is no special DSL in this syntax. A \"Step\" is just a delegate where the body of the method becomes extremely simple. Dependencies to other steps are specified by just calling the steps we depend upon. The step itself is represented by a delegate public delegate void Step() and dotnet-steps reflects over these delegates and figures out what step(s) to execute based on the arguments passed to the script. Reflecting \"this\" \u00b6 As we can see in the dotnet-steps example there is no class that contains the steps. They are written as top level fields in the script. That is a very powerful aspect of C# scripting in general. We can just start to write code without any class containing it. The first challenge here is obtaining a list of available steps since we don't really have a class type for which we can use as a starting point for reflection. We can't use this either since C# scripting does not allow the this keyword in the top level portion of a script. So where does this top level step fields end up? They don't belong to a class ...or do they? It is a matter of fact that they actually do. It is just hidden for us. Top level members gets compiled as members of a class name sumbisson#0 which from the compilers point of view is just normal C# code. But how do we get access to this type and preferably also the instance of \"this\" represented as an instance of submission#0 ? The trick here is to use a top level lambda to provide this information to us. Action stepsDummyaction = () => StepsDummy (); void StepsDummy () { } This stepsDummyAction is also a top level field so that it belongs to submission#0 as well. It is not static so it must have a target , right? Let's try this. Action stepsDummyaction = () => StepsDummy (); void StepsDummy () {} WriteLine ( stepsDummyaction . Target . GetType ()); And the result Submission#0 Success! We now have access to Submission#0 instance through the Target property of our dummy action. And we have access to the Submission#0 type which again makes it possible to reflect over Step fields declared in the Submission#0 type. So now we can write code like private static FieldInfo [] GetStepFields < TStep >() { return _submissionType . GetFields (). Where ( f => f . FieldType == typeof ( TStep )). ToArray (); } In order to get the actual Step delegate we need to get the value from each Step field. Unless the field is declared as static, we also need the Submission#0 instance to get the field value. private static TStep GetStepDelegate < TStep >( FieldInfo stepField ) { return ( TStep )( stepField . IsStatic ? stepField . GetValue ( null ) : stepField . GetValue ( _submission )); } Note: These methods are generic so that they can work for different delegate types. We also have an AsyncStep for dealing with async steps. Executing steps \u00b6 Now that we have access to the Step delegates, the next part is executing them which is pretty trivial by itself, but we also need to track the duration of each step so that we can present a nice summary report at the end of execution. Consider the following two steps. Step step1 = () => WriteLine ( nameof ( step1 )); Step step2 = () => { step1 (); WriteLine ( nameof ( step1 )); }; If we execute step2 we will first execute step1 and then the rest of the code in step2 . And remember that we still want to have step1 appear in the summary report as a separate entry with its own duration measurement. --------------------------------------------------------------------- Steps Summary --------------------------------------------------------------------- Step Duration Total ----- ---------------- ---------------- step1 00 : 00 : 00.0009179 00 : 00 : 00.0009179 step2 00 : 00 : 00.0008100 00 : 00 : 00.0017279 --------------------------------------------------------------------- Total 00 : 00 : 00.0017279 How can we possibly intercept the call to step1 from within step2 ? Decorating Steps \u00b6 Remember that these Step delegates are just instance fields on the underlying Submission#0 instance? So what if we set these Step field values to another Step . A Step that wraps the original Step around a Stopwatch ? Step wrappedSted = () = { var stopWatch = Stopwatch . StartNew (); step (); // This is the original step declared in the script stopWatch . Stop (); } All we really need to do now is to set the field value to this wrapped Step instead. var stepFields = GetStepFields < Step >(); foreach ( var stepField in stepFields ) { var step = GetStepDelegate < Step >( stepField ); Step wrappedStep = () => { StepResult stepresult = PushStepResultOntoCallStack ( stepField ); var stopWatch = Stopwatch . StartNew (); step (); stopWatch . Stop (); PopCallStackAndUpdateDurations ( stepresult , stopWatch ); }; stepField . SetValue ( stepField . IsStatic ? null : _submission , wrappedStep ); } Okay, what is this PushStepResultOntoCallStack and PopCallStackAndUpdateDurations methods? First of all, the StepResult class is just a simple class that contains information about the executed step. public class StepResult { public StepResult ( string name , TimeSpan duration , TimeSpan totalDuration ) { Name = name ; Duration = duration ; TotalDuration = totalDuration ; } public string Name { get ; } public TimeSpan Duration { get ; set ; } public TimeSpan TotalDuration { get ; set ; } } So for each executed step, we record the Duration which is the time spent in a step excluding the time spent calling other steps. The TotalDuration is the time spent executing the step including the time spent calling other steps. For this to work we need some kind of call stack so that we can keep track of the exclusive time being spent in each step. private static StepResult PushStepResultOntoCallStack ( FieldInfo stepField ) { var stepresult = new StepResult ( stepField . Name , TimeSpan . Zero , TimeSpan . Zero ); _callStack . Push ( stepresult ); return stepresult ; } When the step has executed, we pop the current StepResult off the stack and update the duration of the calling step. private static void PopCallStackAndUpdateDurations ( StepResult stepresult , Stopwatch stopWatch ) { var durationForThisStep = stopWatch . Elapsed ; stepresult . TotalDuration = durationForThisStep ; _results . Add ( _callStack . Pop ()); if ( _callStack . Count > 0 ) { var callingStep = _callStack . Peek (); callingStep . Duration = callingStep . Duration . Subtract ( durationForThisStep ); } stepresult . Duration = stepresult . Duration . Add ( durationForThisStep ); } Summary \u00b6 The goal of this post was mainly to show how to do reflection in C# scripts and the technique I've shown here can of course be used in a number of interesting ways. Check out the documentation over at the dotnet-steps for more details. If you have any questions or ideas how to improve, don't hesitate to contact me.","title":"Reflection in C# scripts"},{"location":"blog-dotnet-steps/#reflection-in-c-scripts","text":"I have been using C# scripting as a tool for writing build scripts for many years now. At first it was ScriptCs using Sublime Text as the editor. There was no intellisense or debugging capabilities, but still it was insanely powerful to have all the sweetness of C# available in a simple script file. In addition to using C# scripts in a variety of ways, I am also responsible for a handful of pull requests over at the dotnet-script repo. Together, Filip , my self and several other contributors have created a C# script runner that runs on .Net Core with support for inline NuGet packages, debugging and much more. You should check it out \ud83d\ude00 This post is not really about the evolution of C# scripting, but rather about how I went about creating dotnet-steps which is a super simple way of composing \"steps\" in a C# script. \"A small step for man kind, but a HUGE leap for build scripts\" For a build script it is pretty common to have various steps such as build , test , pack , deploy and so forth. These steps can then be composed together to form the flow of the build script and we can also execute the script in such a way that we can cherrypick the step(s) to be executed. There are plenty of tools that provides similar concepts. Cake - Full fledged build system with all batteries included. Bullseye - Clean and simple \"targets\" runner written as a console application. Nuke - Build scripts written as console application These tools all have their own sort of DSL to declare and chain composable chucks of code together.","title":"Reflection in C# scripts"},{"location":"blog-dotnet-steps/#cake","text":"Task ( \"Run-Unit-Tests\" ) . IsDependentOn ( \"Build\" ) . Does (() => { NUnit ( \"./src/**/bin/\" + configuration + \"/*.Tests.dll\" ); });","title":"Cake"},{"location":"blog-dotnet-steps/#bullseye","text":"Target ( \"default\" , DependsOn ( \"drink-tea\" , \"walk-dog\" )); Target ( \"make-tea\" , () => Console . WriteLine ( \"Tea made.\" )); Target ( \"drink-tea\" , DependsOn ( \"make-tea\" ), () => Console . WriteLine ( \"Ahh... lovely!\" )); Target ( \"walk-dog\" , () => Console . WriteLine ( \"Walkies!\" ));","title":"Bullseye"},{"location":"blog-dotnet-steps/#nuke","text":"Target Compile => _ => _ . Executes (() => { }); Target Pack => _ => _ . DependsOn ( Compile ) . Executes (() => { }); Target Test => _ => _ . DependsOn ( Compile ) . Executes (() => { }); Target Full => _ => _ . DependsOn ( Pack , Test ); My personal favourite among these three is the Nuke syntax. There are no use of strings to declare targets or to reference target dependencies. It is just plain and simple C# in a type safe manner. Question is, can we do even simpler? Written as a C# script without the need for a host console application or a special runner. The syntax I was aiming for was something like Step Compile = () = WriteLine ( nameof ( Compile )); Step Pack = () => { Compile (); WriteLine ( nameof ( Pack )); } Step Test = () => { Compile (); WriteLine ( nameof ( Test )); } Step Full = () => { Pack (); Test (); } await ExecuteSteps ( Args ); As we can see there is no special DSL in this syntax. A \"Step\" is just a delegate where the body of the method becomes extremely simple. Dependencies to other steps are specified by just calling the steps we depend upon. The step itself is represented by a delegate public delegate void Step() and dotnet-steps reflects over these delegates and figures out what step(s) to execute based on the arguments passed to the script.","title":"Nuke"},{"location":"blog-dotnet-steps/#reflecting-this","text":"As we can see in the dotnet-steps example there is no class that contains the steps. They are written as top level fields in the script. That is a very powerful aspect of C# scripting in general. We can just start to write code without any class containing it. The first challenge here is obtaining a list of available steps since we don't really have a class type for which we can use as a starting point for reflection. We can't use this either since C# scripting does not allow the this keyword in the top level portion of a script. So where does this top level step fields end up? They don't belong to a class ...or do they? It is a matter of fact that they actually do. It is just hidden for us. Top level members gets compiled as members of a class name sumbisson#0 which from the compilers point of view is just normal C# code. But how do we get access to this type and preferably also the instance of \"this\" represented as an instance of submission#0 ? The trick here is to use a top level lambda to provide this information to us. Action stepsDummyaction = () => StepsDummy (); void StepsDummy () { } This stepsDummyAction is also a top level field so that it belongs to submission#0 as well. It is not static so it must have a target , right? Let's try this. Action stepsDummyaction = () => StepsDummy (); void StepsDummy () {} WriteLine ( stepsDummyaction . Target . GetType ()); And the result Submission#0 Success! We now have access to Submission#0 instance through the Target property of our dummy action. And we have access to the Submission#0 type which again makes it possible to reflect over Step fields declared in the Submission#0 type. So now we can write code like private static FieldInfo [] GetStepFields < TStep >() { return _submissionType . GetFields (). Where ( f => f . FieldType == typeof ( TStep )). ToArray (); } In order to get the actual Step delegate we need to get the value from each Step field. Unless the field is declared as static, we also need the Submission#0 instance to get the field value. private static TStep GetStepDelegate < TStep >( FieldInfo stepField ) { return ( TStep )( stepField . IsStatic ? stepField . GetValue ( null ) : stepField . GetValue ( _submission )); } Note: These methods are generic so that they can work for different delegate types. We also have an AsyncStep for dealing with async steps.","title":"Reflecting \"this\""},{"location":"blog-dotnet-steps/#executing-steps","text":"Now that we have access to the Step delegates, the next part is executing them which is pretty trivial by itself, but we also need to track the duration of each step so that we can present a nice summary report at the end of execution. Consider the following two steps. Step step1 = () => WriteLine ( nameof ( step1 )); Step step2 = () => { step1 (); WriteLine ( nameof ( step1 )); }; If we execute step2 we will first execute step1 and then the rest of the code in step2 . And remember that we still want to have step1 appear in the summary report as a separate entry with its own duration measurement. --------------------------------------------------------------------- Steps Summary --------------------------------------------------------------------- Step Duration Total ----- ---------------- ---------------- step1 00 : 00 : 00.0009179 00 : 00 : 00.0009179 step2 00 : 00 : 00.0008100 00 : 00 : 00.0017279 --------------------------------------------------------------------- Total 00 : 00 : 00.0017279 How can we possibly intercept the call to step1 from within step2 ?","title":"Executing steps"},{"location":"blog-dotnet-steps/#decorating-steps","text":"Remember that these Step delegates are just instance fields on the underlying Submission#0 instance? So what if we set these Step field values to another Step . A Step that wraps the original Step around a Stopwatch ? Step wrappedSted = () = { var stopWatch = Stopwatch . StartNew (); step (); // This is the original step declared in the script stopWatch . Stop (); } All we really need to do now is to set the field value to this wrapped Step instead. var stepFields = GetStepFields < Step >(); foreach ( var stepField in stepFields ) { var step = GetStepDelegate < Step >( stepField ); Step wrappedStep = () => { StepResult stepresult = PushStepResultOntoCallStack ( stepField ); var stopWatch = Stopwatch . StartNew (); step (); stopWatch . Stop (); PopCallStackAndUpdateDurations ( stepresult , stopWatch ); }; stepField . SetValue ( stepField . IsStatic ? null : _submission , wrappedStep ); } Okay, what is this PushStepResultOntoCallStack and PopCallStackAndUpdateDurations methods? First of all, the StepResult class is just a simple class that contains information about the executed step. public class StepResult { public StepResult ( string name , TimeSpan duration , TimeSpan totalDuration ) { Name = name ; Duration = duration ; TotalDuration = totalDuration ; } public string Name { get ; } public TimeSpan Duration { get ; set ; } public TimeSpan TotalDuration { get ; set ; } } So for each executed step, we record the Duration which is the time spent in a step excluding the time spent calling other steps. The TotalDuration is the time spent executing the step including the time spent calling other steps. For this to work we need some kind of call stack so that we can keep track of the exclusive time being spent in each step. private static StepResult PushStepResultOntoCallStack ( FieldInfo stepField ) { var stepresult = new StepResult ( stepField . Name , TimeSpan . Zero , TimeSpan . Zero ); _callStack . Push ( stepresult ); return stepresult ; } When the step has executed, we pop the current StepResult off the stack and update the duration of the calling step. private static void PopCallStackAndUpdateDurations ( StepResult stepresult , Stopwatch stopWatch ) { var durationForThisStep = stopWatch . Elapsed ; stepresult . TotalDuration = durationForThisStep ; _results . Add ( _callStack . Pop ()); if ( _callStack . Count > 0 ) { var callingStep = _callStack . Peek (); callingStep . Duration = callingStep . Duration . Subtract ( durationForThisStep ); } stepresult . Duration = stepresult . Duration . Add ( durationForThisStep ); }","title":"Decorating Steps"},{"location":"blog-dotnet-steps/#summary","text":"The goal of this post was mainly to show how to do reflection in C# scripts and the technique I've shown here can of course be used in a number of interesting ways. Check out the documentation over at the dotnet-steps for more details. If you have any questions or ideas how to improve, don't hesitate to contact me.","title":"Summary"},{"location":"designpatterns/","text":"Design Patterns \u00b6 LightInject has built-in support for the Decorator pattern and the Composite pattern. Decorator Pattern \u00b6 A decorator is a class that implements the same interface as the type it is decorating and takes the target instance as a constructor argument. public class FooDecorator : IFoo { public FooDecorator(IFoo foo) { } } Decorators are applied using the Decorate method. container.Register<IFoo, Foo>(); container.Decorate(typeof(IFoo), typeof(FooDecorator)); var instance = container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance, typeof(FooDecorator)); Decorators can be nested and they are applied in the same sequence as they are registered. container.Register<IFoo, Foo>(); container.Decorate(typeof(IFoo), typeof(FooDecorator)); container.Decorate(typeof(IFoo), typeof(AnotherFooDecorator)); var instance = container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance, typeof(AnotherFooDecorator)); If we have multiple services implementing the same interface, we can apply the decorator to implementations matching the given predicate. container.Register<IFoo, Foo>(); container.Register<IFoo, AnotherFoo>(\"AnotherFoo\"); container.Decorate(typeof(IFoo), typeof(FooDecorator), service => service.ServiceName == \"AnotherFoo\"); var instance = container.GetInstance<IFoo>(); var decoratedInstance = container.GetInstance<IFoo>(\"AnotherFoo\"); Assert.IsInstanceOfType(instance, typeof(Foo)); Assert.IsInstanceOfType(decoratedInstance, typeof(FooDecorator)); Decorators can have their own dependencies in addition to the target instance it is decorating. public class FooDecoratorWithDependency : IFoo { public FooDecoratorWithDependency(IFoo foo, IBar bar) { Foo = foo; Bar = bar; } public IFoo Foo { get; private set; } public IBar Bar { get; private set; } } The dependencies of the decorator can be implicitly resolved. container.Register<IFoo, Foo>(); container.Register<IBar, Bar>(); container.Decorate(typeof(IFoo), typeof(FooDecoratorWithDependency)); var instance = (FooDecoratorWithDependency)container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance.Foo, typeof(IFoo)); Assert.IsInstanceOfType(instance.Bar, typeof(IBar)); By using a function factory, we can explicitly specify the depenendecies of the decorator. container.Register<IFoo, Foo>(); container.Register<IBar, Bar>(); container.Decorate<IFoo>((serviceFactory, target) => new FooDecoratorWithDependency(target, serviceFactory.GetInstance<IBar>())); var instance = (FooDecoratorWithDependency)container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance.Foo, typeof(IFoo)); Assert.IsInstanceOfType(instance.Bar, typeof(IBar)); Note: The target instance is available through the function delegate so that we can pass it to the constructor of the decorator. Decorators can also be applied to open generic types. container.Register(typeof(IFoo<>), typeof(Foo<>)); container.Decorate(typeof(IFoo<>), typeof(FooDecorator<>)); var instance = container.GetInstance<IFoo<int>>(); Assert.IsInstanceOfType(instance, typeof(FooDecorator<int>)); Lazy Decorators \u00b6 A lazy decorator is a decorator that creates its target only when and if one of its methods are invoked. public class LazyFooDecorator : IFoo { private Lazy<IFoo> lazyFoo; public LazyFooDecorator(Lazy<IFoo> lazyFoo) { this.lazyFoo = lazyFoo; } public void Execute() { lazyFoo.Value.Execute; } } This decorator then postpones the creation of the target IFoo instance until the Execute method is invoked. Since LightInject has native support for Lazy<T> this becomes very easy to configure. container.Register(typeof(IFoo), typeof(Foo)); container.Decorate(typeof(IFoo), typeof(LazyFooDecorator)); var instance = container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance, typeof(LazyFooDecorator)); Composite Pattern \u00b6 The composite pattern is a simple pattern that lets a class implement an interface and then delegates invocation of methods to a set other classes implementing the same interface. public class FooWithEnumerableIFooDependency : IFoo { public IEnumerable<IFoo> FooList { get; private set; } public FooWithEnumerableIFooDependency(IEnumerable<IFoo> fooList) { FooList = fooList; } } While this looks like a recursive dependency, LightInject detects this and removes the FooWithEnumerableIFooDependency from the IEnumerable<IFoo> beeing injected. container.Register(typeof(IFoo), typeof(Foo), \"Foo\"); container.Register(typeof(IFoo), typeof(AnotherFoo), \"AnotherFoo\"); container.Register(typeof(IFoo), typeof(FooWithEnumerableIFooDependency)); var instance = (FooWithEnumerableIFooDependency)container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance.FooList.First(), typeof(Foo)); Assert.IsInstanceOfType(instance.FooList.Last(), typeof(AnotherFoo));","title":"Patterns"},{"location":"designpatterns/#design-patterns","text":"LightInject has built-in support for the Decorator pattern and the Composite pattern.","title":"Design Patterns"},{"location":"designpatterns/#decorator-pattern","text":"A decorator is a class that implements the same interface as the type it is decorating and takes the target instance as a constructor argument. public class FooDecorator : IFoo { public FooDecorator(IFoo foo) { } } Decorators are applied using the Decorate method. container.Register<IFoo, Foo>(); container.Decorate(typeof(IFoo), typeof(FooDecorator)); var instance = container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance, typeof(FooDecorator)); Decorators can be nested and they are applied in the same sequence as they are registered. container.Register<IFoo, Foo>(); container.Decorate(typeof(IFoo), typeof(FooDecorator)); container.Decorate(typeof(IFoo), typeof(AnotherFooDecorator)); var instance = container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance, typeof(AnotherFooDecorator)); If we have multiple services implementing the same interface, we can apply the decorator to implementations matching the given predicate. container.Register<IFoo, Foo>(); container.Register<IFoo, AnotherFoo>(\"AnotherFoo\"); container.Decorate(typeof(IFoo), typeof(FooDecorator), service => service.ServiceName == \"AnotherFoo\"); var instance = container.GetInstance<IFoo>(); var decoratedInstance = container.GetInstance<IFoo>(\"AnotherFoo\"); Assert.IsInstanceOfType(instance, typeof(Foo)); Assert.IsInstanceOfType(decoratedInstance, typeof(FooDecorator)); Decorators can have their own dependencies in addition to the target instance it is decorating. public class FooDecoratorWithDependency : IFoo { public FooDecoratorWithDependency(IFoo foo, IBar bar) { Foo = foo; Bar = bar; } public IFoo Foo { get; private set; } public IBar Bar { get; private set; } } The dependencies of the decorator can be implicitly resolved. container.Register<IFoo, Foo>(); container.Register<IBar, Bar>(); container.Decorate(typeof(IFoo), typeof(FooDecoratorWithDependency)); var instance = (FooDecoratorWithDependency)container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance.Foo, typeof(IFoo)); Assert.IsInstanceOfType(instance.Bar, typeof(IBar)); By using a function factory, we can explicitly specify the depenendecies of the decorator. container.Register<IFoo, Foo>(); container.Register<IBar, Bar>(); container.Decorate<IFoo>((serviceFactory, target) => new FooDecoratorWithDependency(target, serviceFactory.GetInstance<IBar>())); var instance = (FooDecoratorWithDependency)container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance.Foo, typeof(IFoo)); Assert.IsInstanceOfType(instance.Bar, typeof(IBar)); Note: The target instance is available through the function delegate so that we can pass it to the constructor of the decorator. Decorators can also be applied to open generic types. container.Register(typeof(IFoo<>), typeof(Foo<>)); container.Decorate(typeof(IFoo<>), typeof(FooDecorator<>)); var instance = container.GetInstance<IFoo<int>>(); Assert.IsInstanceOfType(instance, typeof(FooDecorator<int>));","title":"Decorator Pattern"},{"location":"designpatterns/#lazy-decorators","text":"A lazy decorator is a decorator that creates its target only when and if one of its methods are invoked. public class LazyFooDecorator : IFoo { private Lazy<IFoo> lazyFoo; public LazyFooDecorator(Lazy<IFoo> lazyFoo) { this.lazyFoo = lazyFoo; } public void Execute() { lazyFoo.Value.Execute; } } This decorator then postpones the creation of the target IFoo instance until the Execute method is invoked. Since LightInject has native support for Lazy<T> this becomes very easy to configure. container.Register(typeof(IFoo), typeof(Foo)); container.Decorate(typeof(IFoo), typeof(LazyFooDecorator)); var instance = container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance, typeof(LazyFooDecorator));","title":"Lazy Decorators"},{"location":"designpatterns/#composite-pattern","text":"The composite pattern is a simple pattern that lets a class implement an interface and then delegates invocation of methods to a set other classes implementing the same interface. public class FooWithEnumerableIFooDependency : IFoo { public IEnumerable<IFoo> FooList { get; private set; } public FooWithEnumerableIFooDependency(IEnumerable<IFoo> fooList) { FooList = fooList; } } While this looks like a recursive dependency, LightInject detects this and removes the FooWithEnumerableIFooDependency from the IEnumerable<IFoo> beeing injected. container.Register(typeof(IFoo), typeof(Foo), \"Foo\"); container.Register(typeof(IFoo), typeof(AnotherFoo), \"AnotherFoo\"); container.Register(typeof(IFoo), typeof(FooWithEnumerableIFooDependency)); var instance = (FooWithEnumerableIFooDependency)container.GetInstance<IFoo>(); Assert.IsInstanceOfType(instance.FooList.First(), typeof(Foo)); Assert.IsInstanceOfType(instance.FooList.Last(), typeof(AnotherFoo));","title":"Composite Pattern"},{"location":"interception/","text":"Interception \u00b6 LightInject supports Aspect Oriented Programming through proxy-based method interceptors. Installing \u00b6 LightInject.Interception provides two distribution models via NuGet Binary \u00b6 PM> Install-Package LightInject.Interception This adds a reference to the LightInject.Interception.dll in the target project. Source \u00b6 PM> Install-Package LightInject.Interception.Source This will install a single file (LightInject.Interception.cs) into the current project. Interceptors \u00b6 An interceptor sits between the call site and the target instance and intercepts method calls. public class SampleInterceptor : IInterceptor { public object Invoke(IInvocationInfo invocationInfo) { // Perform logic before invoking the target method var returnValue = invocationInfo.Proceed(); // Perform logic after invoking the target method return returnValue; } } The IInvocationInfo instance passed into the Invoke method contains information about the method being intercepted. The Proceed method calls down the chain of interceptors and ultimately the actual target instance. Asynchronous Interceptors \u00b6 When intercepting asynchronous methods we need to be able to await the target method. This can be done by inheriting from the abstract AsyncInterceptor class that does the heavy lifting with invoking the asynchronous wrapper methods. The AsyncInterceptor class is a decorator that wraps around another IInterceptor . public class SampleAsyncInterceptor : AsyncInterceptor { public SampleAsyncInterceptor ( IInterceptor targetInterceptor ) : base ( targetInterceptor ) { } protected override async Task InvokeAsync ( IInvocationInfo invocationInfo ) { InterceptedTaskMethod = true ; // Before method invocation await base . InvokeAsync ( invocationInfo ); // After method invocation } protected override async Task < T > InvokeAsync < T >( IInvocationInfo invocationInfo ) { InterceptedTaskOfTMethod = true ; // Before method invocation var value = await base . InvokeAsync < T >( invocationInfo ); // After method invocation return value ; } } Note: Do not call invocationInfo.Proceed() directly when inheriting from the AsyncInterceptor class. We can now create a new instance of the SampleAsyncInterceptor class like this: var asyncInterceptor = new SampleAsyncInterceptor ( new SampleInterceptor ()); Another option is to register our IInterceptor with the container and use the Decorate method to apply the SampleAsyncInterceptor as a decorator. container . Register < IInterceptor , SampleInterceptor >(); container . Decorate < IInterceptor , SampleAsyncInterceptor >(); container . Intercept ( sr => sr . ServiceType == typeof ( IFoo ), factory => factory . GetInstance < IInterceptor >()); Note: Only synchronous methods are passed down to the decorated IInterceptor Single Interceptor \u00b6 This example shows how to configure the service container with a single interceptor to handle all method calls. container.Register<IFoo, Foo>(); container.Intercept(sr => sr.ServiceType == typeof(IFoo), sf => new SampleInterceptor()); var instance = container.GetInstance<IFoo>(); The instance returned is a proxy object that forwards method calls to the SampleInterceptor class. The first parameter of the Intercept method is a selector function used to select the services that should have this interceptor applied. The second parameter is a function delegate that used to create an IInterceptor instance. Note: Proxy types are lazy in the sense that they will not create the target instance or any interceptors until the first method call is made. Dependencies \u00b6 Interceptors might also have dependencies and by resolving the interceptor through the container, those dependencies can be injected into the interceptor itself. public class SampleInterceptor : IInterceptor { private IBar bar; public SampleInterceptor(IBar bar) { this.bar = bar; } public object Invoke(IInvocationInfo invocationInfo) // Perform logic using the injected dependency before invoking the target method return invovationInfo.Proceed(); // Perform logic using the injected dependency after invoking the target method } } The following example shows how to configure the container so that the SampleInterceptor instance is resolved through the container. container.Register<IFoo, Foo>() container.Register<IBar, Bar>(); container.Register<IInterceptor, SampleInterceptor>(); container.Intercept(sr => sr.ServiceType == typeof(IFoo), sf => sf.GetInstance<IInterceptor>()); Note: When injecting depndencies into an interceptor we must make sure that the injected dependency is NOT intercepted by the same interceptor as this would cause a StackOverFlowException . Multiple Interceptors \u00b6 Interceptors can be set up to handle a lot of cross cutting concerns such as logging, caching, null check and so on. According to the Single Responsibility Principle , we can separate the combined logic into a set of interceptor that each only does \"one\" thing. We can do this by using another overload of the Intercept method that allows us to set up a ProxyDefinition instance that gives us more control over the proxy type that is being created. container.Intercept(sr => sr.ServiceType == typeof(IFoo), (sf,pd) => DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(new FirstInterceptor()); proxyDefinition.Implement(new SecondInterceptor()); } Note: The interceptors are invoked in the same order as they are registered with the Implement method. Method Selectors \u00b6 Method selectors are used to select the methods that should be intercepted by an interceptor. The following example shows how to set up the container so that only calls method A is passed to the interceptor. container.Intercept(sr => sr.ServiceType == typeof(IFoo), (sf, pd) => DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() => new SampleInterceptor(), m => m.Name == \"SomeMethodName\"); } Methods that does not match the method selector predicate will NOT be intercepted and method calls will be passed directly down to the target instance. If we omit the method selector, LightInject will intercept all methods from the target type and any additional interface, except methods that are inherited from System.Object . Equals(Object) GetHashCode GetType ToString If we choose to use a method selector, these methods will also be intercepted if they match the predicate in the method selector. proxyDefinition.Implement(() => new SampleInterceptor(), m => m.IsDeclaredBy<object>()); We can also use a method selector with the Intercept method that allows easy interception of any method without implementing an IInterceptor . container.Intercept(m => m.Name == \"SomeMethodName\", invocationInfo => invocationInfo.Proceed()); Extension Methods \u00b6 LightInject provides a set of extension method that simplifies method selector predicates. IsPropertySetter - Returns true if the method represents a property setter, otherwise false . IsPropertyGetter - Returns true if the method represents a property getter, otherwise false . GetProperty - Returns the property for which the target method either represents the property getter or the property setter. Chaining Interceptors \u00b6 As already seen in the example with multiple interceptors, we can chain interceptors together. We can also combine this with method selectors that will affect the call sequence from the call site down to the actual target instance. Consider an interface with three methods. public interface IFoo { void A(); void B(); void C(); } The following example shows how we can control the call sequence for each method. container.Intercept(sr => sr.ServiceType == typeof(IFoo), (sf, pd) => DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() => new FirstInterceptor(), m => m.Name == \"A\"); proxyDefinition.Implement(() => new SecondInterceptor(), m => m.Name == \"B\"); proxyDefinition.Implement(() => new ThirdInterceptor(), m => m.Name == \"A\" || m.Name == \"B\" || m.Name == \"C\"); } Method A call sequence FirstInterceptor -> ThirdInterceptor -> Target Method B call sequence SecondInterceptor -> ThirdInterceptor -> Target Method C call sequence ThirdInterceptor -> Target Implementing additional interfaces \u00b6 Another powerful feature of proxy objects is the ability to implement additional interfaces that is not implemented by the target type. The Intercept method has an overload that lets us specify a set of interfaces to be implemented by the proxy type. container.Intercept(sr => sr.ServiceType == typeof(IFoo), new []{ typeof(IBar) }, (sf, pd) => DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() => new BarInterceptor(), m => m.IsDeclaredBy<IBar>()); } When implementing additional interfaces we must make sure that all methods are intercepted by either one or a combined set of interceptors. This is because we are now dealing with methods that does not exist in the target type and we must do all implementation through interceptors. IProxy \u00b6 /// <summary> /// Implemented by all proxy types. /// </summary> public interface IProxy { /// <summary> /// Gets the proxy target. /// </summary> object Target { get; } } We can get to the underlying target instance through the IProxy interface container.Register<IFoo, Foo>(); container.Intercept(sr => sr.ServiceType == typeof(IFoo), sf => new SampleInterceptor()); var instance = container.GetInstance<IFoo>(); var actualTarget = ((IProxy)instance).Target; This \u00b6 One of the things to be aware of when working with proxy based interception is that it all relies on method calls being made through the proxy. Method calls that are made directly to the target instance will NOT be intercepted. public interface IFoo { void A(); } public class Foo : IFoo { public void A() {} private void B() { //Calls the target (this) directly and interceptors are not invoked. this.A(); } } Another scenario is when the proxy instance itself is leaking its target. public interface IFoo { IFoo A(); } public class Foo { public IFoo A() { return this; } } LightInject will take care of this scenario and detect that we are about to return this from a method and replace the return value with the proxy instance instead. Other scenarios such as event handlers or passing \"this\" to another method is NOT taken care of by LightInject as it is not possible without modifying the code in the target type itself. Class Proxies \u00b6 Starting from version 1.0.0.4, LightInject.Interception can be used to intercept classes with virtual members. public class Foo { public virtual void A() { } } Any member that is marked as virtual can be intercepted. var container = new ServiceContainer(); container.Register<Foo>(); container.Intercept(sr => sr.ServiceType == typeof(Foo), factory => new SampleInterceptor()); Class proxies are implemented internally by subclassing the target type and overriding virtual members to support interception.","title":"Interception"},{"location":"interception/#interception","text":"LightInject supports Aspect Oriented Programming through proxy-based method interceptors.","title":"Interception"},{"location":"interception/#installing","text":"LightInject.Interception provides two distribution models via NuGet","title":"Installing"},{"location":"interception/#binary","text":"PM> Install-Package LightInject.Interception This adds a reference to the LightInject.Interception.dll in the target project.","title":"Binary"},{"location":"interception/#source","text":"PM> Install-Package LightInject.Interception.Source This will install a single file (LightInject.Interception.cs) into the current project.","title":"Source"},{"location":"interception/#interceptors","text":"An interceptor sits between the call site and the target instance and intercepts method calls. public class SampleInterceptor : IInterceptor { public object Invoke(IInvocationInfo invocationInfo) { // Perform logic before invoking the target method var returnValue = invocationInfo.Proceed(); // Perform logic after invoking the target method return returnValue; } } The IInvocationInfo instance passed into the Invoke method contains information about the method being intercepted. The Proceed method calls down the chain of interceptors and ultimately the actual target instance.","title":"Interceptors"},{"location":"interception/#asynchronous-interceptors","text":"When intercepting asynchronous methods we need to be able to await the target method. This can be done by inheriting from the abstract AsyncInterceptor class that does the heavy lifting with invoking the asynchronous wrapper methods. The AsyncInterceptor class is a decorator that wraps around another IInterceptor . public class SampleAsyncInterceptor : AsyncInterceptor { public SampleAsyncInterceptor ( IInterceptor targetInterceptor ) : base ( targetInterceptor ) { } protected override async Task InvokeAsync ( IInvocationInfo invocationInfo ) { InterceptedTaskMethod = true ; // Before method invocation await base . InvokeAsync ( invocationInfo ); // After method invocation } protected override async Task < T > InvokeAsync < T >( IInvocationInfo invocationInfo ) { InterceptedTaskOfTMethod = true ; // Before method invocation var value = await base . InvokeAsync < T >( invocationInfo ); // After method invocation return value ; } } Note: Do not call invocationInfo.Proceed() directly when inheriting from the AsyncInterceptor class. We can now create a new instance of the SampleAsyncInterceptor class like this: var asyncInterceptor = new SampleAsyncInterceptor ( new SampleInterceptor ()); Another option is to register our IInterceptor with the container and use the Decorate method to apply the SampleAsyncInterceptor as a decorator. container . Register < IInterceptor , SampleInterceptor >(); container . Decorate < IInterceptor , SampleAsyncInterceptor >(); container . Intercept ( sr => sr . ServiceType == typeof ( IFoo ), factory => factory . GetInstance < IInterceptor >()); Note: Only synchronous methods are passed down to the decorated IInterceptor","title":"Asynchronous Interceptors"},{"location":"interception/#single-interceptor","text":"This example shows how to configure the service container with a single interceptor to handle all method calls. container.Register<IFoo, Foo>(); container.Intercept(sr => sr.ServiceType == typeof(IFoo), sf => new SampleInterceptor()); var instance = container.GetInstance<IFoo>(); The instance returned is a proxy object that forwards method calls to the SampleInterceptor class. The first parameter of the Intercept method is a selector function used to select the services that should have this interceptor applied. The second parameter is a function delegate that used to create an IInterceptor instance. Note: Proxy types are lazy in the sense that they will not create the target instance or any interceptors until the first method call is made.","title":"Single Interceptor"},{"location":"interception/#dependencies","text":"Interceptors might also have dependencies and by resolving the interceptor through the container, those dependencies can be injected into the interceptor itself. public class SampleInterceptor : IInterceptor { private IBar bar; public SampleInterceptor(IBar bar) { this.bar = bar; } public object Invoke(IInvocationInfo invocationInfo) // Perform logic using the injected dependency before invoking the target method return invovationInfo.Proceed(); // Perform logic using the injected dependency after invoking the target method } } The following example shows how to configure the container so that the SampleInterceptor instance is resolved through the container. container.Register<IFoo, Foo>() container.Register<IBar, Bar>(); container.Register<IInterceptor, SampleInterceptor>(); container.Intercept(sr => sr.ServiceType == typeof(IFoo), sf => sf.GetInstance<IInterceptor>()); Note: When injecting depndencies into an interceptor we must make sure that the injected dependency is NOT intercepted by the same interceptor as this would cause a StackOverFlowException .","title":"Dependencies"},{"location":"interception/#multiple-interceptors","text":"Interceptors can be set up to handle a lot of cross cutting concerns such as logging, caching, null check and so on. According to the Single Responsibility Principle , we can separate the combined logic into a set of interceptor that each only does \"one\" thing. We can do this by using another overload of the Intercept method that allows us to set up a ProxyDefinition instance that gives us more control over the proxy type that is being created. container.Intercept(sr => sr.ServiceType == typeof(IFoo), (sf,pd) => DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(new FirstInterceptor()); proxyDefinition.Implement(new SecondInterceptor()); } Note: The interceptors are invoked in the same order as they are registered with the Implement method.","title":"Multiple Interceptors"},{"location":"interception/#method-selectors","text":"Method selectors are used to select the methods that should be intercepted by an interceptor. The following example shows how to set up the container so that only calls method A is passed to the interceptor. container.Intercept(sr => sr.ServiceType == typeof(IFoo), (sf, pd) => DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() => new SampleInterceptor(), m => m.Name == \"SomeMethodName\"); } Methods that does not match the method selector predicate will NOT be intercepted and method calls will be passed directly down to the target instance. If we omit the method selector, LightInject will intercept all methods from the target type and any additional interface, except methods that are inherited from System.Object . Equals(Object) GetHashCode GetType ToString If we choose to use a method selector, these methods will also be intercepted if they match the predicate in the method selector. proxyDefinition.Implement(() => new SampleInterceptor(), m => m.IsDeclaredBy<object>()); We can also use a method selector with the Intercept method that allows easy interception of any method without implementing an IInterceptor . container.Intercept(m => m.Name == \"SomeMethodName\", invocationInfo => invocationInfo.Proceed());","title":"Method Selectors"},{"location":"interception/#extension-methods","text":"LightInject provides a set of extension method that simplifies method selector predicates. IsPropertySetter - Returns true if the method represents a property setter, otherwise false . IsPropertyGetter - Returns true if the method represents a property getter, otherwise false . GetProperty - Returns the property for which the target method either represents the property getter or the property setter.","title":"Extension Methods"},{"location":"interception/#chaining-interceptors","text":"As already seen in the example with multiple interceptors, we can chain interceptors together. We can also combine this with method selectors that will affect the call sequence from the call site down to the actual target instance. Consider an interface with three methods. public interface IFoo { void A(); void B(); void C(); } The following example shows how we can control the call sequence for each method. container.Intercept(sr => sr.ServiceType == typeof(IFoo), (sf, pd) => DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() => new FirstInterceptor(), m => m.Name == \"A\"); proxyDefinition.Implement(() => new SecondInterceptor(), m => m.Name == \"B\"); proxyDefinition.Implement(() => new ThirdInterceptor(), m => m.Name == \"A\" || m.Name == \"B\" || m.Name == \"C\"); } Method A call sequence FirstInterceptor -> ThirdInterceptor -> Target Method B call sequence SecondInterceptor -> ThirdInterceptor -> Target Method C call sequence ThirdInterceptor -> Target","title":"Chaining Interceptors"},{"location":"interception/#implementing-additional-interfaces","text":"Another powerful feature of proxy objects is the ability to implement additional interfaces that is not implemented by the target type. The Intercept method has an overload that lets us specify a set of interfaces to be implemented by the proxy type. container.Intercept(sr => sr.ServiceType == typeof(IFoo), new []{ typeof(IBar) }, (sf, pd) => DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() => new BarInterceptor(), m => m.IsDeclaredBy<IBar>()); } When implementing additional interfaces we must make sure that all methods are intercepted by either one or a combined set of interceptors. This is because we are now dealing with methods that does not exist in the target type and we must do all implementation through interceptors.","title":"Implementing additional interfaces"},{"location":"interception/#iproxy","text":"/// <summary> /// Implemented by all proxy types. /// </summary> public interface IProxy { /// <summary> /// Gets the proxy target. /// </summary> object Target { get; } } We can get to the underlying target instance through the IProxy interface container.Register<IFoo, Foo>(); container.Intercept(sr => sr.ServiceType == typeof(IFoo), sf => new SampleInterceptor()); var instance = container.GetInstance<IFoo>(); var actualTarget = ((IProxy)instance).Target;","title":"IProxy"},{"location":"interception/#this","text":"One of the things to be aware of when working with proxy based interception is that it all relies on method calls being made through the proxy. Method calls that are made directly to the target instance will NOT be intercepted. public interface IFoo { void A(); } public class Foo : IFoo { public void A() {} private void B() { //Calls the target (this) directly and interceptors are not invoked. this.A(); } } Another scenario is when the proxy instance itself is leaking its target. public interface IFoo { IFoo A(); } public class Foo { public IFoo A() { return this; } } LightInject will take care of this scenario and detect that we are about to return this from a method and replace the return value with the proxy instance instead. Other scenarios such as event handlers or passing \"this\" to another method is NOT taken care of by LightInject as it is not possible without modifying the code in the target type itself.","title":"This"},{"location":"interception/#class-proxies","text":"Starting from version 1.0.0.4, LightInject.Interception can be used to intercept classes with virtual members. public class Foo { public virtual void A() { } } Any member that is marked as virtual can be intercepted. var container = new ServiceContainer(); container.Register<Foo>(); container.Intercept(sr => sr.ServiceType == typeof(Foo), factory => new SampleInterceptor()); Class proxies are implemented internally by subclassing the target type and overriding virtual members to support interception.","title":"Class Proxies"},{"location":"licence/","text":"The MIT License (MIT) \u00b6 Copyright (c) 2014 bernhard.richter@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Licence"},{"location":"licence/#the-mit-license-mit","text":"Copyright (c) 2014 bernhard.richter@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"lightmock/","text":"LightMock \u00b6 LightMock is a simple mocking library that can be used on platforms that does not allow dynamic code generation. Installing \u00b6 PM> Install-Package LightMock This adds a reference to the LightMock in the target project. The LightMock library is a a portable class library that makes it possible to use this across all platforms including iOS and Android. Creating a mock object \u00b6 Even though the mock objects are created manually, they can be reused in many scenarios. As an an example we will use this simple interface. public interface IFoo { void Execute(string value); string Execute(); } The mock object implementing this interface looks like this public class FooMock : IFoo { private readonly IInvocationContext<IFoo> context; public FooMock(IInvocationContext<IFoo> context) { this.context = context; } public void Execute(string value) { context.Invoke(f => f.Execute(value)); } public string Execute() { return context.Invoke(f => f.Execute()); } } Note: Only mocked methods needs to be implemented. Other methods that does not get invoked during testing can just throw a NotImplementedException. Assertions \u00b6 The Assert method is used to verify that the given method has been executed the expected number of times using the expected arguments. //Arrange var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); //Act fooMock.Execute(\"SomeValue\"); //Assert mockContext.Assert(f => f.Execute(\"SomeValue\")); Note: Not specifying the expected number of invocations, means at least once. If we don't care about the actual argument value, we can use a special class called The . var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); fooMock.Execute(\"SomeValue\"); mockContext.Assert(f => f.Execute(The<string>.IsAnyValue), Invoked.Once); We call also use this class to perform custom verification. var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); fooMock.Execute(\"SomeValue\"); mockContext.Assert(f => f.Execute(The<string>.Is(s => s.StartsWith(\"Some\"))), Invoked.Once); Arrangements \u00b6 We can use arrangements to add behavior to the mock object. For instance we can set up the mock object to return a value. var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); mockContext.Arrange(f => f.Execute()).Returns(\"SomeValue\"); var result = fooMock.Execute(); Assert.AreEqual(\"SomeValue\", result); Throw an exception var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); mockContext.Arrange(f => f.Execute(\"SomeValue\")).Throws<InvalidOperationException>(); fooMock.Execute(\"SomeValue\"); Throw an exception using a exception factory. var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); mockContext.Arrange(f => f.Execute(\"SomeValue\")).Throws(() => new InvalidOperationException()); fooMock.Execute(\"SomeValue\"); Execute a callback var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); string callBackResult = null; mockContext.Arrange(f => f.Execute(The<string>.IsAnyValue)) .Callback<string>(s => callBackResult = s); fooMock.Execute(\"SomeValue\"); Assert.AreEqual(\"SomeValue\", callBackResult);","title":"LightMock"},{"location":"lightmock/#lightmock","text":"LightMock is a simple mocking library that can be used on platforms that does not allow dynamic code generation.","title":"LightMock"},{"location":"lightmock/#installing","text":"PM> Install-Package LightMock This adds a reference to the LightMock in the target project. The LightMock library is a a portable class library that makes it possible to use this across all platforms including iOS and Android.","title":"Installing"},{"location":"lightmock/#creating-a-mock-object","text":"Even though the mock objects are created manually, they can be reused in many scenarios. As an an example we will use this simple interface. public interface IFoo { void Execute(string value); string Execute(); } The mock object implementing this interface looks like this public class FooMock : IFoo { private readonly IInvocationContext<IFoo> context; public FooMock(IInvocationContext<IFoo> context) { this.context = context; } public void Execute(string value) { context.Invoke(f => f.Execute(value)); } public string Execute() { return context.Invoke(f => f.Execute()); } } Note: Only mocked methods needs to be implemented. Other methods that does not get invoked during testing can just throw a NotImplementedException.","title":"Creating a mock object"},{"location":"lightmock/#assertions","text":"The Assert method is used to verify that the given method has been executed the expected number of times using the expected arguments. //Arrange var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); //Act fooMock.Execute(\"SomeValue\"); //Assert mockContext.Assert(f => f.Execute(\"SomeValue\")); Note: Not specifying the expected number of invocations, means at least once. If we don't care about the actual argument value, we can use a special class called The . var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); fooMock.Execute(\"SomeValue\"); mockContext.Assert(f => f.Execute(The<string>.IsAnyValue), Invoked.Once); We call also use this class to perform custom verification. var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); fooMock.Execute(\"SomeValue\"); mockContext.Assert(f => f.Execute(The<string>.Is(s => s.StartsWith(\"Some\"))), Invoked.Once);","title":"Assertions"},{"location":"lightmock/#arrangements","text":"We can use arrangements to add behavior to the mock object. For instance we can set up the mock object to return a value. var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); mockContext.Arrange(f => f.Execute()).Returns(\"SomeValue\"); var result = fooMock.Execute(); Assert.AreEqual(\"SomeValue\", result); Throw an exception var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); mockContext.Arrange(f => f.Execute(\"SomeValue\")).Throws<InvalidOperationException>(); fooMock.Execute(\"SomeValue\"); Throw an exception using a exception factory. var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); mockContext.Arrange(f => f.Execute(\"SomeValue\")).Throws(() => new InvalidOperationException()); fooMock.Execute(\"SomeValue\"); Execute a callback var mockContext = new MockContext<IFoo>(); var fooMock = new FooMock(mockContext); string callBackResult = null; mockContext.Arrange(f => f.Execute(The<string>.IsAnyValue)) .Callback<string>(s => callBackResult = s); fooMock.Execute(\"SomeValue\"); Assert.AreEqual(\"SomeValue\", callBackResult);","title":"Arrangements"},{"location":"microsoft.aspnetcore.hosting/","text":"LightInject.Microsoft.AspNetCore.Hosting \u00b6 Enables LightInject to be used as the service container in AspNetCore applications Note: This package is meant to be used for Asp.Net Core 2.2 applications. For Asp.Net Core > 3.0, the LightInject.Microsoft.Hosting package should be used. Installing \u00b6 <PackageReference Include= \"LightInject.Microsoft.AspNetCore.Hosting\" Version= \"<version>\" /> Usage \u00b6 Enabling LightInject is as simple as calling the UseLightInject method that extends the IWebHostBuilder . The following sample shows how to do this in a simple web application. public class Program { public static void Main ( string [] args ) { CreateWebHostBuilder ( args ). Build (). Run (); } public static IWebHostBuilder CreateWebHostBuilder ( string [] args ) => WebHost . CreateDefaultBuilder ( args ) . UseLightInject () . UseStartup < Startup >(); } Typically in LightInject , we register services in a composition root public class CompositionRoot : ICompositionRoot { public void Compose ( IServiceRegistry serviceRegistry ) { serviceRegistry . Register < IFoo , Foo >(); } } public interface IFoo {} public class Foo : IFoo {} By declaring a method named ConfigureContainer we can get access to the IServiceContainer that we in this example use to register our composition root. public class Startup { public Startup ( IConfiguration configuration ) { Configuration = configuration ; } public IConfiguration Configuration { get ; } // Use this method to add services to the container. public void ConfigureServices ( IServiceCollection services ) { } // Use this method to add services directly to LightInject // Important: This method must exist in order to replace the default provider. public void ConfigureContainer ( IServiceContainer container ) { container . RegisterFrom < CompositionRoot >(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure ( IApplicationBuilder app , IHostingEnvironment env ) { } } Note: Services registered in the ConfigureServices method will also be registered with LightInject Controllers \u00b6 By default, controllers are not actually created by LightInject . They are created by the ASP.NET infrastructure and uses LightInject to resolve its dependencies. To enable LightInject to create the controller instances, we need to add the following line. services . AddMvc (). AddControllersAsServices (); Test Services \u00b6 We can register test/mock services to be used when testing our controllers. public void ShouldResolveMockedService () { var builder = new WebHostBuilder () . UseLightInject () . ConfigureTestContainer < IServiceContainer >( c => c . RegisterTransient < IFoo , FooMock >()) . UseStartup < TestStartup >(); using ( var webHost = builder . Build ()) { var foo = webHost . Services . GetRequiredService < IFoo >(); Assert . IsType < FooMock >( foo ); } } public class FooMock : IFoo { }","title":"AspNetCore"},{"location":"microsoft.aspnetcore.hosting/#lightinjectmicrosoftaspnetcorehosting","text":"Enables LightInject to be used as the service container in AspNetCore applications Note: This package is meant to be used for Asp.Net Core 2.2 applications. For Asp.Net Core > 3.0, the LightInject.Microsoft.Hosting package should be used.","title":"LightInject.Microsoft.AspNetCore.Hosting"},{"location":"microsoft.aspnetcore.hosting/#installing","text":"<PackageReference Include= \"LightInject.Microsoft.AspNetCore.Hosting\" Version= \"<version>\" />","title":"Installing"},{"location":"microsoft.aspnetcore.hosting/#usage","text":"Enabling LightInject is as simple as calling the UseLightInject method that extends the IWebHostBuilder . The following sample shows how to do this in a simple web application. public class Program { public static void Main ( string [] args ) { CreateWebHostBuilder ( args ). Build (). Run (); } public static IWebHostBuilder CreateWebHostBuilder ( string [] args ) => WebHost . CreateDefaultBuilder ( args ) . UseLightInject () . UseStartup < Startup >(); } Typically in LightInject , we register services in a composition root public class CompositionRoot : ICompositionRoot { public void Compose ( IServiceRegistry serviceRegistry ) { serviceRegistry . Register < IFoo , Foo >(); } } public interface IFoo {} public class Foo : IFoo {} By declaring a method named ConfigureContainer we can get access to the IServiceContainer that we in this example use to register our composition root. public class Startup { public Startup ( IConfiguration configuration ) { Configuration = configuration ; } public IConfiguration Configuration { get ; } // Use this method to add services to the container. public void ConfigureServices ( IServiceCollection services ) { } // Use this method to add services directly to LightInject // Important: This method must exist in order to replace the default provider. public void ConfigureContainer ( IServiceContainer container ) { container . RegisterFrom < CompositionRoot >(); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure ( IApplicationBuilder app , IHostingEnvironment env ) { } } Note: Services registered in the ConfigureServices method will also be registered with LightInject","title":"Usage"},{"location":"microsoft.aspnetcore.hosting/#controllers","text":"By default, controllers are not actually created by LightInject . They are created by the ASP.NET infrastructure and uses LightInject to resolve its dependencies. To enable LightInject to create the controller instances, we need to add the following line. services . AddMvc (). AddControllersAsServices ();","title":"Controllers"},{"location":"microsoft.aspnetcore.hosting/#test-services","text":"We can register test/mock services to be used when testing our controllers. public void ShouldResolveMockedService () { var builder = new WebHostBuilder () . UseLightInject () . ConfigureTestContainer < IServiceContainer >( c => c . RegisterTransient < IFoo , FooMock >()) . UseStartup < TestStartup >(); using ( var webHost = builder . Build ()) { var foo = webHost . Services . GetRequiredService < IFoo >(); Assert . IsType < FooMock >( foo ); } } public class FooMock : IFoo { }","title":"Test Services"},{"location":"microsoft.dependencyinjection/","text":"LightInject.Microsoft.DependencyInjection \u00b6 Implements the Microsoft.Extensions.DependencyInjection.Abstractions and makes it possible to create an IServiceProvider that is 100% compatible with the Microsoft.Extensions.DependencyInjection.Specification.Tests . Note: This package is NOT meant to be used directly with AspNetCore applications. If the target application is an AspNetCore application, use the LightInject.Microsoft.Hosting package instead. Installing \u00b6 dotnet add package LightInject.Microsoft.DependencyInjection Usage \u00b6 var services = new ServiceCollection (); services . AddTransient < Foo >(); var provider = services . CreateLightInjectServiceProvider (); It is also possible to create an IServiceProvider directly from an IServiceContainer instance. var container = new ServiceContainer ( Options . Default . WithMicrosoftSettings ); var provider = container . CreateServiceProvider (); Note: Make sure that the Options.Default.WithMicrosoftSettings is passed in as options when creating the container. This makes the provider compliant with the default provider from Microsoft.","title":"Microsoft DI"},{"location":"microsoft.dependencyinjection/#lightinjectmicrosoftdependencyinjection","text":"Implements the Microsoft.Extensions.DependencyInjection.Abstractions and makes it possible to create an IServiceProvider that is 100% compatible with the Microsoft.Extensions.DependencyInjection.Specification.Tests . Note: This package is NOT meant to be used directly with AspNetCore applications. If the target application is an AspNetCore application, use the LightInject.Microsoft.Hosting package instead.","title":"LightInject.Microsoft.DependencyInjection"},{"location":"microsoft.dependencyinjection/#installing","text":"dotnet add package LightInject.Microsoft.DependencyInjection","title":"Installing"},{"location":"microsoft.dependencyinjection/#usage","text":"var services = new ServiceCollection (); services . AddTransient < Foo >(); var provider = services . CreateLightInjectServiceProvider (); It is also possible to create an IServiceProvider directly from an IServiceContainer instance. var container = new ServiceContainer ( Options . Default . WithMicrosoftSettings ); var provider = container . CreateServiceProvider (); Note: Make sure that the Options.Default.WithMicrosoftSettings is passed in as options when creating the container. This makes the provider compliant with the default provider from Microsoft.","title":"Usage"},{"location":"mvc/","text":"MVC \u00b6 LightInject.Mvc provides an integration that enables dependency injection in ASP.NET MVC applications. Installing \u00b6 LightInject.Mvc provides two distribution models via NuGet Binary \u00b6 PM> Install-Package LightInject.Mvc This adds a reference to the LightInject.Mvc.dll in the target project. Source \u00b6 PM> Install-Package LightInject.Mvc.Source This will install a single file (LightInject.Mvc.cs) into the current project. Initializing \u00b6 protected void Application_Start() { var container = new ServiceContainer(); container.RegisterControllers(); //register other services container.EnableMvc() } Services \u00b6 All services that implements IDisposable, must be registered with the PerScopeLifetime to ensure that they are properly disposed when the web request ends. container.Register<IFoo, Foo>(new PerScopeLifetime()); Controllers are also disposable services and LightInject provides the RegisterControllers method that registers all controllers from a given assembly with the PerRequestLifetime . container.RegisterControllers(typeof(MyMvcApplication).Assembly); FilterAttribute \u00b6 Although filter attributes are instantiated by the MFC infrastructure, LightInject is still able to inject dependencies into properties. public class FooFilterAttribute : ActionFilterAttribute { public IFoo Foo { get; set; } }","title":"Mvc"},{"location":"mvc/#mvc","text":"LightInject.Mvc provides an integration that enables dependency injection in ASP.NET MVC applications.","title":"MVC"},{"location":"mvc/#installing","text":"LightInject.Mvc provides two distribution models via NuGet","title":"Installing"},{"location":"mvc/#binary","text":"PM> Install-Package LightInject.Mvc This adds a reference to the LightInject.Mvc.dll in the target project.","title":"Binary"},{"location":"mvc/#source","text":"PM> Install-Package LightInject.Mvc.Source This will install a single file (LightInject.Mvc.cs) into the current project.","title":"Source"},{"location":"mvc/#initializing","text":"protected void Application_Start() { var container = new ServiceContainer(); container.RegisterControllers(); //register other services container.EnableMvc() }","title":"Initializing"},{"location":"mvc/#services","text":"All services that implements IDisposable, must be registered with the PerScopeLifetime to ensure that they are properly disposed when the web request ends. container.Register<IFoo, Foo>(new PerScopeLifetime()); Controllers are also disposable services and LightInject provides the RegisterControllers method that registers all controllers from a given assembly with the PerRequestLifetime . container.RegisterControllers(typeof(MyMvcApplication).Assembly);","title":"Services"},{"location":"mvc/#filterattribute","text":"Although filter attributes are instantiated by the MFC infrastructure, LightInject is still able to inject dependencies into properties. public class FooFilterAttribute : ActionFilterAttribute { public IFoo Foo { get; set; } }","title":"FilterAttribute"},{"location":"nancy/","text":"Nancy \u00b6 LightInject.Nancy provides an integration that enables LightInject to be used as the IoC container in the Nancy web framework. Installing \u00b6 PM> Install-Package LightInject.Nancy This adds a reference to the LightInject.Nancy.dll in the target project. Dependencies \u00b6 public interface IFoo {} public class Foo : IFoo {} public class SampleModule : NancyModule { public SampleModule(IFoo foo) { Get[\"/\"] = parameters => \"Hello World\"; } } Configuring additional services/dependencies is done by implementing the ICompositionRoot interface. public class CompositionRoot : ICompositionRoot { void ICompositionRoot.Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register<IFoo, Foo>(); } } Note: LightInject will look for an ICompositionRoot implementation in the same assembly as the requested service. Custom Bootstrapper \u00b6 If we need to use an existing container instance or perform some other configuration, this can be done by inheriting from the LightInjectNancyBootstrapper class. public class Bootstrapper : LightInjectNancyBootstrapper { protected override IServiceContainer GetServiceContainer() { // Alteratively provide an existing container instance. return base.GetServiceContainer(); } } Lifetime \u00b6 Services registered with the PerScopeLifetime are scoped per web request while services registered with the PerContainerLifetime are as scoped per application. NancyContext \u00b6 By injecting a Func<NancyContext> delegate we can get access to the NancyContext even outside of Nancy modules. public class Foo { private readonly Func<NancyContext> getNancyContext; public Foo(Func<NancyContext> getNancyContext) { this.getNancyContext = getNancyContext; } public void DoSomething() { var nancyContext = getNancyContext(); } }","title":"Nancy"},{"location":"nancy/#nancy","text":"LightInject.Nancy provides an integration that enables LightInject to be used as the IoC container in the Nancy web framework.","title":"Nancy"},{"location":"nancy/#installing","text":"PM> Install-Package LightInject.Nancy This adds a reference to the LightInject.Nancy.dll in the target project.","title":"Installing"},{"location":"nancy/#dependencies","text":"public interface IFoo {} public class Foo : IFoo {} public class SampleModule : NancyModule { public SampleModule(IFoo foo) { Get[\"/\"] = parameters => \"Hello World\"; } } Configuring additional services/dependencies is done by implementing the ICompositionRoot interface. public class CompositionRoot : ICompositionRoot { void ICompositionRoot.Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register<IFoo, Foo>(); } } Note: LightInject will look for an ICompositionRoot implementation in the same assembly as the requested service.","title":"Dependencies"},{"location":"nancy/#custom-bootstrapper","text":"If we need to use an existing container instance or perform some other configuration, this can be done by inheriting from the LightInjectNancyBootstrapper class. public class Bootstrapper : LightInjectNancyBootstrapper { protected override IServiceContainer GetServiceContainer() { // Alteratively provide an existing container instance. return base.GetServiceContainer(); } }","title":"Custom Bootstrapper"},{"location":"nancy/#lifetime","text":"Services registered with the PerScopeLifetime are scoped per web request while services registered with the PerContainerLifetime are as scoped per application.","title":"Lifetime"},{"location":"nancy/#nancycontext","text":"By injecting a Func<NancyContext> delegate we can get access to the NancyContext even outside of Nancy modules. public class Foo { private readonly Func<NancyContext> getNancyContext; public Foo(Func<NancyContext> getNancyContext) { this.getNancyContext = getNancyContext; } public void DoSomething() { var nancyContext = getNancyContext(); } }","title":"NancyContext"},{"location":"signalr/","text":"SignalR \u00b6 LightInject.Signal provides an integration that enables dependency injection in SignalR hub implementations. Installing \u00b6 LightInject.SignalR provides two distribution models via NuGet Binary \u00b6 PM> Install-Package LightInject.SignalR This adds a reference to the LightInject.SignalR.dll in the target project. Source \u00b6 PM> Install-Package LightInject.SignalR.Source This will install a single file ( LightInject.SignalR.cs ) into the current project. Initializing \u00b6 The following example shows how to enable support for SignalR in an OWIN startup class. public class Startup { public void Configuration(IAppBuilder app) { var serviceContainer = new ServiceContainer(); serviceContainer.RegisterHubs(); ..register other services app.MapSignalR(serviceContainer.EnableSignalR()); } } Services \u00b6 Services that implements IDisposable must be registered with the with the PerScopeLifetime or the PerRequestLifetime to ensure that they are properly disposed when the Hub is disposed.","title":"SignalR"},{"location":"signalr/#signalr","text":"LightInject.Signal provides an integration that enables dependency injection in SignalR hub implementations.","title":"SignalR"},{"location":"signalr/#installing","text":"LightInject.SignalR provides two distribution models via NuGet","title":"Installing"},{"location":"signalr/#binary","text":"PM> Install-Package LightInject.SignalR This adds a reference to the LightInject.SignalR.dll in the target project.","title":"Binary"},{"location":"signalr/#source","text":"PM> Install-Package LightInject.SignalR.Source This will install a single file ( LightInject.SignalR.cs ) into the current project.","title":"Source"},{"location":"signalr/#initializing","text":"The following example shows how to enable support for SignalR in an OWIN startup class. public class Startup { public void Configuration(IAppBuilder app) { var serviceContainer = new ServiceContainer(); serviceContainer.RegisterHubs(); ..register other services app.MapSignalR(serviceContainer.EnableSignalR()); } }","title":"Initializing"},{"location":"signalr/#services","text":"Services that implements IDisposable must be registered with the with the PerScopeLifetime or the PerRequestLifetime to ensure that they are properly disposed when the Hub is disposed.","title":"Services"},{"location":"transactions/","text":"Transaction Management \u00b6 In this example we will be looking into how to deal with connections and transactions in a Web application. We will also discuss how to implement automatic rollback for integration tests. Our testing framework will be xUnit and together with LightInject this will hopefully turn into a very smooth testing experience. Commands and Queries \u00b6 There are many ways to manage the interaction with the database and in this application we are going to implement something that has come to be known as the Command-Query pattern. The basic idea here is that we have one interface ( IQueryHandler ) for everything that comes out of the database and another interface ( ICommandHandler )for everything that goes into the database. The fact that we are dealing with the same set of interfaces for all interaction with the database means that we can very easily add features through the use of decorators. I am not going to cover everything with regards to command and queries here, but we will look into the interfaces we need to implement in order to shuffle data back and forth to the database. Queries \u00b6 The following interface represents a class that can handle a query and return some kind of result. public interface IQueryHandler<in TQuery, TResult> where TQuery : IQuery<TResult> { Task<TResult> HandleAsync(TQuery query); } You might wonder about the IQuery<TResult> generic contraint. This is just an interface to give type inference a helping hand as we move on to the next interface. The IQueryExecutor represents a class that can execute any query. public interface IQueryExecutor { Task<TResult> ExecuteAsync<TResult>(IQuery<TResult> query); } This is where the IQuery<TResult> generic contraint comes into play. Without the contraint we would have to specify the type of result when calling the ExecuteAsync method. var result = queryExecutor.ExecuteAsync<SomeResultType>(somequery); With the query class \"implementing\" the IQuery<TResult> interface we can instead do this var result = queryExecutor.ExecuteAsync(somequery); Commands \u00b6 The following interface represents a class that can handle a command where the command can be any class. public interface ICommandHandler<in TCommand> { Task HandleAsync(TCommand command); } Will be seeing examples of both queries and commands throughout this example. Why not an ORM? \u00b6 The best answer I can give you is that I have already been there and felt the pain that eventually comes sneaking upon you. A little at first and then more and more as things gets more complicated. In fact, I have actually written an inhouse ORM back in the days and writing a Linq provider for instance, certainly represents the Mount Everest of programming. Not because Linq is so hard, but because you have to deal with all the mismatches between the relational model and the object model. ORM's tries to free you from understanding SQL and it is such a failed abstraction. Eventually at some point, you find yourself in a situation where you are trying to come up with a Linq expression that generates the SQL you've already written. Bottom line, bite the bullet and learn SQL. Customers \u00b6 The first task is to create a query handler that can retrieve customers from the database based on their origin (country). The SQL for ths look like this: SELECT CustomerId , CompanyName FROM Customers WHERE Country = @ Country ; With the SQL in place, we are ready to implement the query handler. public class CustomersQueryHandler : IQueryHandler<CustomersQuery, Customer[]> { private readonly IDbConnection dbConnection; public CustomersQueryHandler(IDbConnection dbConnection) { this.dbConnection = dbConnection; } public async Task<Customer[]> HandleAsync(CustomersQuery query) { var result = await dbConnection.QueryAsync<CustomerRow>(SQL.CustomersByCountry, query); return result.ToArray(); } } Note: Query and command handlers does not dictate that the data is stored in a relational database. It might just as well be stored in a file or another type of database such as a document database. This query handler has just one dependency, the IDbConnection off which Dapper provides the QueryAsync method used to execute the query. The query ( CustomersQuery ) looks like this public class CustomersQuery : IQuery<Customer[]> { public string Country { get; set; } } Passing data through layers \u00b6 Okay, so we have our application that consists of different layers. Data Access Layer (query and command handlers) Business Layer (services using the data access layer) Public API (typically a REST based API using services from the business layer) Data Access Layer \u00b6 This is where we actually interact with the underlying data store which for most applications even today means a relational database. These databases store relational data and is not very well suited for storing objects and we should treat the database accordingly. Relational databases does not store objects, they store rows of data. This is why we represent the result from Dapper as a set of CustomerRow instances. Business Layer \u00b6 This layer consists of the services that in turn will be using the data access layer. This is also the place to put any kind of business logic related to our services. By mocking the data access layer we can test this functionality without hitting the database. API Layer \u00b6 This is our public API which in this sample application is exposed as a RESTful API using Web Api. Try to keep this layer as thin as possible. It should not deal with any kind of business logic, but it should for instance deal with making sure that we return the correct status codes according to REST best practices. So should each layer have its own representation of the same data? My answer is this: Be pragmatic about this. If the representation looks identical throughout the various layers, you might as well reuse the same class for different layers. Once you need to add JsonIgnore attributes to ensure that database-only properties does not get exposed in the Web API, you might consider another representation. It is also likely that the representations for reading and writing will differ so there is a lot to consider her. There is also a performance penalty involved here since we need to constantly map the \"same\" data between layers. There might also be situations where the service layer just acts as a pass-t through layer and it that case it might be just fine to use the query/command handlers directly in our controllers. Composition Root \u00b6 The composition root is where we register services into the container. serviceRegistry.Register<IQueryExecutor, QueryExecutor>(new PerContainerLifetime()); serviceRegistry.RegisterQueryHandlers(); // We register the connection that it is disposed when the scope ends. // The scope here is per web request. serviceRegistry.Register(factory => CreateConnection(), new PerScopeLifetime()); We register the IDbConnection with the PerScopeLifetime which means that we get the same connection within a scope. The scope is usually per web request, but it can also be per test method as we will see in a minute. This is actually a nice aspect of the scoping mechanism in LightInject. We tell a service to be per scope without providing any details about how the scope is started or ended. Testing query handlers \u00b6 Before we dive into how to handle transactions, we are going to look at how to test our new query handler. LightInject provides an extension( LightInject.xUnit ) that makes it possible to inject services into test methods. [Theory, Scoped, InjectData] public async Task ShouldGetCustomersFromGermany(IQueryExecutor queryExecutor) { var query = new CustomersQuery {Country = \"Germany\"}; var result = await queryExecutor.ExecuteAsync(query); Assert.Equal(11, result.Length); } The Scoped attribute tells LightInject to wrap a scope around this test method. When the test method ends, the scope will end as well and that will in turn cause the IDbConnection to be disposed since that service is registered with the PerScopeLifetime . The InjectData attribute simply tells LightInject to inject method arguments and can be thought off as a more sophisticated version of the InlineData attribute usually seen in xUnit theory based tests. LightInject.xUnit creates a container instance behind the scenes and uses that instance to inject services into the test methods. The default behavior in LightInject is to look for composition roots in the same assembly as the requested service. This is part of the fallback mechanism and means that we don't really need to explicitly configure the container in the test class although it is possible to do so by declaring the following static method. public static void Configure(IServiceContainer container) { container.RegisterFrom<CompositionRoot>(); } We can also use the InjectData attribute so specify inline data in addition to the service being injected. [Theory, Scoped] [InjectData(\"France\", 11)] [InjectData(\"Germany\", 11)] [InjectData(\"Norway\", 1)] public async Task ShouldGetCustomers(IQueryExecutor queryExecutor, string country, int expectedCount) { var result = await queryExecutor.ExecuteAsync(new CustomersQuery() { Country = country }); Assert.Equal(expectedCount, result.Length); } Transactions \u00b6 We are going to build upon the standard IDbConnection and IDbTransaction interfaces and provide a way to transparently apply transactions to command handlers. Requirements: Transactions should as short lived as possible. Only one transaction per scope (web request) Support sequential and nested execution of command handlers within the same transaction. Allow integration tests to roll back changes when the test ends. This might seem like a tall order and the solution might look a bit controversial, but bare with me on this one and you will see that the implementation is actually quite simple. Inserting data \u00b6 Before we start to think about transactions, we need something that writes to the database. A simple insert should do the trick. public class AddCustomerCommandHandler : ICommandHandler<AddCustomerCommand> { private readonly IDbConnection dbConnection; public AddCustomerCommandHandler(IDbConnection dbConnection) { this.dbConnection = dbConnection; } public async Task HandleAsync(AddCustomerCommand command) { await dbConnection.ExecuteAsync(SQL.InsertCustomer, command); } } The command handler takes care of executing a simple insert into the Customers table using the ExecuteAsync extension method provided by Dapper . The AddCustomerCommand is just a simple POCO class that contains the data to be inserted. public class AddCustomerCommand { public string CustomerId { get; set; } public string CompanyName { get; set; } } The SQL looks like this: INSERT INTO Customers ( CustomerId , CompanyName ) VALUES ( @ CustomerId , @ CompanyName ) Wrapping command handlers inside a transaction is just a matter of applying a simple decorator. public class TransactionalCommandHandler<TCommand> : ICommandHandler<TCommand> { private readonly IDbConnection dbConnection; private readonly ICommandHandler<TCommand> commandHandler; public TransactionalCommandHandler(IDbConnection dbConnection, ICommandHandler<TCommand> commandHandler) { this.dbConnection = dbConnection; this.commandHandler = commandHandler; } public async Task HandleAsync(TCommand command) { using (var transaction = dbConnection.BeginTransaction()) { await commandHandler.HandleAsync(command); transaction.Commit(); } } } With a single line of code in the composition root , we can now apply this decorator to all command handlers. serviceRegistry.Decorate(typeof(ICommandHandler<>), typeof(TransactionalCommandHandler<>)); Multiple command handlers \u00b6 Within a single scope (web request), we might have to execute more than one command handler, either sequentially or nested within each other. Since we now have an all-purpose decorator ( TransactionalCommandHandler ) that starts a new transaction before each underlying command handler, we need to make sure that only one transaction exists within the scope (web request). We do this by implementing yet another decorator and this time a decorator for the IDbConnection interface. public class ConnectionDecorator : IDbConnection { private readonly IDbConnection dbConnection; private readonly Lazy<TransactionDecorator> dbTransaction; public ConnectionDecorator(IDbConnection dbConnection) { this.dbConnection = dbConnection; dbTransaction = new Lazy<TransactionDecorator>(() => new TransactionDecorator(this, dbConnection.BeginTransaction())); } public void Dispose() { if (dbTransaction.IsValueCreated) { dbTransaction.Value.EndTransaction(); } dbConnection.Dispose(); } public IDbTransaction BeginTransaction() { dbTransaction.Value.IncrementTransactionCount(); return dbTransaction.Value; } public IDbTransaction BeginTransaction(IsolationLevel il) { return BeginTransaction(); } public void Close() { dbConnection.Close(); } public void ChangeDatabase(string databaseName) { dbConnection.ChangeDatabase(databaseName); } public IDbCommand CreateCommand() { return dbConnection.CreateCommand(); } public void Open() { dbConnection.Open(); } public string ConnectionString { get { return dbConnection.ConnectionString; } set { dbConnection.ConnectionString = value; } } public int ConnectionTimeout { get { return dbConnection.ConnectionTimeout; } } public string Database { get { return dbConnection.Database; } } public ConnectionState State { get { return dbConnection.State; } } } Most of the methods and properties here just call into the underlying IDbConnection , except for the Dispose and BeginTransaction methods that we will explain in a minute. But first the code for the TransactionDecorator public class TransactionDecorator : IDbTransaction { private readonly IDbTransaction dbTransaction; private int transactionCount; private int commitCount; public TransactionDecorator(IDbConnection dbConnection, IDbTransaction dbTransaction) { Connection = dbConnection; this.dbTransaction = dbTransaction; } public void IncrementTransactionCount() { transactionCount++; } public void EndTransaction() { if (commitCount == transactionCount) { dbTransaction.Commit(); } else { dbTransaction.Rollback(); } dbTransaction.Dispose(); } public void Dispose() { } public virtual void Commit() { commitCount++; } public void Rollback() { } public IDbConnection Connection { get; } public IsolationLevel IsolationLevel => dbTransaction.IsolationLevel; } Okay, it is time to what is going on here. Hang on! When the BeginTransaction method is executed we create a new IDbTransaction and wraps that transaction inside a TransactionDecorator . This transaction is provided through a Lazy<T> that makes sure that we only create a single transaction no matter how many times the BeginTransaction method is called. We also increment the \" transactionCount \" which basically reflects the number of calls to the BeginTransaction method. The \" transactionCount \" is then used inside the EndTransaction method to decide if we should perform a commit or a rollback. The rule here is simple. In order for the transaction to be committed, we need the commitCount to be equal to the transactionCount . If they are not equal it means that a BeginTransaction was executed without a commit. In that case we do a rollback. The EndTransaction method is called from the Dispose method inside the the ConnectionDecorator that first checks if we actually have a transaction at all. If so, we execute the EndTransaction method and finally disposes the underlying connection. The connection is as mentioned before disposed when the scope (web request) ends because it is registered with the PerScopeLifetime . Plugging all this goodness into our code is a simple as serviceRegistry.Decorate<IDbConnection, ConnectionDecorator>(); We can now execute nested command handlers as well as command handlers sequentially and still have them operate within the same transaction that either gets committed or rolled back when the connection is disposed. Automatic rollback \u00b6 Integration tests that writes to the database should perform a rollback when the test ends. This is now just a matter of adding another decorator that simply executes a rollback rather than a commit. public class RollbackCommandHandler<TCommand> : ICommandHandler<TCommand> { private readonly IDbConnection dbConnection; private readonly ICommandHandler<TCommand> commandHandler; public RollbackCommandHandler(IDbConnection dbConnection, ICommandHandler<TCommand> commandHandler) { this.dbConnection = dbConnection; this.commandHandler = commandHandler; } public async Task HandleAsync(TCommand command) { using (var transaction = dbConnection.BeginTransaction()) { await commandHandler.HandleAsync(command); transaction.Rollback(); } } } This decorator only lives in the test project and we can apply the decorator by implementing a static Configure method in the test class. public static void Configure(IServiceContainer container) { container.RegisterFrom<CompositionRoot>(); container.Decorate(typeof(ICommandHandler<>), typeof(RollbackCommandHandler<>)); } We can now finally write a test that verifies that a new customer has been written to the database. [Theory, Scoped, InjectData] public async Task ShouldAddCustomer(ICommandExecutor commandExecutor, IQueryExecutor queryExecutor) { await commandExecutor.ExecuteAsync(new AddCustomerCommand {CustomerId = \"AAPL\", CompanyName = \"Apple Inc\"}); var newCustomer = await queryExecutor.ExecuteAsync(new CustomerQuery {CustomerId = \"AAPL\"}); Assert.Equal(\"Apple Inc\", newCustomer.CompanyName); } Since the transaction is not ended until the test ends, we can still query the database for the newly inserted customer and verify that is was inserted. Testing Controllers \u00b6 Testing the public API in a Web API application means testing the controllers and by using the Microsoft.Owin.Testing package we can create an in-memory server that lets us test our Owin based web application end to end. Lets just quickly take a look at the controller we are going to test. public class CustomersController : ApiController { private readonly IQueryExecutor queryExecutor; public CustomersController(IQueryExecutor queryExecutor) { this.queryExecutor = queryExecutor; } public async Task<IHttpActionResult> Get(string country) { var customers = await queryExecutor.ExecuteAsync(new CustomersQuery {Country = country}); return Ok(customers); } } A typical test for this controller would look like this. [Fact] public async Task ShouldGetCustomersUsingTestServer() { using (var server = TestServer.Create<Startup>()) { HttpClient client = server.HttpClient; HttpResponseMessage response = await client.GetAsync(\"api/customers?country=Germany\"); string content = await response.Content.ReadAsStringAsync(); Customer[] customers = JsonConvert.DeserializeObject<Customer[]>(content); Assert.Equal(11, customers.Length); } } Let's create an extension method to help us shorten this code a bit. public static class HttpClientExtensions { public static async Task<Response<TResult>> GetAsync<TResult>(this HttpClient client, string requestUri) { var responseMessage = await client.GetAsync(requestUri).ConfigureAwait(false); Response<TResult> response = new Response<TResult>() {Message = responseMessage}; if (responseMessage.IsSuccessStatusCode) { var content = await responseMessage.Content.ReadAsStringAsync().ConfigureAwait(false); response.Value = JsonConvert.DeserializeObject<TResult>(content); } return response; } } This extension method returns the response as a Response<T> that contains the HttpResponseMessage and the typed result object. This means that we can do asserts on the actual result in addition to data related to the request such as the HttpStatusCode . [Fact] public async Task ShouldGetCustomersUsingExtensionMethod() { using (var server = TestServer.Create<Startup>()) { HttpClient client = server.HttpClient; var response = await client.GetAsync<Customer[]>(\"api/customers?country=Germany\"); Assert.Equal(11, response.Value.Length); } } The nice thing about the TestServer is that it allows us to pass the Startup class to be used for the test. This means that we can pass a startup class that might be specific to the test. The startup class for this application looks like this. public class Startup { public Startup() { Container = new ServiceContainer(); } public void Configuration(IAppBuilder app) { var config = new HttpConfiguration(); Configure(Container); ConfigureMediaFormatter(config); ConfigureHttpRoutes(config); Container.RegisterApiControllers(); Container.EnableWebApi(config); app.UseWebApi(config); } private static void ConfigureMediaFormatter(HttpConfiguration configuration) { configuration.Formatters.Clear(); configuration.Formatters.Add(new JsonMediaTypeFormatter()); } private static void ConfigureHttpRoutes(HttpConfiguration config) { config.Routes.MapHttpRoute( name: \"API Default\", routeTemplate: \"api/{controller}/{id}\", defaults: new { id = RouteParameter.Optional }); } public virtual void Configure(IServiceContainer serviceContainer) { serviceContainer.RegisterFrom<CompositionRoot>(); } public IServiceContainer Container { get; } } The thing to notice here is that we have a virtual Configure method that makes it possible to inherit from this class in a test project and override the way we configure the container. We also expose the container used by Web Api so that we can get access to it in an inherited startup class. The next class is a base class for testing controllers that makes it possible to specify the startup class type as a generic argument to the class itself. public abstract class ControllerTestBase<TStartup> where TStartup : Startup, new() { public static void Configure(IServiceContainer container) { var startup = new TStartup(); container.Register(factory => TestServer.Create(builder => startup.Configuration(builder)), new PerScopeLifetime()); container.Register(CreateHttpClient); } private static HttpClient CreateHttpClient(IServiceFactory container) { var testServer = container.GetInstance<TestServer>(); var httpClient = new HttpClient(testServer.Handler); httpClient.BaseAddress = testServer.BaseAddress; return httpClient; } } This base class now makes it possible to specify the startup class and it also allows us to inject the HttpClient instance. public class ControllerTests : ControllerTestBase<Startup> { [Theory, Scoped, InjectData] public async Task ShouldGetCustomersUsingInjectedClient(HttpClient client) { var response = await client.GetAsync<Customer[]>(\"api/customers?country=Germany\"); Assert.Equal(11, response.Value.Length); } } Being good REST citizens, we should also make sure that we return the correct status code along with the content. Say now that we want to test that the service returns 204-NoContent if no customers are found for the given country. We could do this by making sure that we have the appropriate test data in the database or we could mock the IQueryExecutor and have it return an empty list without even touching the database. By extending the HttpClient we can really simplify the way to mock services used in the test. public class TestClient : HttpClient { private readonly IServiceRegistry serviceRegistry; public TestClient(IServiceRegistry serviceRegistry, HttpMessageHandler handler) : base(handler) { this.serviceRegistry = serviceRegistry; } public Mock<TService> Mock<TService>() where TService:class { var mock = new Mock<TService>(); serviceRegistry.Override(registration => registration.ServiceType == typeof(TService), (factory, registration) => CreateMockRegistration(mock)); return mock; } private static ServiceRegistration CreateMockRegistration<TService>(Mock<TService> mock) where TService:class { return new ServiceRegistration() {ServiceType = typeof(TService), Value = mock.Object }; } } This class basically replaces the existing IQueryExecutor registration with a mock instance and makes it possible to mock services very easily. [Theory, Scoped, InjectData] public async Task ShouldReturnNoContent(TestClient client) { var mock = client.Mock<IQueryExecutor>(); mock.Setup(m => m.ExecuteAsync(It.IsAny<IQuery<Customer[]>>())).ReturnsAsync(new Customer[] {}); var response = await client.GetAsync<Customer[]>(\"api/customers?country=Germany\"); Assert.Equal(HttpStatusCode.NoContent, response.Message.StatusCode); }","title":"Transactions and Testing"},{"location":"transactions/#transaction-management","text":"In this example we will be looking into how to deal with connections and transactions in a Web application. We will also discuss how to implement automatic rollback for integration tests. Our testing framework will be xUnit and together with LightInject this will hopefully turn into a very smooth testing experience.","title":"Transaction Management"},{"location":"transactions/#commands-and-queries","text":"There are many ways to manage the interaction with the database and in this application we are going to implement something that has come to be known as the Command-Query pattern. The basic idea here is that we have one interface ( IQueryHandler ) for everything that comes out of the database and another interface ( ICommandHandler )for everything that goes into the database. The fact that we are dealing with the same set of interfaces for all interaction with the database means that we can very easily add features through the use of decorators. I am not going to cover everything with regards to command and queries here, but we will look into the interfaces we need to implement in order to shuffle data back and forth to the database.","title":"Commands and Queries"},{"location":"transactions/#queries","text":"The following interface represents a class that can handle a query and return some kind of result. public interface IQueryHandler<in TQuery, TResult> where TQuery : IQuery<TResult> { Task<TResult> HandleAsync(TQuery query); } You might wonder about the IQuery<TResult> generic contraint. This is just an interface to give type inference a helping hand as we move on to the next interface. The IQueryExecutor represents a class that can execute any query. public interface IQueryExecutor { Task<TResult> ExecuteAsync<TResult>(IQuery<TResult> query); } This is where the IQuery<TResult> generic contraint comes into play. Without the contraint we would have to specify the type of result when calling the ExecuteAsync method. var result = queryExecutor.ExecuteAsync<SomeResultType>(somequery); With the query class \"implementing\" the IQuery<TResult> interface we can instead do this var result = queryExecutor.ExecuteAsync(somequery);","title":"Queries"},{"location":"transactions/#commands","text":"The following interface represents a class that can handle a command where the command can be any class. public interface ICommandHandler<in TCommand> { Task HandleAsync(TCommand command); } Will be seeing examples of both queries and commands throughout this example.","title":"Commands"},{"location":"transactions/#why-not-an-orm","text":"The best answer I can give you is that I have already been there and felt the pain that eventually comes sneaking upon you. A little at first and then more and more as things gets more complicated. In fact, I have actually written an inhouse ORM back in the days and writing a Linq provider for instance, certainly represents the Mount Everest of programming. Not because Linq is so hard, but because you have to deal with all the mismatches between the relational model and the object model. ORM's tries to free you from understanding SQL and it is such a failed abstraction. Eventually at some point, you find yourself in a situation where you are trying to come up with a Linq expression that generates the SQL you've already written. Bottom line, bite the bullet and learn SQL.","title":"Why not an ORM?"},{"location":"transactions/#customers","text":"The first task is to create a query handler that can retrieve customers from the database based on their origin (country). The SQL for ths look like this: SELECT CustomerId , CompanyName FROM Customers WHERE Country = @ Country ; With the SQL in place, we are ready to implement the query handler. public class CustomersQueryHandler : IQueryHandler<CustomersQuery, Customer[]> { private readonly IDbConnection dbConnection; public CustomersQueryHandler(IDbConnection dbConnection) { this.dbConnection = dbConnection; } public async Task<Customer[]> HandleAsync(CustomersQuery query) { var result = await dbConnection.QueryAsync<CustomerRow>(SQL.CustomersByCountry, query); return result.ToArray(); } } Note: Query and command handlers does not dictate that the data is stored in a relational database. It might just as well be stored in a file or another type of database such as a document database. This query handler has just one dependency, the IDbConnection off which Dapper provides the QueryAsync method used to execute the query. The query ( CustomersQuery ) looks like this public class CustomersQuery : IQuery<Customer[]> { public string Country { get; set; } }","title":"Customers"},{"location":"transactions/#passing-data-through-layers","text":"Okay, so we have our application that consists of different layers. Data Access Layer (query and command handlers) Business Layer (services using the data access layer) Public API (typically a REST based API using services from the business layer)","title":"Passing data through layers"},{"location":"transactions/#data-access-layer","text":"This is where we actually interact with the underlying data store which for most applications even today means a relational database. These databases store relational data and is not very well suited for storing objects and we should treat the database accordingly. Relational databases does not store objects, they store rows of data. This is why we represent the result from Dapper as a set of CustomerRow instances.","title":"Data Access Layer"},{"location":"transactions/#business-layer","text":"This layer consists of the services that in turn will be using the data access layer. This is also the place to put any kind of business logic related to our services. By mocking the data access layer we can test this functionality without hitting the database.","title":"Business Layer"},{"location":"transactions/#api-layer","text":"This is our public API which in this sample application is exposed as a RESTful API using Web Api. Try to keep this layer as thin as possible. It should not deal with any kind of business logic, but it should for instance deal with making sure that we return the correct status codes according to REST best practices. So should each layer have its own representation of the same data? My answer is this: Be pragmatic about this. If the representation looks identical throughout the various layers, you might as well reuse the same class for different layers. Once you need to add JsonIgnore attributes to ensure that database-only properties does not get exposed in the Web API, you might consider another representation. It is also likely that the representations for reading and writing will differ so there is a lot to consider her. There is also a performance penalty involved here since we need to constantly map the \"same\" data between layers. There might also be situations where the service layer just acts as a pass-t through layer and it that case it might be just fine to use the query/command handlers directly in our controllers.","title":"API Layer"},{"location":"transactions/#composition-root","text":"The composition root is where we register services into the container. serviceRegistry.Register<IQueryExecutor, QueryExecutor>(new PerContainerLifetime()); serviceRegistry.RegisterQueryHandlers(); // We register the connection that it is disposed when the scope ends. // The scope here is per web request. serviceRegistry.Register(factory => CreateConnection(), new PerScopeLifetime()); We register the IDbConnection with the PerScopeLifetime which means that we get the same connection within a scope. The scope is usually per web request, but it can also be per test method as we will see in a minute. This is actually a nice aspect of the scoping mechanism in LightInject. We tell a service to be per scope without providing any details about how the scope is started or ended.","title":"Composition Root"},{"location":"transactions/#testing-query-handlers","text":"Before we dive into how to handle transactions, we are going to look at how to test our new query handler. LightInject provides an extension( LightInject.xUnit ) that makes it possible to inject services into test methods. [Theory, Scoped, InjectData] public async Task ShouldGetCustomersFromGermany(IQueryExecutor queryExecutor) { var query = new CustomersQuery {Country = \"Germany\"}; var result = await queryExecutor.ExecuteAsync(query); Assert.Equal(11, result.Length); } The Scoped attribute tells LightInject to wrap a scope around this test method. When the test method ends, the scope will end as well and that will in turn cause the IDbConnection to be disposed since that service is registered with the PerScopeLifetime . The InjectData attribute simply tells LightInject to inject method arguments and can be thought off as a more sophisticated version of the InlineData attribute usually seen in xUnit theory based tests. LightInject.xUnit creates a container instance behind the scenes and uses that instance to inject services into the test methods. The default behavior in LightInject is to look for composition roots in the same assembly as the requested service. This is part of the fallback mechanism and means that we don't really need to explicitly configure the container in the test class although it is possible to do so by declaring the following static method. public static void Configure(IServiceContainer container) { container.RegisterFrom<CompositionRoot>(); } We can also use the InjectData attribute so specify inline data in addition to the service being injected. [Theory, Scoped] [InjectData(\"France\", 11)] [InjectData(\"Germany\", 11)] [InjectData(\"Norway\", 1)] public async Task ShouldGetCustomers(IQueryExecutor queryExecutor, string country, int expectedCount) { var result = await queryExecutor.ExecuteAsync(new CustomersQuery() { Country = country }); Assert.Equal(expectedCount, result.Length); }","title":"Testing query handlers"},{"location":"transactions/#transactions","text":"We are going to build upon the standard IDbConnection and IDbTransaction interfaces and provide a way to transparently apply transactions to command handlers. Requirements: Transactions should as short lived as possible. Only one transaction per scope (web request) Support sequential and nested execution of command handlers within the same transaction. Allow integration tests to roll back changes when the test ends. This might seem like a tall order and the solution might look a bit controversial, but bare with me on this one and you will see that the implementation is actually quite simple.","title":"Transactions"},{"location":"transactions/#inserting-data","text":"Before we start to think about transactions, we need something that writes to the database. A simple insert should do the trick. public class AddCustomerCommandHandler : ICommandHandler<AddCustomerCommand> { private readonly IDbConnection dbConnection; public AddCustomerCommandHandler(IDbConnection dbConnection) { this.dbConnection = dbConnection; } public async Task HandleAsync(AddCustomerCommand command) { await dbConnection.ExecuteAsync(SQL.InsertCustomer, command); } } The command handler takes care of executing a simple insert into the Customers table using the ExecuteAsync extension method provided by Dapper . The AddCustomerCommand is just a simple POCO class that contains the data to be inserted. public class AddCustomerCommand { public string CustomerId { get; set; } public string CompanyName { get; set; } } The SQL looks like this: INSERT INTO Customers ( CustomerId , CompanyName ) VALUES ( @ CustomerId , @ CompanyName ) Wrapping command handlers inside a transaction is just a matter of applying a simple decorator. public class TransactionalCommandHandler<TCommand> : ICommandHandler<TCommand> { private readonly IDbConnection dbConnection; private readonly ICommandHandler<TCommand> commandHandler; public TransactionalCommandHandler(IDbConnection dbConnection, ICommandHandler<TCommand> commandHandler) { this.dbConnection = dbConnection; this.commandHandler = commandHandler; } public async Task HandleAsync(TCommand command) { using (var transaction = dbConnection.BeginTransaction()) { await commandHandler.HandleAsync(command); transaction.Commit(); } } } With a single line of code in the composition root , we can now apply this decorator to all command handlers. serviceRegistry.Decorate(typeof(ICommandHandler<>), typeof(TransactionalCommandHandler<>));","title":"Inserting data"},{"location":"transactions/#multiple-command-handlers","text":"Within a single scope (web request), we might have to execute more than one command handler, either sequentially or nested within each other. Since we now have an all-purpose decorator ( TransactionalCommandHandler ) that starts a new transaction before each underlying command handler, we need to make sure that only one transaction exists within the scope (web request). We do this by implementing yet another decorator and this time a decorator for the IDbConnection interface. public class ConnectionDecorator : IDbConnection { private readonly IDbConnection dbConnection; private readonly Lazy<TransactionDecorator> dbTransaction; public ConnectionDecorator(IDbConnection dbConnection) { this.dbConnection = dbConnection; dbTransaction = new Lazy<TransactionDecorator>(() => new TransactionDecorator(this, dbConnection.BeginTransaction())); } public void Dispose() { if (dbTransaction.IsValueCreated) { dbTransaction.Value.EndTransaction(); } dbConnection.Dispose(); } public IDbTransaction BeginTransaction() { dbTransaction.Value.IncrementTransactionCount(); return dbTransaction.Value; } public IDbTransaction BeginTransaction(IsolationLevel il) { return BeginTransaction(); } public void Close() { dbConnection.Close(); } public void ChangeDatabase(string databaseName) { dbConnection.ChangeDatabase(databaseName); } public IDbCommand CreateCommand() { return dbConnection.CreateCommand(); } public void Open() { dbConnection.Open(); } public string ConnectionString { get { return dbConnection.ConnectionString; } set { dbConnection.ConnectionString = value; } } public int ConnectionTimeout { get { return dbConnection.ConnectionTimeout; } } public string Database { get { return dbConnection.Database; } } public ConnectionState State { get { return dbConnection.State; } } } Most of the methods and properties here just call into the underlying IDbConnection , except for the Dispose and BeginTransaction methods that we will explain in a minute. But first the code for the TransactionDecorator public class TransactionDecorator : IDbTransaction { private readonly IDbTransaction dbTransaction; private int transactionCount; private int commitCount; public TransactionDecorator(IDbConnection dbConnection, IDbTransaction dbTransaction) { Connection = dbConnection; this.dbTransaction = dbTransaction; } public void IncrementTransactionCount() { transactionCount++; } public void EndTransaction() { if (commitCount == transactionCount) { dbTransaction.Commit(); } else { dbTransaction.Rollback(); } dbTransaction.Dispose(); } public void Dispose() { } public virtual void Commit() { commitCount++; } public void Rollback() { } public IDbConnection Connection { get; } public IsolationLevel IsolationLevel => dbTransaction.IsolationLevel; } Okay, it is time to what is going on here. Hang on! When the BeginTransaction method is executed we create a new IDbTransaction and wraps that transaction inside a TransactionDecorator . This transaction is provided through a Lazy<T> that makes sure that we only create a single transaction no matter how many times the BeginTransaction method is called. We also increment the \" transactionCount \" which basically reflects the number of calls to the BeginTransaction method. The \" transactionCount \" is then used inside the EndTransaction method to decide if we should perform a commit or a rollback. The rule here is simple. In order for the transaction to be committed, we need the commitCount to be equal to the transactionCount . If they are not equal it means that a BeginTransaction was executed without a commit. In that case we do a rollback. The EndTransaction method is called from the Dispose method inside the the ConnectionDecorator that first checks if we actually have a transaction at all. If so, we execute the EndTransaction method and finally disposes the underlying connection. The connection is as mentioned before disposed when the scope (web request) ends because it is registered with the PerScopeLifetime . Plugging all this goodness into our code is a simple as serviceRegistry.Decorate<IDbConnection, ConnectionDecorator>(); We can now execute nested command handlers as well as command handlers sequentially and still have them operate within the same transaction that either gets committed or rolled back when the connection is disposed.","title":"Multiple command handlers"},{"location":"transactions/#automatic-rollback","text":"Integration tests that writes to the database should perform a rollback when the test ends. This is now just a matter of adding another decorator that simply executes a rollback rather than a commit. public class RollbackCommandHandler<TCommand> : ICommandHandler<TCommand> { private readonly IDbConnection dbConnection; private readonly ICommandHandler<TCommand> commandHandler; public RollbackCommandHandler(IDbConnection dbConnection, ICommandHandler<TCommand> commandHandler) { this.dbConnection = dbConnection; this.commandHandler = commandHandler; } public async Task HandleAsync(TCommand command) { using (var transaction = dbConnection.BeginTransaction()) { await commandHandler.HandleAsync(command); transaction.Rollback(); } } } This decorator only lives in the test project and we can apply the decorator by implementing a static Configure method in the test class. public static void Configure(IServiceContainer container) { container.RegisterFrom<CompositionRoot>(); container.Decorate(typeof(ICommandHandler<>), typeof(RollbackCommandHandler<>)); } We can now finally write a test that verifies that a new customer has been written to the database. [Theory, Scoped, InjectData] public async Task ShouldAddCustomer(ICommandExecutor commandExecutor, IQueryExecutor queryExecutor) { await commandExecutor.ExecuteAsync(new AddCustomerCommand {CustomerId = \"AAPL\", CompanyName = \"Apple Inc\"}); var newCustomer = await queryExecutor.ExecuteAsync(new CustomerQuery {CustomerId = \"AAPL\"}); Assert.Equal(\"Apple Inc\", newCustomer.CompanyName); } Since the transaction is not ended until the test ends, we can still query the database for the newly inserted customer and verify that is was inserted.","title":"Automatic rollback"},{"location":"transactions/#testing-controllers","text":"Testing the public API in a Web API application means testing the controllers and by using the Microsoft.Owin.Testing package we can create an in-memory server that lets us test our Owin based web application end to end. Lets just quickly take a look at the controller we are going to test. public class CustomersController : ApiController { private readonly IQueryExecutor queryExecutor; public CustomersController(IQueryExecutor queryExecutor) { this.queryExecutor = queryExecutor; } public async Task<IHttpActionResult> Get(string country) { var customers = await queryExecutor.ExecuteAsync(new CustomersQuery {Country = country}); return Ok(customers); } } A typical test for this controller would look like this. [Fact] public async Task ShouldGetCustomersUsingTestServer() { using (var server = TestServer.Create<Startup>()) { HttpClient client = server.HttpClient; HttpResponseMessage response = await client.GetAsync(\"api/customers?country=Germany\"); string content = await response.Content.ReadAsStringAsync(); Customer[] customers = JsonConvert.DeserializeObject<Customer[]>(content); Assert.Equal(11, customers.Length); } } Let's create an extension method to help us shorten this code a bit. public static class HttpClientExtensions { public static async Task<Response<TResult>> GetAsync<TResult>(this HttpClient client, string requestUri) { var responseMessage = await client.GetAsync(requestUri).ConfigureAwait(false); Response<TResult> response = new Response<TResult>() {Message = responseMessage}; if (responseMessage.IsSuccessStatusCode) { var content = await responseMessage.Content.ReadAsStringAsync().ConfigureAwait(false); response.Value = JsonConvert.DeserializeObject<TResult>(content); } return response; } } This extension method returns the response as a Response<T> that contains the HttpResponseMessage and the typed result object. This means that we can do asserts on the actual result in addition to data related to the request such as the HttpStatusCode . [Fact] public async Task ShouldGetCustomersUsingExtensionMethod() { using (var server = TestServer.Create<Startup>()) { HttpClient client = server.HttpClient; var response = await client.GetAsync<Customer[]>(\"api/customers?country=Germany\"); Assert.Equal(11, response.Value.Length); } } The nice thing about the TestServer is that it allows us to pass the Startup class to be used for the test. This means that we can pass a startup class that might be specific to the test. The startup class for this application looks like this. public class Startup { public Startup() { Container = new ServiceContainer(); } public void Configuration(IAppBuilder app) { var config = new HttpConfiguration(); Configure(Container); ConfigureMediaFormatter(config); ConfigureHttpRoutes(config); Container.RegisterApiControllers(); Container.EnableWebApi(config); app.UseWebApi(config); } private static void ConfigureMediaFormatter(HttpConfiguration configuration) { configuration.Formatters.Clear(); configuration.Formatters.Add(new JsonMediaTypeFormatter()); } private static void ConfigureHttpRoutes(HttpConfiguration config) { config.Routes.MapHttpRoute( name: \"API Default\", routeTemplate: \"api/{controller}/{id}\", defaults: new { id = RouteParameter.Optional }); } public virtual void Configure(IServiceContainer serviceContainer) { serviceContainer.RegisterFrom<CompositionRoot>(); } public IServiceContainer Container { get; } } The thing to notice here is that we have a virtual Configure method that makes it possible to inherit from this class in a test project and override the way we configure the container. We also expose the container used by Web Api so that we can get access to it in an inherited startup class. The next class is a base class for testing controllers that makes it possible to specify the startup class type as a generic argument to the class itself. public abstract class ControllerTestBase<TStartup> where TStartup : Startup, new() { public static void Configure(IServiceContainer container) { var startup = new TStartup(); container.Register(factory => TestServer.Create(builder => startup.Configuration(builder)), new PerScopeLifetime()); container.Register(CreateHttpClient); } private static HttpClient CreateHttpClient(IServiceFactory container) { var testServer = container.GetInstance<TestServer>(); var httpClient = new HttpClient(testServer.Handler); httpClient.BaseAddress = testServer.BaseAddress; return httpClient; } } This base class now makes it possible to specify the startup class and it also allows us to inject the HttpClient instance. public class ControllerTests : ControllerTestBase<Startup> { [Theory, Scoped, InjectData] public async Task ShouldGetCustomersUsingInjectedClient(HttpClient client) { var response = await client.GetAsync<Customer[]>(\"api/customers?country=Germany\"); Assert.Equal(11, response.Value.Length); } } Being good REST citizens, we should also make sure that we return the correct status code along with the content. Say now that we want to test that the service returns 204-NoContent if no customers are found for the given country. We could do this by making sure that we have the appropriate test data in the database or we could mock the IQueryExecutor and have it return an empty list without even touching the database. By extending the HttpClient we can really simplify the way to mock services used in the test. public class TestClient : HttpClient { private readonly IServiceRegistry serviceRegistry; public TestClient(IServiceRegistry serviceRegistry, HttpMessageHandler handler) : base(handler) { this.serviceRegistry = serviceRegistry; } public Mock<TService> Mock<TService>() where TService:class { var mock = new Mock<TService>(); serviceRegistry.Override(registration => registration.ServiceType == typeof(TService), (factory, registration) => CreateMockRegistration(mock)); return mock; } private static ServiceRegistration CreateMockRegistration<TService>(Mock<TService> mock) where TService:class { return new ServiceRegistration() {ServiceType = typeof(TService), Value = mock.Object }; } } This class basically replaces the existing IQueryExecutor registration with a mock instance and makes it possible to mock services very easily. [Theory, Scoped, InjectData] public async Task ShouldReturnNoContent(TestClient client) { var mock = client.Mock<IQueryExecutor>(); mock.Setup(m => m.ExecuteAsync(It.IsAny<IQuery<Customer[]>>())).ReturnsAsync(new Customer[] {}); var response = await client.GetAsync<Customer[]>(\"api/customers?country=Germany\"); Assert.Equal(HttpStatusCode.NoContent, response.Message.StatusCode); }","title":"Testing Controllers"},{"location":"wcf/","text":"WCF \u00b6 LightInject.Wcf provides an integration that enables dependency injection in WCF applications. Installing \u00b6 PM> Install-Package LightInject.Wcf This adds a reference to the LightInject.Wcf.dll in the target project. Getting started \u00b6 LightInject.Wcf aims to provide a zero config approach to developing WCF services in addition to support both constructor and property injection for WCF service implementations. Note: If a Web site is precompiled for deployment, content provided by a VirtualPathProvider instance is not compiled, and no VirtualPathProviderinstances are used by the precompiled site. The easiest way to create a new WCF application is to start with a new empty web application and then install the LightInject.Wcf package. Our first service might look something like this: [ServiceContract] public interface IService { [OperationContract] int GetValue(int value); } public class Service : IService { public int GetValue(int value) { return value; } } The only thing we need to do is to create an ICompositionRoot implementation that registers our services and potentially its dependencies. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register<IService, Service>(); } } That's it. No XML config, no .svc files, just press F5 to run the application. Given that our service is defined in the SampleWcfApplication namespace, the service will be available at http://localhost:xxxxx/SampleWcfApplication.IService.svc Named Services \u00b6 If we want to identify our service by something else than the full type name of the service interface, we need to register the service using a name. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register<IService, Service>(\"MyService\"); } } Now we need one additional class to bootstrap the container so that the service is registered with the correct name before the service is invoked. [assembly: System.Web.PreApplicationStartMethod(typeof(SampleWcfApplication.Startup), \"Initialize\")] namespace SampleWcfApplication { using LightInject; using LightInject.Wcf; public class Startup { public static void Initialize() { var container = new ServiceContainer(); container.RegisterFrom<CompositionRoot>(); LightInjectServiceHostFactory.Container = container; } } } Behaviors \u00b6 While it still is possible to configure endpoint and service behaviors using XML, LightInject.Wcf allows for IEndpointBehavior and IServiceBehavior implementations to be registered with the container so that they can be applied to the service. public class SampleServiceBehavior : IServiceBehavior { public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) { } public void AddBindingParameters( ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters) { } public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) { } } public class SampleEndpointBehavior : IEndpointBehavior { public void Validate(ServiceEndpoint endpoint) { } public void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters) { } public void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher) { } public void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime) { } } In order to configure these endpoints we can simply register them with the container. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register<IService, Service>(); serviceRegistry.Register<IServiceBehavior, SampleServiceBehavior>(); serviceRegistry.Register<IEndpointBehavior, SampleEndpointBehavior>(); } }","title":"WCF"},{"location":"wcf/#wcf","text":"LightInject.Wcf provides an integration that enables dependency injection in WCF applications.","title":"WCF"},{"location":"wcf/#installing","text":"PM> Install-Package LightInject.Wcf This adds a reference to the LightInject.Wcf.dll in the target project.","title":"Installing"},{"location":"wcf/#getting-started","text":"LightInject.Wcf aims to provide a zero config approach to developing WCF services in addition to support both constructor and property injection for WCF service implementations. Note: If a Web site is precompiled for deployment, content provided by a VirtualPathProvider instance is not compiled, and no VirtualPathProviderinstances are used by the precompiled site. The easiest way to create a new WCF application is to start with a new empty web application and then install the LightInject.Wcf package. Our first service might look something like this: [ServiceContract] public interface IService { [OperationContract] int GetValue(int value); } public class Service : IService { public int GetValue(int value) { return value; } } The only thing we need to do is to create an ICompositionRoot implementation that registers our services and potentially its dependencies. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register<IService, Service>(); } } That's it. No XML config, no .svc files, just press F5 to run the application. Given that our service is defined in the SampleWcfApplication namespace, the service will be available at http://localhost:xxxxx/SampleWcfApplication.IService.svc","title":"Getting started"},{"location":"wcf/#named-services","text":"If we want to identify our service by something else than the full type name of the service interface, we need to register the service using a name. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register<IService, Service>(\"MyService\"); } } Now we need one additional class to bootstrap the container so that the service is registered with the correct name before the service is invoked. [assembly: System.Web.PreApplicationStartMethod(typeof(SampleWcfApplication.Startup), \"Initialize\")] namespace SampleWcfApplication { using LightInject; using LightInject.Wcf; public class Startup { public static void Initialize() { var container = new ServiceContainer(); container.RegisterFrom<CompositionRoot>(); LightInjectServiceHostFactory.Container = container; } } }","title":"Named Services"},{"location":"wcf/#behaviors","text":"While it still is possible to configure endpoint and service behaviors using XML, LightInject.Wcf allows for IEndpointBehavior and IServiceBehavior implementations to be registered with the container so that they can be applied to the service. public class SampleServiceBehavior : IServiceBehavior { public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) { } public void AddBindingParameters( ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters) { } public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) { } } public class SampleEndpointBehavior : IEndpointBehavior { public void Validate(ServiceEndpoint endpoint) { } public void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters) { } public void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher) { } public void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime) { } } In order to configure these endpoints we can simply register them with the container. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register<IService, Service>(); serviceRegistry.Register<IServiceBehavior, SampleServiceBehavior>(); serviceRegistry.Register<IEndpointBehavior, SampleEndpointBehavior>(); } }","title":"Behaviors"},{"location":"web/","text":"Web \u00b6 Enables LightInject to be used in a web application and provides support for PerWebRequest scoped service instances. Installing \u00b6 LightInject.Web provides two distribution models via NuGet Binary \u00b6 PM> Install-Package LightInject.Web This adds a reference to the LightInject.Web.dll in the target project. Source \u00b6 PM> Install-Package LightInject.Web.Source This will install a single file (LightInject.Web.cs) into the current project. The following example shows how to enable LightInject in the Application_Start event. protected void Application_Start() { var container = new ServiceContainer(); container.EnablePerWebRequestScope(); container.Register<IFoo, Foo>(new PerScopeLifetime()); } A service registered with PerScopeLifetime is scoped per web request and is disposed at the end of the request if it implements IDisposable .","title":"Web"},{"location":"web/#web","text":"Enables LightInject to be used in a web application and provides support for PerWebRequest scoped service instances.","title":"Web"},{"location":"web/#installing","text":"LightInject.Web provides two distribution models via NuGet","title":"Installing"},{"location":"web/#binary","text":"PM> Install-Package LightInject.Web This adds a reference to the LightInject.Web.dll in the target project.","title":"Binary"},{"location":"web/#source","text":"PM> Install-Package LightInject.Web.Source This will install a single file (LightInject.Web.cs) into the current project. The following example shows how to enable LightInject in the Application_Start event. protected void Application_Start() { var container = new ServiceContainer(); container.EnablePerWebRequestScope(); container.Register<IFoo, Foo>(new PerScopeLifetime()); } A service registered with PerScopeLifetime is scoped per web request and is disposed at the end of the request if it implements IDisposable .","title":"Source"},{"location":"webapi/","text":"Web API \u00b6 LightInject.WebApi provides an integration that enables dependency injection in Web API applications. Installing \u00b6 LightInject.WebApi provides two distribution models via NuGet Binary \u00b6 PM> Install-Package LightInject.WebApi This adds a reference to the LightInject.WebApi.dll in the target project. Source \u00b6 PM> Install-Package LightInject.WebApi.Source This will install a single file, LightInject.WebApi.cs in the target project. Initializing \u00b6 protected void Application_Start () { var container = new ServiceContainer (); container . RegisterApiControllers (); //register other services container . EnablePerWebRequestScope (); container . EnableWebApi ( GlobalConfiguration . Configuration ) } Note: EnablePerWebRequestScope is only required for hosting within ASP.Net FilterAttribute \u00b6 Although filter attributes are instantiated by the MFC infrastructure, LightInject is still able to inject dependencies into properties. public class FooFilterAttribute : ActionFilterAttribute { public IFoo Foo { get; set; } } Owin Selfhosting \u00b6 This example shows how to do Web API self hosting using OWIN. Step 1 \u00b6 Create a standard console application and run the following command from the package manager console. PM> Install-Package Microsoft.AspNet.WebApi.OwinSelfHost Step 2 \u00b6 Add a OWIN startup class. public class Startup { public void Configuration ( IAppBuilder app ) { // Configure Web API for self-host. var config = new HttpConfiguration (); config . Routes . MapHttpRoute ( name : \"DefaultApi\" , routeTemplate : \"api/{controller}/{id}\" , defaults : new { id = RouteParameter . Optional }); app . UseWebApi ( config ); } } ``` ### Step 3 ### Add a controller ``` csharp public class ValuesController : ApiController { public IEnumerable < string > Get () { return new string [] { \"value1\" , \"value2\" }; } } Step 4 \u00b6 Modify the Main method to start the OWIN host. class Program { static void Main ( string [] args ) { // Start OWIN host using ( WebApp . Start < Startup >( \"http://localhost:9000/\" )) { Console . ReadLine (); } Console . ReadLine (); } } Press F5 to run the application and browse to http://localhost:9000/api/values . Step 5 \u00b6 PM> Install-Package LightInject.WebApi Modify the Startup class to enable LightInject to be used as the dependency resolver. public class Startup { public void Configuration ( IAppBuilder app ) { // Configure Web API for self-host. var config = new HttpConfiguration (); var container = new ServiceContainer (); container . RegisterApiControllers (); container . EnableWebApi ( config ); config . Routes . MapHttpRoute ( name : \"DefaultApi\" , routeTemplate : \"api/{controller}/{id}\" , defaults : new { id = RouteParameter . Optional }); app . UseWebApi ( config ); } } Note: LightInject.Web can be uninstalled as it is not used in the self host scenario. Scoping \u00b6 Scopes are handled by Web API itself and services registered with the PerScopeLifetime or PerRequestLifetime are disposed when the web request ends. HttpRequestMessage \u00b6 The current HttpRequestMessage is available to us in the controllers as it is exposed through the Request property. To make the HttpRequestMessage available to other services we need to make some minor changes The following code will be included as part of the next version of LightInject.WebApi. The first thing we need is a handler that can keep track of the current HttpRequestMessage . internal class HttpRequestMessageHandler : DelegatingHandler { private LogicalThreadStorage < HttpRequestMessageStorage > messageStorage = new LogicalThreadStorage < HttpRequestMessageStorage >(() => new HttpRequestMessageStorage ()); protected override Task < HttpResponseMessage > SendAsync ( HttpRequestMessage request , CancellationToken cancellationToken ) { messageStorage . Value . Message = request ; return base . SendAsync ( request , cancellationToken ); } public HttpRequestMessage GetCurrentMessage () { return messageStorage . Value . Message ; } } The HttpRequestMessageStorage class is simply a \"holder\" class for the actual HttpRequestMessage . public class HttpRequestMessageStorage { public HttpRequestMessage Message { get ; set ; } } Next we modify the Startup class to support injection of a Func<HttpRequestMessage> . public class Startup { public void Configuration ( IAppBuilder app ) { // Configure Web API for self-host. var config = new HttpConfiguration (); var container = new ServiceContainer (); container . RegisterApiControllers (); container . EnableWebApi ( config ); container . ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider (); var handler = new HttpRequestMessageHandler (); config . MessageHandlers . Insert ( 0 , handler ); container . Register < Func < HttpRequestMessage >>( factory => () => handler . GetCurrentMessage ()); config . Routes . MapHttpRoute ( name : \"DefaultApi\" , routeTemplate : \"api/{controller}/{id}\" , defaults : new { id = RouteParameter . Optional }); app . UseWebApi ( config ); } } Now, if we need access to the current HttpRequestMessage , we can just inject a function delegate. public class Foo { public Foo(Func<HttpRequestMessage> getCurrentRequestMessage) { var currentMessage = getCurrentRequestMessage(); } }","title":"Web Api"},{"location":"webapi/#web-api","text":"LightInject.WebApi provides an integration that enables dependency injection in Web API applications.","title":"Web API"},{"location":"webapi/#installing","text":"LightInject.WebApi provides two distribution models via NuGet","title":"Installing"},{"location":"webapi/#binary","text":"PM> Install-Package LightInject.WebApi This adds a reference to the LightInject.WebApi.dll in the target project.","title":"Binary"},{"location":"webapi/#source","text":"PM> Install-Package LightInject.WebApi.Source This will install a single file, LightInject.WebApi.cs in the target project.","title":"Source"},{"location":"webapi/#initializing","text":"protected void Application_Start () { var container = new ServiceContainer (); container . RegisterApiControllers (); //register other services container . EnablePerWebRequestScope (); container . EnableWebApi ( GlobalConfiguration . Configuration ) } Note: EnablePerWebRequestScope is only required for hosting within ASP.Net","title":"Initializing"},{"location":"webapi/#filterattribute","text":"Although filter attributes are instantiated by the MFC infrastructure, LightInject is still able to inject dependencies into properties. public class FooFilterAttribute : ActionFilterAttribute { public IFoo Foo { get; set; } }","title":"FilterAttribute"},{"location":"webapi/#owin-selfhosting","text":"This example shows how to do Web API self hosting using OWIN.","title":"Owin Selfhosting"},{"location":"webapi/#step-1","text":"Create a standard console application and run the following command from the package manager console. PM> Install-Package Microsoft.AspNet.WebApi.OwinSelfHost","title":"Step 1"},{"location":"webapi/#step-2","text":"Add a OWIN startup class. public class Startup { public void Configuration ( IAppBuilder app ) { // Configure Web API for self-host. var config = new HttpConfiguration (); config . Routes . MapHttpRoute ( name : \"DefaultApi\" , routeTemplate : \"api/{controller}/{id}\" , defaults : new { id = RouteParameter . Optional }); app . UseWebApi ( config ); } } ``` ### Step 3 ### Add a controller ``` csharp public class ValuesController : ApiController { public IEnumerable < string > Get () { return new string [] { \"value1\" , \"value2\" }; } }","title":"Step 2"},{"location":"webapi/#step-4","text":"Modify the Main method to start the OWIN host. class Program { static void Main ( string [] args ) { // Start OWIN host using ( WebApp . Start < Startup >( \"http://localhost:9000/\" )) { Console . ReadLine (); } Console . ReadLine (); } } Press F5 to run the application and browse to http://localhost:9000/api/values .","title":"Step 4"},{"location":"webapi/#step-5","text":"PM> Install-Package LightInject.WebApi Modify the Startup class to enable LightInject to be used as the dependency resolver. public class Startup { public void Configuration ( IAppBuilder app ) { // Configure Web API for self-host. var config = new HttpConfiguration (); var container = new ServiceContainer (); container . RegisterApiControllers (); container . EnableWebApi ( config ); config . Routes . MapHttpRoute ( name : \"DefaultApi\" , routeTemplate : \"api/{controller}/{id}\" , defaults : new { id = RouteParameter . Optional }); app . UseWebApi ( config ); } } Note: LightInject.Web can be uninstalled as it is not used in the self host scenario.","title":"Step 5"},{"location":"webapi/#scoping","text":"Scopes are handled by Web API itself and services registered with the PerScopeLifetime or PerRequestLifetime are disposed when the web request ends.","title":"Scoping"},{"location":"webapi/#httprequestmessage","text":"The current HttpRequestMessage is available to us in the controllers as it is exposed through the Request property. To make the HttpRequestMessage available to other services we need to make some minor changes The following code will be included as part of the next version of LightInject.WebApi. The first thing we need is a handler that can keep track of the current HttpRequestMessage . internal class HttpRequestMessageHandler : DelegatingHandler { private LogicalThreadStorage < HttpRequestMessageStorage > messageStorage = new LogicalThreadStorage < HttpRequestMessageStorage >(() => new HttpRequestMessageStorage ()); protected override Task < HttpResponseMessage > SendAsync ( HttpRequestMessage request , CancellationToken cancellationToken ) { messageStorage . Value . Message = request ; return base . SendAsync ( request , cancellationToken ); } public HttpRequestMessage GetCurrentMessage () { return messageStorage . Value . Message ; } } The HttpRequestMessageStorage class is simply a \"holder\" class for the actual HttpRequestMessage . public class HttpRequestMessageStorage { public HttpRequestMessage Message { get ; set ; } } Next we modify the Startup class to support injection of a Func<HttpRequestMessage> . public class Startup { public void Configuration ( IAppBuilder app ) { // Configure Web API for self-host. var config = new HttpConfiguration (); var container = new ServiceContainer (); container . RegisterApiControllers (); container . EnableWebApi ( config ); container . ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider (); var handler = new HttpRequestMessageHandler (); config . MessageHandlers . Insert ( 0 , handler ); container . Register < Func < HttpRequestMessage >>( factory => () => handler . GetCurrentMessage ()); config . Routes . MapHttpRoute ( name : \"DefaultApi\" , routeTemplate : \"api/{controller}/{id}\" , defaults : new { id = RouteParameter . Optional }); app . UseWebApi ( config ); } } Now, if we need access to the current HttpRequestMessage , we can just inject a function delegate. public class Foo { public Foo(Func<HttpRequestMessage> getCurrentRequestMessage) { var currentMessage = getCurrentRequestMessage(); } }","title":"HttpRequestMessage"},{"location":"webapirequestlogging/","text":"Web Api Request Logging \u00b6 This post is going to show you how to use LightInject to enable logging in a Web Api application. We are going to look into how to preserve contextual information associated with the incoming request so that this information can be used for logging purposes. All this goodness is going to end up in a simple console application that shows how all the pieces fit together. Logging \u00b6 Since logging is a cross cutting concern and is to be found scattered all around in our application, it makes sense to create an abstraction so that we don't create a direct dependency on a particular logging framework. This abstraction is something that we should own rather than relying on third part abstraction such as Common Logging . Believe me, that is going to cause us nothing but pain as we would have to deal with different versions of a third party abstraction. Own you own abstraction! We start of with a simple interface that is going to be used for logging. public interface ILog { void Info(string message); void Debug(string message); void Error(string message, Exception exception = null); } This is the interface that we will be injection into controllers, services or any other class that requires logging. The actual implementation of this interface looks like this public class Log : ILog { private readonly Action<string> logDebug; private readonly Action<string, Exception> logError; private readonly Action<string> logInfo; public Log(Action<string> logInfo, Action<string> logDebug, Action<string, Exception> logError) { this.logInfo = logInfo; this.logDebug = logDebug; this.logError = logError; } public void Info(string message) { logInfo(message); } public void Debug(string message) { logDebug(message); } public void Error(string message, Exception exception = null) { logError(message, exception); } } The Log class is not tied to a specific logging framework and it just takes a set of action delegates that represents the three logging levels supported by our abstraction. To help us create a Log instance, we have this nice little interface. public interface ILogFactory { ILog GetLogger(Type type); } And since we are going to be using Log4Net in this sample application, we have an implementation called Log4NetLogFactory . public class Log4NetLogFactory : ILogFactory { public Log4NetLogFactory() { XmlConfigurator.Configure(); } public ILog GetLogger(Type type) { var logger = LogManager.GetLogger(type); return new Log(logger.Info, logger.Debug, logger.Error); } } Note: This is the ONLY place where we actually reference Log4Net. Composition root \u00b6 This application has two composition roots ( ICompositionRoot ), one that registers the core services ( CompositionRoot )and one that registers services related to Web Api ( WebApiCompositionRoot ). public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register<ILogFactory, Log4NetLogFactory>(new PerContainerLifetime()); serviceRegistry.Register<Type, ILog>((factory, type) => factory.GetInstance<ILogFactory>().GetLogger(type)); serviceRegistry.RegisterConstructorDependency( (factory, info) => factory.GetInstance<Type, ILog>(info.Member.DeclaringType)); } } The first service that we register is the ILogFactory that is responsible for creating an ILog instance based on a given type. Next, we register the ILog service with a factory delegate that calls into the already registered ILogFactory service Finally we tell the container using the RegisterConstructorDependency method that whenever it sees an ILog constructor dependency, it should provide an ILog instance based on the actual class that uses it. public class WebApiCompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.RegisterFrom<CompositionRoot>(); serviceRegistry.RegisterApiControllers(); } } The WebApiCompositionRoot registers core services in addition services related to Web Api which in this case means the controllers. Controllers \u00b6 This application has just one controller named PingController that is simply going to return the text \"pong\". public class PingController : ApiController { private readonly ILog log; public PingController(ILog log) { this.log = log; } public async Task<IHttpActionResult> Get() { log.Info(\"Ping start\"); var result = Ok(\"Pong\"); log.Info(\"Ping end\"); return result; } } As we can see we are injecting an ILog instance into the controller. The Startup class for this application looks like this public class Startup { public void Configuration(IAppBuilder app) { var configuration = new HttpConfiguration(); ConfigureHttpRoutes(configuration); ConfigureMediaFormatter(configuration); var container = new ServiceContainer(); container.RegisterFrom<WebApiCompositionRoot>(); container.EnableWebApi(configuration); app.UseWebApi(configuration); } private static void ConfigureMediaFormatter(HttpConfiguration configuration) { configuration.Formatters.Clear(); configuration.Formatters.Add(new JsonMediaTypeFormatter()); } private static void ConfigureHttpRoutes(HttpConfiguration config) { config.Routes.MapHttpRoute( name: \"API Default\", routeTemplate: \"api/{controller}/{id}\", defaults: new { id = RouteParameter.Optional }); } } We can see all this in action just by running the application and hitting the service. http://localhost:8080/api/ping That should yield the following output in the console 2016-02-11 09:14:28.489 [INFO] 13 WebApiRequestLogging.PingController: Ping start 2016-02-11 09:14:28.603 [INFO] 6 WebApiRequestLogging.PingController: Ping end The Log4Net conversion pattern is like this (app.config) <conversionPattern value=\"%date{yyyy-MM-dd HH:mm:ss.fff} [%level] %thread %logger: %message%newline\" /> Request logging \u00b6 Sometimes it might be useful to log each request and maybe also the duration of the request. We start off with a simple class ( OwinMiddleware ) that logs the duration of the request. public class RequestLoggingMiddleware : OwinMiddleware { private readonly ILog log; public RequestLoggingMiddleware(OwinMiddleware next, ILog log) : base(next) { this.log = log; } public override async Task Invoke(IOwinContext context) { await Measure(context).ConfigureAwait(false);; } private async Task Measure(IOwinContext context) { var stopWath = Stopwatch.StartNew(); await Next.Invoke(context).ConfigureAwait(false); stopWath.Stop(); log.Info($\"Request {context.Request.Uri.PathAndQuery} took {stopWath.ElapsedMilliseconds} ms\"); } } In addition to this we need to add this new middleware to the Owin pipeline by adding this line to the Startup class. app.Use<RequestLoggingMiddleware>(container.GetInstance<Type, ILog>(typeof (RequestLogDecorator))); Note: The reason for using an OwinMiddleware instead of a DelegatingHandler is that the OwinMiddleware is not tied to Web Api in any way and can also be used in other frameworks that build upon the Owin stack. Console output should now be 2016-02-11 13:07:48.466 [INFO] 11 WebApiRequestLogging.RequestLoggingMiddleware: Request /api/ping took 4 ms Request Context \u00b6 In some situations it is useful to be able to associate all log entries with the current web request. This can be used for analyzing the log later in tools such as Splunk making it possible to see all log entries tied to any given request. We could make the IOwinContext available in the container so that it could be injected into any class that requires information about the current request. This would however mean that these classes would have to know about the IOwinContext which might not be the best solution. So let's start off simple by creating a class to hold the request identifier. public class RequestContext { public RequestContext(string id) { Id = id; } public string Id { get; } } Next we create another middleware class to set the request identifier. public class RequestContextMiddleware : OwinMiddleware { private static readonly AsyncLocal<RequestContext> RequestContextStorage = new AsyncLocal<RequestContext>(); public RequestContextMiddleware(OwinMiddleware next) : base(next) { } public override async Task Invoke(IOwinContext context) { RequestContextStorage.Value = new RequestContext(Guid.NewGuid().ToString()); await Next.Invoke(context); } public static RequestContext CurrentRequest => RequestContextStorage.Value; } The actual RequestContext uses the AsyncLocal<T> class to ensure that the context flows across await points. The AsyncLocal<T> class is sort of the async version of ThreadLocal<T> . You should NEVER rely on any kind of storage that is tied to a specific thread in an async environment. Then we need to add the RequestContextMiddleware to the Owin pipeline. app.Use<RequestContextMiddleware>(); We now have way to access the current RequestContext through the CurrentRequest property. Sweet. The only thing missing now is to register a function delegate that represent getting the current RequestContext . serviceRegistry.Register<Func<RequestContext>>(factory => (() => RequestContextMiddleware.CurrentRequest), new PerContainerLifetime()); The reason for injection a function delegate rather than just the RequestContext is that it might be used in services such as singletons that outlives the scope of a web request. By injecting the delegate that in turn gives us the RequestContext , we can be sure that it is valid. Decorators \u00b6 The requirement here is that if we are logging outside the context of a web request, such as in a unit test, we should just log without the request identifier, but if we log inside a web request (production or integration tests), we should add the request identifier to the message being logged. This is a perfect example of where we can apply the Decorator Pattern . This allows us to add new functionality to a service without touching the original implementation. Did I hear \"open-closed principle\", anyone? public class RequestLogDecorator : ILog { private readonly ILog log; private readonly Func<RequestContext> getRequestContext; public RequestLogDecorator(ILog log, Func<RequestContext> getRequestContext) { this.log = log; this.getRequestInfo = getRequestInfo; } public void Info(string message) { log.Info($\"Request id: {getRequestContext().Id} {message}\"); } public void Debug(string message) { log.Debug($\"Request id: {getRequestContext().Id} {message}\"); } public void Error(string message, Exception exception = null) { log.Error($\"Request id: {getRequestContext().Id} {message}\", exception); } } The decorator simply wraps the original ILog instance and applies the request identifier now returned from the getRequestContext delegate. Don't you just love the new string interpolation features? Note: If you are new to the decorator pattern, you can think of it as a Russian Doll where inside there is an exact identical doll wrapped by an outer doll. Decorators are first-class citizens in LightInject and applying a decorator is just a one-liner in the WepApiCompositionRoot class. serviceRegistry.Decorate<ILog, RequestLogDecorator>(); Since we only apply the decorator in the WepApiCompositionRoot class it will only be used in the context of a web request. To \"ensure\" that we don't always log on the same thread, we modify the PingController to inlude a delay. public async Task<IHttpActionResult> Get() { log.Info(\"Ping start\"); //ConfigureAwait(false) to say that we don't care about synchronization context. await Task.Delay(100).ConfigureAwait(false); // We are probably on another thread here var result = Ok(\"Pong\"); log.Info(\"Ping end\"); return result; } Running the application and hitting the service should now yield the following output in the console 2016-02-11 20:40:30.994 [INFO] 12 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping start 2016-02-11 20:40:31.111 [INFO] 6 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping end 2016-02-11 20:40:31.205 [INFO] 6 WebApiRequestLogging.RequestLogDecorator: Request id: 91444099-72ad-488f-99d6-ab201f20531e Request /api/ping took 463 ms As we can see that even if we started and ended the request on two different threads, we still have the same request identifier. Happy logging!!","title":"Web Api Request Logging"},{"location":"webapirequestlogging/#web-api-request-logging","text":"This post is going to show you how to use LightInject to enable logging in a Web Api application. We are going to look into how to preserve contextual information associated with the incoming request so that this information can be used for logging purposes. All this goodness is going to end up in a simple console application that shows how all the pieces fit together.","title":"Web Api Request Logging"},{"location":"webapirequestlogging/#logging","text":"Since logging is a cross cutting concern and is to be found scattered all around in our application, it makes sense to create an abstraction so that we don't create a direct dependency on a particular logging framework. This abstraction is something that we should own rather than relying on third part abstraction such as Common Logging . Believe me, that is going to cause us nothing but pain as we would have to deal with different versions of a third party abstraction. Own you own abstraction! We start of with a simple interface that is going to be used for logging. public interface ILog { void Info(string message); void Debug(string message); void Error(string message, Exception exception = null); } This is the interface that we will be injection into controllers, services or any other class that requires logging. The actual implementation of this interface looks like this public class Log : ILog { private readonly Action<string> logDebug; private readonly Action<string, Exception> logError; private readonly Action<string> logInfo; public Log(Action<string> logInfo, Action<string> logDebug, Action<string, Exception> logError) { this.logInfo = logInfo; this.logDebug = logDebug; this.logError = logError; } public void Info(string message) { logInfo(message); } public void Debug(string message) { logDebug(message); } public void Error(string message, Exception exception = null) { logError(message, exception); } } The Log class is not tied to a specific logging framework and it just takes a set of action delegates that represents the three logging levels supported by our abstraction. To help us create a Log instance, we have this nice little interface. public interface ILogFactory { ILog GetLogger(Type type); } And since we are going to be using Log4Net in this sample application, we have an implementation called Log4NetLogFactory . public class Log4NetLogFactory : ILogFactory { public Log4NetLogFactory() { XmlConfigurator.Configure(); } public ILog GetLogger(Type type) { var logger = LogManager.GetLogger(type); return new Log(logger.Info, logger.Debug, logger.Error); } } Note: This is the ONLY place where we actually reference Log4Net.","title":"Logging"},{"location":"webapirequestlogging/#composition-root","text":"This application has two composition roots ( ICompositionRoot ), one that registers the core services ( CompositionRoot )and one that registers services related to Web Api ( WebApiCompositionRoot ). public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register<ILogFactory, Log4NetLogFactory>(new PerContainerLifetime()); serviceRegistry.Register<Type, ILog>((factory, type) => factory.GetInstance<ILogFactory>().GetLogger(type)); serviceRegistry.RegisterConstructorDependency( (factory, info) => factory.GetInstance<Type, ILog>(info.Member.DeclaringType)); } } The first service that we register is the ILogFactory that is responsible for creating an ILog instance based on a given type. Next, we register the ILog service with a factory delegate that calls into the already registered ILogFactory service Finally we tell the container using the RegisterConstructorDependency method that whenever it sees an ILog constructor dependency, it should provide an ILog instance based on the actual class that uses it. public class WebApiCompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.RegisterFrom<CompositionRoot>(); serviceRegistry.RegisterApiControllers(); } } The WebApiCompositionRoot registers core services in addition services related to Web Api which in this case means the controllers.","title":"Composition root"},{"location":"webapirequestlogging/#controllers","text":"This application has just one controller named PingController that is simply going to return the text \"pong\". public class PingController : ApiController { private readonly ILog log; public PingController(ILog log) { this.log = log; } public async Task<IHttpActionResult> Get() { log.Info(\"Ping start\"); var result = Ok(\"Pong\"); log.Info(\"Ping end\"); return result; } } As we can see we are injecting an ILog instance into the controller. The Startup class for this application looks like this public class Startup { public void Configuration(IAppBuilder app) { var configuration = new HttpConfiguration(); ConfigureHttpRoutes(configuration); ConfigureMediaFormatter(configuration); var container = new ServiceContainer(); container.RegisterFrom<WebApiCompositionRoot>(); container.EnableWebApi(configuration); app.UseWebApi(configuration); } private static void ConfigureMediaFormatter(HttpConfiguration configuration) { configuration.Formatters.Clear(); configuration.Formatters.Add(new JsonMediaTypeFormatter()); } private static void ConfigureHttpRoutes(HttpConfiguration config) { config.Routes.MapHttpRoute( name: \"API Default\", routeTemplate: \"api/{controller}/{id}\", defaults: new { id = RouteParameter.Optional }); } } We can see all this in action just by running the application and hitting the service. http://localhost:8080/api/ping That should yield the following output in the console 2016-02-11 09:14:28.489 [INFO] 13 WebApiRequestLogging.PingController: Ping start 2016-02-11 09:14:28.603 [INFO] 6 WebApiRequestLogging.PingController: Ping end The Log4Net conversion pattern is like this (app.config) <conversionPattern value=\"%date{yyyy-MM-dd HH:mm:ss.fff} [%level] %thread %logger: %message%newline\" />","title":"Controllers"},{"location":"webapirequestlogging/#request-logging","text":"Sometimes it might be useful to log each request and maybe also the duration of the request. We start off with a simple class ( OwinMiddleware ) that logs the duration of the request. public class RequestLoggingMiddleware : OwinMiddleware { private readonly ILog log; public RequestLoggingMiddleware(OwinMiddleware next, ILog log) : base(next) { this.log = log; } public override async Task Invoke(IOwinContext context) { await Measure(context).ConfigureAwait(false);; } private async Task Measure(IOwinContext context) { var stopWath = Stopwatch.StartNew(); await Next.Invoke(context).ConfigureAwait(false); stopWath.Stop(); log.Info($\"Request {context.Request.Uri.PathAndQuery} took {stopWath.ElapsedMilliseconds} ms\"); } } In addition to this we need to add this new middleware to the Owin pipeline by adding this line to the Startup class. app.Use<RequestLoggingMiddleware>(container.GetInstance<Type, ILog>(typeof (RequestLogDecorator))); Note: The reason for using an OwinMiddleware instead of a DelegatingHandler is that the OwinMiddleware is not tied to Web Api in any way and can also be used in other frameworks that build upon the Owin stack. Console output should now be 2016-02-11 13:07:48.466 [INFO] 11 WebApiRequestLogging.RequestLoggingMiddleware: Request /api/ping took 4 ms","title":"Request logging"},{"location":"webapirequestlogging/#request-context","text":"In some situations it is useful to be able to associate all log entries with the current web request. This can be used for analyzing the log later in tools such as Splunk making it possible to see all log entries tied to any given request. We could make the IOwinContext available in the container so that it could be injected into any class that requires information about the current request. This would however mean that these classes would have to know about the IOwinContext which might not be the best solution. So let's start off simple by creating a class to hold the request identifier. public class RequestContext { public RequestContext(string id) { Id = id; } public string Id { get; } } Next we create another middleware class to set the request identifier. public class RequestContextMiddleware : OwinMiddleware { private static readonly AsyncLocal<RequestContext> RequestContextStorage = new AsyncLocal<RequestContext>(); public RequestContextMiddleware(OwinMiddleware next) : base(next) { } public override async Task Invoke(IOwinContext context) { RequestContextStorage.Value = new RequestContext(Guid.NewGuid().ToString()); await Next.Invoke(context); } public static RequestContext CurrentRequest => RequestContextStorage.Value; } The actual RequestContext uses the AsyncLocal<T> class to ensure that the context flows across await points. The AsyncLocal<T> class is sort of the async version of ThreadLocal<T> . You should NEVER rely on any kind of storage that is tied to a specific thread in an async environment. Then we need to add the RequestContextMiddleware to the Owin pipeline. app.Use<RequestContextMiddleware>(); We now have way to access the current RequestContext through the CurrentRequest property. Sweet. The only thing missing now is to register a function delegate that represent getting the current RequestContext . serviceRegistry.Register<Func<RequestContext>>(factory => (() => RequestContextMiddleware.CurrentRequest), new PerContainerLifetime()); The reason for injection a function delegate rather than just the RequestContext is that it might be used in services such as singletons that outlives the scope of a web request. By injecting the delegate that in turn gives us the RequestContext , we can be sure that it is valid.","title":"Request Context"},{"location":"webapirequestlogging/#decorators","text":"The requirement here is that if we are logging outside the context of a web request, such as in a unit test, we should just log without the request identifier, but if we log inside a web request (production or integration tests), we should add the request identifier to the message being logged. This is a perfect example of where we can apply the Decorator Pattern . This allows us to add new functionality to a service without touching the original implementation. Did I hear \"open-closed principle\", anyone? public class RequestLogDecorator : ILog { private readonly ILog log; private readonly Func<RequestContext> getRequestContext; public RequestLogDecorator(ILog log, Func<RequestContext> getRequestContext) { this.log = log; this.getRequestInfo = getRequestInfo; } public void Info(string message) { log.Info($\"Request id: {getRequestContext().Id} {message}\"); } public void Debug(string message) { log.Debug($\"Request id: {getRequestContext().Id} {message}\"); } public void Error(string message, Exception exception = null) { log.Error($\"Request id: {getRequestContext().Id} {message}\", exception); } } The decorator simply wraps the original ILog instance and applies the request identifier now returned from the getRequestContext delegate. Don't you just love the new string interpolation features? Note: If you are new to the decorator pattern, you can think of it as a Russian Doll where inside there is an exact identical doll wrapped by an outer doll. Decorators are first-class citizens in LightInject and applying a decorator is just a one-liner in the WepApiCompositionRoot class. serviceRegistry.Decorate<ILog, RequestLogDecorator>(); Since we only apply the decorator in the WepApiCompositionRoot class it will only be used in the context of a web request. To \"ensure\" that we don't always log on the same thread, we modify the PingController to inlude a delay. public async Task<IHttpActionResult> Get() { log.Info(\"Ping start\"); //ConfigureAwait(false) to say that we don't care about synchronization context. await Task.Delay(100).ConfigureAwait(false); // We are probably on another thread here var result = Ok(\"Pong\"); log.Info(\"Ping end\"); return result; } Running the application and hitting the service should now yield the following output in the console 2016-02-11 20:40:30.994 [INFO] 12 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping start 2016-02-11 20:40:31.111 [INFO] 6 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping end 2016-02-11 20:40:31.205 [INFO] 6 WebApiRequestLogging.RequestLogDecorator: Request id: 91444099-72ad-488f-99d6-ab201f20531e Request /api/ping took 463 ms As we can see that even if we started and ended the request on two different threads, we still have the same request identifier. Happy logging!!","title":"Decorators"},{"location":"xunit/","text":"LightInject.xUnit \u00b6 LightInject.xUnit provides an integration that enables dependency injection in xUnit test methods. Installing \u00b6 LightInject.xUnit provides two distribution models via NuGet Binary \u00b6 PM> Install-Package LightInject.xUnit This adds a reference to the LightInject.Xunit.dll in the target project. Source \u00b6 PM> Install-Package LightInject.xUnit.Source This will install a single file, LightInject.Xunit.cs in the target project. Injecting services \u00b6 Services from LightInject are injected into methods that are decorated with the InjectData attribute. [Theory, InjectData] public void TestMethod(IFoo foo) { Assert.NotNull(foo); } Configuration \u00b6 LightInject will look for an ICompositionRoot implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root. If such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature. public static void Configure(IServiceContainer container) { container.Register<IFoo, Foo>(); } This method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed. Scoping (xUnit <= 1.9.2) \u00b6 Services registered with the PerScopeLifetime or PerRequestLifetime needs to be resolved within an active Scope to ensure that any services that implements IDisposable are properly disposed. By decorating the test method with the ScopedTheory attribute, a new Scope will be started when the test method starts and it will end when the test method ends. [ScopedTheory, InjectData] public void MethodWithScopedArgument(IFoo foo) { Assert.NotNull(foo); } Scoping (xUnit >= 2.0.0) \u00b6 Services registered with the PerScopeLifetime or PerRequestLifetime needs to be resolved within an active Scope to ensure that any services that implements IDisposable are properly disposed. By decorating the test method with the Scoped attribute, a new Scope will be started when the test method starts and it will end when the test method ends. [Theory, Scoped, InjectData] public void MethodWithScopedArgument(IFoo foo) { Assert.NotNull(foo); }","title":"xUnit"},{"location":"xunit/#lightinjectxunit","text":"LightInject.xUnit provides an integration that enables dependency injection in xUnit test methods.","title":"LightInject.xUnit"},{"location":"xunit/#installing","text":"LightInject.xUnit provides two distribution models via NuGet","title":"Installing"},{"location":"xunit/#binary","text":"PM> Install-Package LightInject.xUnit This adds a reference to the LightInject.Xunit.dll in the target project.","title":"Binary"},{"location":"xunit/#source","text":"PM> Install-Package LightInject.xUnit.Source This will install a single file, LightInject.Xunit.cs in the target project.","title":"Source"},{"location":"xunit/#injecting-services","text":"Services from LightInject are injected into methods that are decorated with the InjectData attribute. [Theory, InjectData] public void TestMethod(IFoo foo) { Assert.NotNull(foo); }","title":"Injecting services"},{"location":"xunit/#configuration","text":"LightInject will look for an ICompositionRoot implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root. If such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature. public static void Configure(IServiceContainer container) { container.Register<IFoo, Foo>(); } This method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed.","title":"Configuration"},{"location":"xunit/#scoping-xunit-192","text":"Services registered with the PerScopeLifetime or PerRequestLifetime needs to be resolved within an active Scope to ensure that any services that implements IDisposable are properly disposed. By decorating the test method with the ScopedTheory attribute, a new Scope will be started when the test method starts and it will end when the test method ends. [ScopedTheory, InjectData] public void MethodWithScopedArgument(IFoo foo) { Assert.NotNull(foo); }","title":"Scoping (xUnit &lt;= 1.9.2)"},{"location":"xunit/#scoping-xunit-200","text":"Services registered with the PerScopeLifetime or PerRequestLifetime needs to be resolved within an active Scope to ensure that any services that implements IDisposable are properly disposed. By decorating the test method with the Scoped attribute, a new Scope will be started when the test method starts and it will end when the test method ends. [Theory, Scoped, InjectData] public void MethodWithScopedArgument(IFoo foo) { Assert.NotNull(foo); }","title":"Scoping (xUnit &gt;= 2.0.0)"}]}