{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installing LightInject provides two distribution models via NuGet Binary PM Install-Package LightInject This adds a reference to the LightInject.dll in the target project. Source PM Install-Package LightInject.Source This will install a single file (LightInject.cs) into the current project. Creating a container var container = new LightInject.ServiceContainer(); The container implements IDisposable and should be disposed after usage has completed. It can also be used inside of a using statement for a constrained scope. Default services public interface IFoo {} public class Foo : IFoo {} container.Register IFoo, Foo (); var instance = container.GetInstance IFoo (); Assert.IsInstanceOfType(instance, typeof(Foo)); Named services public class Foo : IFoo {} public class AnotherFoo : IFoo {} container.Register IFoo, Foo (); container.Register IFoo, AnotherFoo (\"AnotherFoo\"); var instance = container.GetInstance IFoo (\"AnotherFoo\"); Assert.IsInstanceOfType(instance, typeof(AnotherFoo)); If only one named registration exists, LightInject is capable of resolving this as the default service. \u200b container.Register (\"AnotherFoo\"); var instance = container.GetInstance (); Assert.IsInstanceOfType(instance, typeof(AnotherFoo)); Unresolved services LightInject can resolve services that are not registered with the container using the RegisterFallback method. var container = new ServiceContainer(); container.RegisterFallback((type, s) = true, request = new Foo()); var foo = container.GetInstance IFoo (); The first argument to the RegisterFallback method makes it possible to possible to decide if the service can be \"late-resolved\". The second argument is a ServiceRequest instance that provides the requested service type and service name. IEnumerable T When we register multiple services with the same service type, LightInject is capable of resolving these services as an IEnumerable T . public class Foo : IFoo {} public class AnotherFoo : IFoo {} container.Register IFoo, Foo (); container.Register IFoo, AnotherFoo (\"AnotherFoo\"); var instances = container.GetInstance IEnumerable IFoo () Assert.AreEqual(2, instances.Count()); Alternatively using the GetAllInstances method. var instances = container.GetAllInstances IFoo (); Assert.AreEqual(2, instances.Count()); In addition, LightInject supports the following IEnumerable T sub-types. Array ICollection T IList T IReadOnlyCollection T (Net 4.5 and Windows Runtime); IReadOnlyList T (Net 4.5 and Windows Runtime) By default, LightInject will resolve all services that are compatible with the requested element type. container.Register Foo (); container.Register DerivedFoo (); var instances = container.GetAllInstances Foo (); Assert.AreEqual(2, instances.Count()); This behavior can be overridden using the EnableVariance container option. var container = new ServiceContainer(new ContainerOptions { EnableVariance = false }); container.Register Foo (); container.Register DerivedFoo (); var instances = container.GetAllInstances Foo (); Assert.AreEqual(1, instances.Count()); We can also selectively decide to apply variance only for certain IEnumerable T services. options.VarianceFilter = (enumerableType) = enumerableType.GetGenericArguments()[0] == typeof(IFoo); Ordering Sometimes the ordering of the resolved services are important and LightInject solves this by ordering services by their service name. container.Register IFoo, Foo1 ( A ); container.Register IFoo, Foo2 ( B ); container.Register IFoo, Foo3 ( C ); var instances = container.GetAllInstances IFoo ().ToArray(); Assert.IsType Foo1 (instances[0]); Assert.IsType Foo2 (instances[1]); Assert.IsType Foo3 (instances[2]); We can also register multiple implementations for a given service type using the RegisterOrdered method. var container = CreateContainer(); container.RegisterOrdered(typeof(IFoo), new[] {typeof(Foo1), typeof(Foo2), typeof(Foo3)}, type = new PerContainerLifetime()); var instances = container.GetAllInstances IFoo ().ToArray(); Assert.IsType Foo1 (instances[0]); Assert.IsType Foo2 (instances[1]); Assert.IsType Foo3 (instances[2]); The RegisterOrdered method gives each implementation a service name that can be used for ordering when resolving these services. By default the service name is formatted like 001 , 002 and so on. If we need so change this convention, we can do this by passing a format function to the RegisterOrdered method. container.RegisterOrdered(typeof(IFoo ), new[] { typeof(Foo1 ), typeof(Foo2 ), typeof(Foo3 ) }, type = new PerContainerLifetime(), i = $ A{i.ToString().PadLeft(3,'0')} ); var services = container.AvailableServices.Where(sr = sr.ServiceType == typeof(IFoo )) .OrderBy(sr = sr.ServiceName).ToArray(); Assert.Equal( A001 , services[0].ServiceName); Assert.Equal( A002 , services[1].ServiceName); Assert.Equal( A003 , services[2].ServiceName); Values Registers the value as a constant. container.RegisterInstance string (\"SomeValue\"); var value = container.GetInstance string (); Assert.AreEqual(\"SomeValue, value); Compilation LightInject uses dynamic code compilation either in the form of System.Reflection.Emit or compiled expression trees. When a service is requested from the container, the code needed for creating the service instance is generated and compiled and a delegate for that code is stored for lookup later on so that we only compile it once. These delegates are stored in an AVL tree that ensures maximal performance when looking up a delegate for a given service type. If fact, looking up these delegates is what sets the top performing containers apart. Most high performance container emits approximately the same code, but the approach to storing these delegates may differ. LightInject provides lock-free service lookup meaning that no locks are involved for getting a service instance after its initial generation and compilation. The only time LightInject actually creates a lock is when generating the code for a given service. That does however mean a potential lock contention problem when many concurrent requests asks for services for the first time. LightInject deals with this potential problem by providing an API for compilation typically used when an application starts. The following example shows how to compile all registered services. container.Compile(); One thing to be aware of is that not all services are backed by its own delegate. Consider the following service: public class Foo { public Foo(Bar bar) { Bar = bar; } } Registered and resolved like this: container.Register Foo (); container.Register Bar (); var foo = container.GetInstance Foo (); In this case we only create a delegate for resolving Foo since that is the only service that is directly requested from the container. The code for creating the Bar instance is embedded inside the code for creating the Foo instance and hence there is only one delegate created. We call Foo a root service since it is directly requested from the container. In fact lets just have a look at the IL generated for creating the Foo instance. newobj Void .ctor() // Bar newobj Void .ctor(LightInject.SampleLibrary.IBar) //Foo What happens here is that a new instance of Bar is created and pushed onto the stack and then we create the Foo instance. This is the code that the delegate for Foo points to. The reason for such a relatively detailed explanation is to illustrate that we don't always create a delegate for a given service and by simply doing a container.Compile() we might create a lot of delegates that is never actually executed. Probably no big deal as long as we don't have tens of thousands of services, but just something to be aware of. LightInject does not attempt to identify root services as that would be very difficult for various reasons. We can instead use a predicate when compiling services up front. container.Compile(sr = sr.ServiceType == typeof(Foo)); Open Generics LightInject cannot compile open generic services since the actual generic arguments are not known at \"compile\" time. We can however specify the generic arguments like this: container.Compile Foo int () LightInject will create a log entry every time a new delegate is created so that information can be used to identify root services that could be compiled up front. In addition to this, a log entry (warning) is also created when trying to compile an open generic service up front. Lifetime The default behavior in LightInject is to treat all objects as transients unless otherwise specified. container.Register IFoo,Foo (); var firstInstance = container.GetInstance IFoo (); var secondInstance = container.GetInstance IFoo (); Assert.AreNotSame(firstInstance, secondInstance); PerScopeLifetime Ensures that only one instance of a given service can exists within a scope. The container will call the Dispose method on all disposable objects created within the scope. container.Register IFoo,Foo (new PerScopeLifetime()); using(container.BeginScope()) { var firstInstance = container.GetInstance IFoo (); var secondInstance = container.GetInstance IFoo (); Assert.AreSame(firstInstance, secondInstance); } Note: An InvalidOperationException is thrown if a service registered with the PerScopeLifetime is requested outside the scope. PerContainerLifetime Ensures that only one instance of a given service can exist within the container. The container will call the Dispose method on all disposable objects when the container itself is disposed. using(container = new ServiceContainer()) { container.Register IFoo,Foo (new PerContainerLifetime()); var firstInstance = container.GetInstance IFoo (); var secondInstance = container.GetInstance IFoo (); Assert.AreSame(firstInstance, secondInstance); } PerRequestLifeTime A new instance is created for each request and the container calls Dispose when the scope ends. This lifetime is used when the conrete class implements IDisposable . container.Register IFoo,Foo (new PerRequestLifeTime()); using(container.BeginScope()) { var firstInstance = container.GetInstance IFoo (); var secondInstance = container.GetInstance IFoo (); Assert.AreNotSame(firstInstance, secondInstance); } Note: An InvalidOperationException is thrown if a service registered with the PerRequestLifeTime is requested outside the scope. Custom lifetime A custom lifetime is created by implementing the ILifetime interface internal interface ILifetime { object GetInstance(Func object instanceFactory, Scope currentScope); } The following example shows to create a custom lifetime that ensures only one instance per thread. public class PerThreadLifetime : ILifetime { ThreadLocal object instances = new ThreadLocal object (); public object GetInstance(Func object instanceFactory, Scope currentScope) { if (instances.value == null) { instances.value = instanceFactory(); } return instances.value; } } That is all it takes to create a custom lifetime, but what about disposable services? public class PerThreadLifetime : ILifetime { ThreadLocal object instances = new ThreadLocal object (); public object GetInstance(Func object instanceFactory, Scope currentScope) { if (instances.value == null) { object instance = instanceFactory(); IDisposable disposable = instance as IDisposable; if (disposable != null) { if (currentScope == null) { throw new InvalidOperationException(\"Attempt to create an disposable object without a current scope.\") } currentScope.TrackInstance(disposable); } instances.value = instance; } return instance.value; } } Important A lifetime object controls the lifetime of a single service and can never be shared for multiple service registrations. Wrong ILifetime lifetime = new PerContainerLifeTime(); container.Register IFoo,Foo (lifetime); container.Register IBar,Bar (lifetime); Right container.Register IFoo,Foo (new PerContainerLifeTime()); container.Register IBar,Bar (new PerContainerLifeTime()); A lifetime object is also shared across threads and that is something we must take into consideration when developing new lifetime implementations. Async and Await By default scopes are managed per thread which means that when the container looks for the current scope, it will look for a scope that is associated with the current thread. With the introduction of the async/await pattern chances are that the code that is requesting a service instance is running on another thread. To illustrate this lets consider an example that is going to cause an instance to be resolved on another thread. We start of by creating an interface that returns a Task IBar public interface IAsyncFoo { Task IBar GetBar(); } Next we implement this interface in such a way that the IBar instance is requested on another thread. public class AsyncFoo : IAsyncFoo { private readonly Lazy IBar lazyBar; public AsyncFoo(Lazy IBar lazyBar) { this.lazyBar = lazyBar; } public async Task IBar GetBar() { await Task.Delay(10); return lazyBar.Value; --This code is executed on another thread (continuation). } } The we register the dependency ( IBar ) with the PerScopeLifetime that is going to cause the container to ask for the current scope so that the instance can be registered with that scope. var container = new ServiceContainer(); container.Register IBar, Bar (new PerScopeLifetime()); container.Register IAsyncFoo, AsyncFoo (); using (container.BeginScope()) { var instance = container.GetInstance IAsyncFoo (); ExceptionAssert.Throws AggregateException (() = instance.GetBar().Wait()); } This will throw an exception that states the following: Attempt to create a scoped instance without a current scope. The reason that this is happening is that the current scope is associated with the thread that created it and when the continuation executes, we are essentially requesting an instance on another thread. To deal with this issue, LightInject now supports scopes across the logical CallContext . var container = new ServiceContainer(); container.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider(); container.Register IBar, Bar (new PerScopeLifetime()); container.Register IAsyncFoo, AsyncFoo (); using (container.BeginScope()) { var instance = container.GetInstance IAsyncFoo (); var bar = instance.GetBar().Result; Assert.IsInstanceOfType(bar, typeof(IBar)); } Note that the PerLogicalCallContextScopeManagerProvider is only available when running under .Net 4.5. For more information, please refer to the following article by Stephen Cleary. Dependencies Constructor Injection public interface IFoo {} public interface IBar {} public class Foo : IFoo { public Foo(IBar bar) { Bar = bar; } public IBar Bar { get; private set; } } public class Bar : IBar {} Implicit service registration Registers a service without specifying any information about how to resolve the constructor dependencies of the implementing type. container.Register IFoo, Foo (); container.Register IBar, Bar (); var foo = (Foo)container.GetInstance IFoo (); Assert.IsInstanceOfType(foo.Bar, typeof(Bar)); Note: In the case where the implementing type(Foo) has more than one constructor, LightInject will choose the constructor with the most parameters. For fine grained control of the injected constructor dependencies, we can provide a factory that makes it possible to create an instance of a given constructor dependency. container.RegisterConstructorDependency IBar ((factory, parameterInfo) = new Bar()); This tells the container to inject a new Bar instance whenever it sees an IBar constructor dependency. Explicit service registration Registers a service by providing explicit information about how to create the service instance and how to resolve the constructor dependencies. \u200b container.Register (); container.Register (factory = new Foo(factory.GetInstance )); var foo = (Foo)container.GetInstance (); Assert.IsNotNull(foo.Bar); Parameters Parameters are used when we want to supply one or more values when the service is resolved. public class Foo : IFoo { public Foo(int value) { Value = value; } public int Value { get; private set; } } container.Register int, IFoo ((arg, factory) = new Foo(arg)); var foo = (Foo)container.GetInstance int, IFoo (42); Assert.AreEqual(42,foo.Value); We can also do a combination of supplied values and dependencies. public class Foo : IFoo { public Foo(int value, IBar bar) { Value = value; } public int Value { get; private set; } public IBar Bar { get; private set; } } container.Register IBar, Bar (); container.Register int, IFoo ((factory, value) = new Foo(value, factory.GetInstance IBar ())); var foo = (Foo)container.GetInstance int, IFoo (42); Assert.AreEqual(42, foo.Value); Assert.IsNotNull(foo.Bar); Property Injection public interface IFoo {} public interface IBar {} public class Foo : IFoo { public IBar Bar { get; set; } } public class Bar : IBar {} Implicit service registration Registers the service without specifying any information about how to resolve the property dependencies. container.Register IFoo, Foo (); container.Register IBar, Bar (); var foo = (Foo)container.GetInstance IFoo (); Assert.IsNotNull(foo.bar); Note: LightInject * considers all read/write properties a dependency, but implements a loose strategy around property dependencies, meaning that it will NOT* throw an exception in the case of an unresolved property dependency. For fine grained control of the injected property dependencies, we can provide a factory that makes it possible to create an instance of a given property dependency. container.RegisterPropertyDependency IBar ((factory, propertyInfo) = new Bar()); This tells the container to inject a new Bar instance whenever it sees an IBar property dependency. Explicit service registration Registers a service by providing explicit information about how to create the service instance and how to resolve the property dependencies. container.Register IBar, Bar (); container.Register IFoo (factory = new Foo() {Bar = factory.GetInstance IBar ()}) var foo = (Foo)container.GetInstance IFoo (); Assert.IsNotNull(foo.bar); Property injection on existing instances. In the cases where we don't control the creation of the service instance, LightInject can inject property dependencies into an existing instance. container.Register IBar, Bar (); var foo = new Foo(); container.InjectProperties(foo); Assert.IsNotNull(foo); Disabling ProperyInjection Property injection is enabled by default in LightInject , but it can be disabled like this. var container = new ServiceContainer(new ContainerOptions { EnablePropertyInjection = false }); It is actually recommended to turn off property injection unless it is really needed. Backward compatibility is the only reason that this is not the default. Initializers Use the Initialize method to perform service instance initialization/post-processing. container.Register IFoo, FooWithPropertyDependency (); container.Initialize(registration = registration.ServiceType == typeof(IFoo), (factory, instance) = ((FooWithPropertyDependency)instance).Bar = new Bar()); var foo = (FooWithProperyDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(foo.Bar, typeof(Bar)); Assembly Scanning LightInject is capable of registering services by looking at the types of a given assembly. container.RegisterAssembly(typeof(IFoo).Assembly) To filter out the services to be registered with the container, we can provide a predicate that makes it possible to inspect the service type and the implementing type. container.RegisterAssembly(typeof(IFoo).Assembly, (serviceType, implementingType) = serviceType.NameSpace == SomeNamespace ); It is also possible to scan a set assembly files based on a search pattern. container.RegisterAssembly( SomeAssemblyName*.dll ); When scanning assemblies, LightInject will register services using a service name that by default is the implementing type name. This behavior can be changed by specifying a function delegate to provide the name based on the service type and the implementing type. container.RegisterAssembly(typeof(IFoo).Assembly, () = new PerContainerLifetime(), (serviceType, implementingType) = serviceType.NameSpace == SomeNamespace , (serviceType, implementingType) = Provide custom service name here ); We can also change this behavior globally for all registrations by implementing the IServiceNameProvider interface. public class CustomServiceNameProvider : IServiceNameProvider { public string GetServiceName(Type serviceType, Type implementingType) { return Provide custom service name here ; } } To change the default behavior for all registrations we simply change this dependency on the container before we start scanning assemblies. container.ServiceNameProvider = new CustomServiceNameProvider(); Composition Root When LightInject scans an assembly it will look for an implementation of the ICompositionRoot interface. public class SampleCompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register(typeof(IFoo),typeof(Foo)); } } If one or more implementations of the ICompositionRoot interface is found, they will be created and executed. Note: Any other services contained within the target assembly that is not registered in the composition root, will NOT be registered. Rather that having a single composition root that basically needs to reference all other assemblies, having multiple composition roots makes it possible to group services naturally together. Another advantage of registering services in a ICompositionRoot , is that they can easily be reused in automated tests. Lazy Composition Roots LightInject is capable of registering services on a need to have basis. For a large application that has a lot of services, it might not be the best solution to register all these services up front as this could seriously hurt the startup time of our application due to extensive assembly loading. If an unregistered service is requested, LightInject will scan the assembly where this service is contained. CompositionRootAttribute When an assembly is being scanned, LightInject will look for implementations of the ICompositionRoot interface. For large assemblies that contains many type, this might be an expensive operation. The CompositionRootAttribute is an assembly level attribute that simply helps LightInject to locate the compostion root. [assembly: CompositionRootType(typeof(SampleCompositionRoot))] RegisterFrom Allows explicit execution of a composition root. container.RegisterFrom SampleCompositionRoot (); Generics public interface IFoo T {}; public class Foo T : IFoo T {}; The container creates the closed generic type based on the service request. \u200b container.Register(typeof(IFoo ), typeof(Foo )); var instance = container.GetInstance(typeof(IFoo )); Assert.IsInstanceOfType(instance, typeof(Foo )); Constraints LightInject enforces generic constrains Lazy T LightInject can resolve a service as an instance of Lazy T when we want to postpone resolving the underlying service until it is needed. public interface IFoo {} public class Foo : IFoo {} container.Register IFoo, Foo (); var lazyFoo = container.GetInstance Lazy IFoo (); Assert.IsNotNull(lazyFoo.Value); Function Factories Function factories allows services to resolved as a function delegate that in turn is capable of returning the underlying service instance. We can think of this as an alternative to the Service Locator (anti)pattern. public interface IFoo {} public class Foo : IFoo {} container.Register IFoo,Foo (); var func = container.GetInstance Func IFoo (); var foo = func(); Assert.IsNotNull(foo); Note: A function factory is effectively a delegate that redirects back to the corresponding GetInstance method on the service container. Named Factories The container returns a function delegate that represents calling the GetInstance method with \"SomeFoo\" as the service name argument. container.Register IFoo, Foo (\"SomeFoo\"); var func = container.GetInstance Func IFoo (\"SomeFoo\"); var foo = func(); Assert.IsNotNull(foo); Parameters Function factories can also take parameters that will be used create the service instance. public class Foo : IFoo { public Foo(int value) { Value = value; } public int Value { get; private set; } } container.Register int, IFoo ((factory, value) = new Foo(value)); var fooFactory = container.GetInstance Func int, IFoo (); var foo = (Foo)fooFactory(42); Assert.AreEqual(foo.Value, 42); Note : The service must be explicitly registered in order for the container to resolve it as a parameterized function factory. IDisposable The only way to deal with disposable objects when using function factories, is to let the service type inherit from IDisposable. public interface IFoo : IDisposable {} public class Foo : IFoo {} container.Register IFoo, Foo (); var fooFactory = container.GetInstance Func IFoo (); using(IFoo foo = fooFactory()) { } --Instance is disposed here Note: Although this is common practice even in the BCL , this kind of interfaces are often referred to as leaky abstractions . Typed Factories A typed factory is a class that wraps the function factory that is used to create the underlying service instance. As opposed to just function factories, typed factories provides better expressiveness to the consumer of the factory. \u200b public interface IFooFactory { IFoo GetFoo(); } public class FooFactory : IFooFactory { private Func IFoo createFoo; public FooFactory(Func IFoo createFoo) { this.createFoo = createFoo; } public IFoo GetFoo() { return createFoo(); } } container.Register IFoo, Foo (); container.Register IFooFactory, FooFactory (new PerContainerLifetime()); var fooFactory = container.GetInstance IFooFactory (); var foo = fooFactory.GetFoo(); Assert.IsNotNull(foo); Note: Register typed factories with the PerContainerLifetime unless a compelling reason exists to choose a different lifetime. Parameters Types factories can also wrap a parameterized function factory and allows us to pass arguments. public class Foo : IFoo { public Foo(int value) { Value = value; } public int Value { get; private set; } } public interface IFooFactory { IFoo GetFoo(int value); } public class FooFactory : IFooFactory { private Func int, IFoo createFoo; public FooFactory(Func int, IFoo createFoo) { this.createFoo = createFoo; } public IFoo GetFoo(int value) { return createFoo(value); } } container.Register int, IFoo ((factory, value) = new Foo(value)); container.Register IFooFactory, FooFactory (new PerContainerLifetime()); var typedFooFactory = container.GetInstance IFooFactory (); var foo = typedFooFactory.GetFoo(42); Assert.AreEqual(foo.Value, 42); IDisposable Working with typed factories gives us the possibility to release disposable services registered as transients without exposing a leaky abstraction. public interface IFooFactory { IFoo GetFoo(int value); void Release(IFoo foo); } public class FooFactory : IFooFactory { private Func IFoo createFoo; public FooFactory(Func IFoo createFoo) { this.createFoo = createFoo; } public IFoo GetFoo(int value) { return createFoo(value); } public void Release(IFoo foo) { var disposable = foo as IDisposable; if (disposable != null) { disposable.Dispose(); } } } Recursive dependency detection A recursive dependency graph is when a service depends directly or indirectly on itself. public class FooWithRecursiveDependency : IFoo { public FooWithRecursiveDependency(IFoo foo) { } } The following code will throw an InvalidOperationException stating that there are existing recursive dependencies. container.Register(typeof(IFoo), typeof(FooWithRecursiveDependency)); container.GetInstance IFoo () Internals When running under the .Net platform, LightInject is capable of creating instances of classes that has the internal modifier. The only requirement is that the internal class exposes a public constructor. internal class InternalFooWithPublicConstructor : IFoo { public InternalFooWithPublicConstructor () {} } Logging Sometimes it might be useful to obtain information about what is going on inside the container and LightInject provides a very simple log abstraction that is used to log information and warnings from within the container. var containerOptions = new ContainerOptions(); containerOptions.LogFactory = (type) = logEntry = Console.WriteLine(logEntry.Message);","title":"Home"},{"location":"#installing","text":"LightInject provides two distribution models via NuGet","title":"Installing"},{"location":"#binary","text":"PM Install-Package LightInject This adds a reference to the LightInject.dll in the target project.","title":"Binary"},{"location":"#source","text":"PM Install-Package LightInject.Source This will install a single file (LightInject.cs) into the current project.","title":"Source"},{"location":"#creating-a-container","text":"var container = new LightInject.ServiceContainer(); The container implements IDisposable and should be disposed after usage has completed. It can also be used inside of a using statement for a constrained scope.","title":"Creating a container"},{"location":"#default-services","text":"public interface IFoo {} public class Foo : IFoo {} container.Register IFoo, Foo (); var instance = container.GetInstance IFoo (); Assert.IsInstanceOfType(instance, typeof(Foo));","title":"Default services"},{"location":"#named-services","text":"public class Foo : IFoo {} public class AnotherFoo : IFoo {} container.Register IFoo, Foo (); container.Register IFoo, AnotherFoo (\"AnotherFoo\"); var instance = container.GetInstance IFoo (\"AnotherFoo\"); Assert.IsInstanceOfType(instance, typeof(AnotherFoo)); If only one named registration exists, LightInject is capable of resolving this as the default service. \u200b container.Register (\"AnotherFoo\"); var instance = container.GetInstance (); Assert.IsInstanceOfType(instance, typeof(AnotherFoo));","title":"Named services"},{"location":"#unresolved-services","text":"LightInject can resolve services that are not registered with the container using the RegisterFallback method. var container = new ServiceContainer(); container.RegisterFallback((type, s) = true, request = new Foo()); var foo = container.GetInstance IFoo (); The first argument to the RegisterFallback method makes it possible to possible to decide if the service can be \"late-resolved\". The second argument is a ServiceRequest instance that provides the requested service type and service name.","title":"Unresolved services"},{"location":"#ienumerablet","text":"When we register multiple services with the same service type, LightInject is capable of resolving these services as an IEnumerable T . public class Foo : IFoo {} public class AnotherFoo : IFoo {} container.Register IFoo, Foo (); container.Register IFoo, AnotherFoo (\"AnotherFoo\"); var instances = container.GetInstance IEnumerable IFoo () Assert.AreEqual(2, instances.Count()); Alternatively using the GetAllInstances method. var instances = container.GetAllInstances IFoo (); Assert.AreEqual(2, instances.Count()); In addition, LightInject supports the following IEnumerable T sub-types. Array ICollection T IList T IReadOnlyCollection T (Net 4.5 and Windows Runtime); IReadOnlyList T (Net 4.5 and Windows Runtime) By default, LightInject will resolve all services that are compatible with the requested element type. container.Register Foo (); container.Register DerivedFoo (); var instances = container.GetAllInstances Foo (); Assert.AreEqual(2, instances.Count()); This behavior can be overridden using the EnableVariance container option. var container = new ServiceContainer(new ContainerOptions { EnableVariance = false }); container.Register Foo (); container.Register DerivedFoo (); var instances = container.GetAllInstances Foo (); Assert.AreEqual(1, instances.Count()); We can also selectively decide to apply variance only for certain IEnumerable T services. options.VarianceFilter = (enumerableType) = enumerableType.GetGenericArguments()[0] == typeof(IFoo);","title":"IEnumerable&lt;T&gt;"},{"location":"#ordering","text":"Sometimes the ordering of the resolved services are important and LightInject solves this by ordering services by their service name. container.Register IFoo, Foo1 ( A ); container.Register IFoo, Foo2 ( B ); container.Register IFoo, Foo3 ( C ); var instances = container.GetAllInstances IFoo ().ToArray(); Assert.IsType Foo1 (instances[0]); Assert.IsType Foo2 (instances[1]); Assert.IsType Foo3 (instances[2]); We can also register multiple implementations for a given service type using the RegisterOrdered method. var container = CreateContainer(); container.RegisterOrdered(typeof(IFoo), new[] {typeof(Foo1), typeof(Foo2), typeof(Foo3)}, type = new PerContainerLifetime()); var instances = container.GetAllInstances IFoo ().ToArray(); Assert.IsType Foo1 (instances[0]); Assert.IsType Foo2 (instances[1]); Assert.IsType Foo3 (instances[2]); The RegisterOrdered method gives each implementation a service name that can be used for ordering when resolving these services. By default the service name is formatted like 001 , 002 and so on. If we need so change this convention, we can do this by passing a format function to the RegisterOrdered method. container.RegisterOrdered(typeof(IFoo ), new[] { typeof(Foo1 ), typeof(Foo2 ), typeof(Foo3 ) }, type = new PerContainerLifetime(), i = $ A{i.ToString().PadLeft(3,'0')} ); var services = container.AvailableServices.Where(sr = sr.ServiceType == typeof(IFoo )) .OrderBy(sr = sr.ServiceName).ToArray(); Assert.Equal( A001 , services[0].ServiceName); Assert.Equal( A002 , services[1].ServiceName); Assert.Equal( A003 , services[2].ServiceName);","title":"Ordering"},{"location":"#values","text":"Registers the value as a constant. container.RegisterInstance string (\"SomeValue\"); var value = container.GetInstance string (); Assert.AreEqual(\"SomeValue, value);","title":"Values"},{"location":"#compilation","text":"LightInject uses dynamic code compilation either in the form of System.Reflection.Emit or compiled expression trees. When a service is requested from the container, the code needed for creating the service instance is generated and compiled and a delegate for that code is stored for lookup later on so that we only compile it once. These delegates are stored in an AVL tree that ensures maximal performance when looking up a delegate for a given service type. If fact, looking up these delegates is what sets the top performing containers apart. Most high performance container emits approximately the same code, but the approach to storing these delegates may differ. LightInject provides lock-free service lookup meaning that no locks are involved for getting a service instance after its initial generation and compilation. The only time LightInject actually creates a lock is when generating the code for a given service. That does however mean a potential lock contention problem when many concurrent requests asks for services for the first time. LightInject deals with this potential problem by providing an API for compilation typically used when an application starts. The following example shows how to compile all registered services. container.Compile(); One thing to be aware of is that not all services are backed by its own delegate. Consider the following service: public class Foo { public Foo(Bar bar) { Bar = bar; } } Registered and resolved like this: container.Register Foo (); container.Register Bar (); var foo = container.GetInstance Foo (); In this case we only create a delegate for resolving Foo since that is the only service that is directly requested from the container. The code for creating the Bar instance is embedded inside the code for creating the Foo instance and hence there is only one delegate created. We call Foo a root service since it is directly requested from the container. In fact lets just have a look at the IL generated for creating the Foo instance. newobj Void .ctor() // Bar newobj Void .ctor(LightInject.SampleLibrary.IBar) //Foo What happens here is that a new instance of Bar is created and pushed onto the stack and then we create the Foo instance. This is the code that the delegate for Foo points to. The reason for such a relatively detailed explanation is to illustrate that we don't always create a delegate for a given service and by simply doing a container.Compile() we might create a lot of delegates that is never actually executed. Probably no big deal as long as we don't have tens of thousands of services, but just something to be aware of. LightInject does not attempt to identify root services as that would be very difficult for various reasons. We can instead use a predicate when compiling services up front. container.Compile(sr = sr.ServiceType == typeof(Foo));","title":"Compilation"},{"location":"#open-generics","text":"LightInject cannot compile open generic services since the actual generic arguments are not known at \"compile\" time. We can however specify the generic arguments like this: container.Compile Foo int () LightInject will create a log entry every time a new delegate is created so that information can be used to identify root services that could be compiled up front. In addition to this, a log entry (warning) is also created when trying to compile an open generic service up front.","title":"Open Generics"},{"location":"#lifetime","text":"The default behavior in LightInject is to treat all objects as transients unless otherwise specified. container.Register IFoo,Foo (); var firstInstance = container.GetInstance IFoo (); var secondInstance = container.GetInstance IFoo (); Assert.AreNotSame(firstInstance, secondInstance);","title":"Lifetime"},{"location":"#perscopelifetime","text":"Ensures that only one instance of a given service can exists within a scope. The container will call the Dispose method on all disposable objects created within the scope. container.Register IFoo,Foo (new PerScopeLifetime()); using(container.BeginScope()) { var firstInstance = container.GetInstance IFoo (); var secondInstance = container.GetInstance IFoo (); Assert.AreSame(firstInstance, secondInstance); } Note: An InvalidOperationException is thrown if a service registered with the PerScopeLifetime is requested outside the scope.","title":"PerScopeLifetime"},{"location":"#percontainerlifetime","text":"Ensures that only one instance of a given service can exist within the container. The container will call the Dispose method on all disposable objects when the container itself is disposed. using(container = new ServiceContainer()) { container.Register IFoo,Foo (new PerContainerLifetime()); var firstInstance = container.GetInstance IFoo (); var secondInstance = container.GetInstance IFoo (); Assert.AreSame(firstInstance, secondInstance); }","title":"PerContainerLifetime"},{"location":"#perrequestlifetime","text":"A new instance is created for each request and the container calls Dispose when the scope ends. This lifetime is used when the conrete class implements IDisposable . container.Register IFoo,Foo (new PerRequestLifeTime()); using(container.BeginScope()) { var firstInstance = container.GetInstance IFoo (); var secondInstance = container.GetInstance IFoo (); Assert.AreNotSame(firstInstance, secondInstance); } Note: An InvalidOperationException is thrown if a service registered with the PerRequestLifeTime is requested outside the scope.","title":"PerRequestLifeTime"},{"location":"#custom-lifetime","text":"A custom lifetime is created by implementing the ILifetime interface internal interface ILifetime { object GetInstance(Func object instanceFactory, Scope currentScope); } The following example shows to create a custom lifetime that ensures only one instance per thread. public class PerThreadLifetime : ILifetime { ThreadLocal object instances = new ThreadLocal object (); public object GetInstance(Func object instanceFactory, Scope currentScope) { if (instances.value == null) { instances.value = instanceFactory(); } return instances.value; } } That is all it takes to create a custom lifetime, but what about disposable services? public class PerThreadLifetime : ILifetime { ThreadLocal object instances = new ThreadLocal object (); public object GetInstance(Func object instanceFactory, Scope currentScope) { if (instances.value == null) { object instance = instanceFactory(); IDisposable disposable = instance as IDisposable; if (disposable != null) { if (currentScope == null) { throw new InvalidOperationException(\"Attempt to create an disposable object without a current scope.\") } currentScope.TrackInstance(disposable); } instances.value = instance; } return instance.value; } }","title":"Custom lifetime"},{"location":"#important","text":"A lifetime object controls the lifetime of a single service and can never be shared for multiple service registrations. Wrong ILifetime lifetime = new PerContainerLifeTime(); container.Register IFoo,Foo (lifetime); container.Register IBar,Bar (lifetime); Right container.Register IFoo,Foo (new PerContainerLifeTime()); container.Register IBar,Bar (new PerContainerLifeTime()); A lifetime object is also shared across threads and that is something we must take into consideration when developing new lifetime implementations.","title":"Important"},{"location":"#async-and-await","text":"By default scopes are managed per thread which means that when the container looks for the current scope, it will look for a scope that is associated with the current thread. With the introduction of the async/await pattern chances are that the code that is requesting a service instance is running on another thread. To illustrate this lets consider an example that is going to cause an instance to be resolved on another thread. We start of by creating an interface that returns a Task IBar public interface IAsyncFoo { Task IBar GetBar(); } Next we implement this interface in such a way that the IBar instance is requested on another thread. public class AsyncFoo : IAsyncFoo { private readonly Lazy IBar lazyBar; public AsyncFoo(Lazy IBar lazyBar) { this.lazyBar = lazyBar; } public async Task IBar GetBar() { await Task.Delay(10); return lazyBar.Value; --This code is executed on another thread (continuation). } } The we register the dependency ( IBar ) with the PerScopeLifetime that is going to cause the container to ask for the current scope so that the instance can be registered with that scope. var container = new ServiceContainer(); container.Register IBar, Bar (new PerScopeLifetime()); container.Register IAsyncFoo, AsyncFoo (); using (container.BeginScope()) { var instance = container.GetInstance IAsyncFoo (); ExceptionAssert.Throws AggregateException (() = instance.GetBar().Wait()); } This will throw an exception that states the following: Attempt to create a scoped instance without a current scope. The reason that this is happening is that the current scope is associated with the thread that created it and when the continuation executes, we are essentially requesting an instance on another thread. To deal with this issue, LightInject now supports scopes across the logical CallContext . var container = new ServiceContainer(); container.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider(); container.Register IBar, Bar (new PerScopeLifetime()); container.Register IAsyncFoo, AsyncFoo (); using (container.BeginScope()) { var instance = container.GetInstance IAsyncFoo (); var bar = instance.GetBar().Result; Assert.IsInstanceOfType(bar, typeof(IBar)); } Note that the PerLogicalCallContextScopeManagerProvider is only available when running under .Net 4.5. For more information, please refer to the following article by Stephen Cleary.","title":"Async and Await"},{"location":"#dependencies","text":"","title":"Dependencies"},{"location":"#constructor-injection","text":"public interface IFoo {} public interface IBar {} public class Foo : IFoo { public Foo(IBar bar) { Bar = bar; } public IBar Bar { get; private set; } } public class Bar : IBar {}","title":"Constructor Injection"},{"location":"#implicit-service-registration","text":"Registers a service without specifying any information about how to resolve the constructor dependencies of the implementing type. container.Register IFoo, Foo (); container.Register IBar, Bar (); var foo = (Foo)container.GetInstance IFoo (); Assert.IsInstanceOfType(foo.Bar, typeof(Bar)); Note: In the case where the implementing type(Foo) has more than one constructor, LightInject will choose the constructor with the most parameters. For fine grained control of the injected constructor dependencies, we can provide a factory that makes it possible to create an instance of a given constructor dependency. container.RegisterConstructorDependency IBar ((factory, parameterInfo) = new Bar()); This tells the container to inject a new Bar instance whenever it sees an IBar constructor dependency.","title":"Implicit service registration"},{"location":"#explicit-service-registration","text":"Registers a service by providing explicit information about how to create the service instance and how to resolve the constructor dependencies. \u200b container.Register (); container.Register (factory = new Foo(factory.GetInstance )); var foo = (Foo)container.GetInstance (); Assert.IsNotNull(foo.Bar);","title":"Explicit service registration"},{"location":"#parameters","text":"Parameters are used when we want to supply one or more values when the service is resolved. public class Foo : IFoo { public Foo(int value) { Value = value; } public int Value { get; private set; } } container.Register int, IFoo ((arg, factory) = new Foo(arg)); var foo = (Foo)container.GetInstance int, IFoo (42); Assert.AreEqual(42,foo.Value); We can also do a combination of supplied values and dependencies. public class Foo : IFoo { public Foo(int value, IBar bar) { Value = value; } public int Value { get; private set; } public IBar Bar { get; private set; } } container.Register IBar, Bar (); container.Register int, IFoo ((factory, value) = new Foo(value, factory.GetInstance IBar ())); var foo = (Foo)container.GetInstance int, IFoo (42); Assert.AreEqual(42, foo.Value); Assert.IsNotNull(foo.Bar);","title":"Parameters"},{"location":"#property-injection","text":"public interface IFoo {} public interface IBar {} public class Foo : IFoo { public IBar Bar { get; set; } } public class Bar : IBar {}","title":"Property Injection"},{"location":"#implicit-service-registration_1","text":"Registers the service without specifying any information about how to resolve the property dependencies. container.Register IFoo, Foo (); container.Register IBar, Bar (); var foo = (Foo)container.GetInstance IFoo (); Assert.IsNotNull(foo.bar); Note: LightInject * considers all read/write properties a dependency, but implements a loose strategy around property dependencies, meaning that it will NOT* throw an exception in the case of an unresolved property dependency. For fine grained control of the injected property dependencies, we can provide a factory that makes it possible to create an instance of a given property dependency. container.RegisterPropertyDependency IBar ((factory, propertyInfo) = new Bar()); This tells the container to inject a new Bar instance whenever it sees an IBar property dependency.","title":"Implicit service registration"},{"location":"#explicit-service-registration_1","text":"Registers a service by providing explicit information about how to create the service instance and how to resolve the property dependencies. container.Register IBar, Bar (); container.Register IFoo (factory = new Foo() {Bar = factory.GetInstance IBar ()}) var foo = (Foo)container.GetInstance IFoo (); Assert.IsNotNull(foo.bar);","title":"Explicit service registration"},{"location":"#property-injection-on-existing-instances","text":"In the cases where we don't control the creation of the service instance, LightInject can inject property dependencies into an existing instance. container.Register IBar, Bar (); var foo = new Foo(); container.InjectProperties(foo); Assert.IsNotNull(foo);","title":"Property injection on existing instances."},{"location":"#disabling-properyinjection","text":"Property injection is enabled by default in LightInject , but it can be disabled like this. var container = new ServiceContainer(new ContainerOptions { EnablePropertyInjection = false }); It is actually recommended to turn off property injection unless it is really needed. Backward compatibility is the only reason that this is not the default.","title":"Disabling ProperyInjection"},{"location":"#initializers","text":"Use the Initialize method to perform service instance initialization/post-processing. container.Register IFoo, FooWithPropertyDependency (); container.Initialize(registration = registration.ServiceType == typeof(IFoo), (factory, instance) = ((FooWithPropertyDependency)instance).Bar = new Bar()); var foo = (FooWithProperyDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(foo.Bar, typeof(Bar));","title":"Initializers"},{"location":"#assembly-scanning","text":"LightInject is capable of registering services by looking at the types of a given assembly. container.RegisterAssembly(typeof(IFoo).Assembly) To filter out the services to be registered with the container, we can provide a predicate that makes it possible to inspect the service type and the implementing type. container.RegisterAssembly(typeof(IFoo).Assembly, (serviceType, implementingType) = serviceType.NameSpace == SomeNamespace ); It is also possible to scan a set assembly files based on a search pattern. container.RegisterAssembly( SomeAssemblyName*.dll ); When scanning assemblies, LightInject will register services using a service name that by default is the implementing type name. This behavior can be changed by specifying a function delegate to provide the name based on the service type and the implementing type. container.RegisterAssembly(typeof(IFoo).Assembly, () = new PerContainerLifetime(), (serviceType, implementingType) = serviceType.NameSpace == SomeNamespace , (serviceType, implementingType) = Provide custom service name here ); We can also change this behavior globally for all registrations by implementing the IServiceNameProvider interface. public class CustomServiceNameProvider : IServiceNameProvider { public string GetServiceName(Type serviceType, Type implementingType) { return Provide custom service name here ; } } To change the default behavior for all registrations we simply change this dependency on the container before we start scanning assemblies. container.ServiceNameProvider = new CustomServiceNameProvider();","title":"Assembly Scanning"},{"location":"#composition-root","text":"When LightInject scans an assembly it will look for an implementation of the ICompositionRoot interface. public class SampleCompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register(typeof(IFoo),typeof(Foo)); } } If one or more implementations of the ICompositionRoot interface is found, they will be created and executed. Note: Any other services contained within the target assembly that is not registered in the composition root, will NOT be registered. Rather that having a single composition root that basically needs to reference all other assemblies, having multiple composition roots makes it possible to group services naturally together. Another advantage of registering services in a ICompositionRoot , is that they can easily be reused in automated tests.","title":"Composition Root"},{"location":"#lazy-composition-roots","text":"LightInject is capable of registering services on a need to have basis. For a large application that has a lot of services, it might not be the best solution to register all these services up front as this could seriously hurt the startup time of our application due to extensive assembly loading. If an unregistered service is requested, LightInject will scan the assembly where this service is contained.","title":"Lazy Composition Roots"},{"location":"#compositionrootattribute","text":"When an assembly is being scanned, LightInject will look for implementations of the ICompositionRoot interface. For large assemblies that contains many type, this might be an expensive operation. The CompositionRootAttribute is an assembly level attribute that simply helps LightInject to locate the compostion root. [assembly: CompositionRootType(typeof(SampleCompositionRoot))]","title":"CompositionRootAttribute"},{"location":"#registerfrom","text":"Allows explicit execution of a composition root. container.RegisterFrom SampleCompositionRoot ();","title":"RegisterFrom"},{"location":"#generics","text":"public interface IFoo T {}; public class Foo T : IFoo T {}; The container creates the closed generic type based on the service request. \u200b container.Register(typeof(IFoo ), typeof(Foo )); var instance = container.GetInstance(typeof(IFoo )); Assert.IsInstanceOfType(instance, typeof(Foo ));","title":"Generics"},{"location":"#constraints","text":"LightInject enforces generic constrains","title":"Constraints"},{"location":"#lazyt","text":"LightInject can resolve a service as an instance of Lazy T when we want to postpone resolving the underlying service until it is needed. public interface IFoo {} public class Foo : IFoo {} container.Register IFoo, Foo (); var lazyFoo = container.GetInstance Lazy IFoo (); Assert.IsNotNull(lazyFoo.Value);","title":"Lazy&lt;T&gt;"},{"location":"#function-factories","text":"Function factories allows services to resolved as a function delegate that in turn is capable of returning the underlying service instance. We can think of this as an alternative to the Service Locator (anti)pattern. public interface IFoo {} public class Foo : IFoo {} container.Register IFoo,Foo (); var func = container.GetInstance Func IFoo (); var foo = func(); Assert.IsNotNull(foo); Note: A function factory is effectively a delegate that redirects back to the corresponding GetInstance method on the service container.","title":"Function Factories"},{"location":"#named-factories","text":"The container returns a function delegate that represents calling the GetInstance method with \"SomeFoo\" as the service name argument. container.Register IFoo, Foo (\"SomeFoo\"); var func = container.GetInstance Func IFoo (\"SomeFoo\"); var foo = func(); Assert.IsNotNull(foo);","title":"Named Factories"},{"location":"#parameters_1","text":"Function factories can also take parameters that will be used create the service instance. public class Foo : IFoo { public Foo(int value) { Value = value; } public int Value { get; private set; } } container.Register int, IFoo ((factory, value) = new Foo(value)); var fooFactory = container.GetInstance Func int, IFoo (); var foo = (Foo)fooFactory(42); Assert.AreEqual(foo.Value, 42); Note : The service must be explicitly registered in order for the container to resolve it as a parameterized function factory.","title":"Parameters"},{"location":"#idisposable","text":"The only way to deal with disposable objects when using function factories, is to let the service type inherit from IDisposable. public interface IFoo : IDisposable {} public class Foo : IFoo {} container.Register IFoo, Foo (); var fooFactory = container.GetInstance Func IFoo (); using(IFoo foo = fooFactory()) { } --Instance is disposed here Note: Although this is common practice even in the BCL , this kind of interfaces are often referred to as leaky abstractions .","title":"IDisposable"},{"location":"#typed-factories","text":"A typed factory is a class that wraps the function factory that is used to create the underlying service instance. As opposed to just function factories, typed factories provides better expressiveness to the consumer of the factory. \u200b public interface IFooFactory { IFoo GetFoo(); } public class FooFactory : IFooFactory { private Func IFoo createFoo; public FooFactory(Func IFoo createFoo) { this.createFoo = createFoo; } public IFoo GetFoo() { return createFoo(); } } container.Register IFoo, Foo (); container.Register IFooFactory, FooFactory (new PerContainerLifetime()); var fooFactory = container.GetInstance IFooFactory (); var foo = fooFactory.GetFoo(); Assert.IsNotNull(foo); Note: Register typed factories with the PerContainerLifetime unless a compelling reason exists to choose a different lifetime.","title":"Typed Factories"},{"location":"#parameters_2","text":"Types factories can also wrap a parameterized function factory and allows us to pass arguments. public class Foo : IFoo { public Foo(int value) { Value = value; } public int Value { get; private set; } } public interface IFooFactory { IFoo GetFoo(int value); } public class FooFactory : IFooFactory { private Func int, IFoo createFoo; public FooFactory(Func int, IFoo createFoo) { this.createFoo = createFoo; } public IFoo GetFoo(int value) { return createFoo(value); } } container.Register int, IFoo ((factory, value) = new Foo(value)); container.Register IFooFactory, FooFactory (new PerContainerLifetime()); var typedFooFactory = container.GetInstance IFooFactory (); var foo = typedFooFactory.GetFoo(42); Assert.AreEqual(foo.Value, 42);","title":"Parameters"},{"location":"#idisposable_1","text":"Working with typed factories gives us the possibility to release disposable services registered as transients without exposing a leaky abstraction. public interface IFooFactory { IFoo GetFoo(int value); void Release(IFoo foo); } public class FooFactory : IFooFactory { private Func IFoo createFoo; public FooFactory(Func IFoo createFoo) { this.createFoo = createFoo; } public IFoo GetFoo(int value) { return createFoo(value); } public void Release(IFoo foo) { var disposable = foo as IDisposable; if (disposable != null) { disposable.Dispose(); } } }","title":"IDisposable"},{"location":"#recursive-dependency-detection","text":"A recursive dependency graph is when a service depends directly or indirectly on itself. public class FooWithRecursiveDependency : IFoo { public FooWithRecursiveDependency(IFoo foo) { } } The following code will throw an InvalidOperationException stating that there are existing recursive dependencies. container.Register(typeof(IFoo), typeof(FooWithRecursiveDependency)); container.GetInstance IFoo ()","title":"Recursive dependency detection"},{"location":"#internals","text":"When running under the .Net platform, LightInject is capable of creating instances of classes that has the internal modifier. The only requirement is that the internal class exposes a public constructor. internal class InternalFooWithPublicConstructor : IFoo { public InternalFooWithPublicConstructor () {} }","title":"Internals"},{"location":"#logging","text":"Sometimes it might be useful to obtain information about what is going on inside the container and LightInject provides a very simple log abstraction that is used to log information and warnings from within the container. var containerOptions = new ContainerOptions(); containerOptions.LogFactory = (type) = logEntry = Console.WriteLine(logEntry.Message);","title":"Logging"},{"location":"annotation/","text":"Annotation LightInject supports annotation of properties and constructor parameters through an extension LightInject. PM Install-Package LightInject.Annotation By using the InjectAttribute we can be more explicit about the services that gets injected into properties and constructor dependencies. Note: As opposed to all other types within LightInject , the InjectAttribute is marked with the public access modifier so that is can be used outside the assembly that contains the service container. This creates a dependency from our services to the assembly containing the attribute, but we still don't need to reference any of the specific types in LightInject making this an affordable sacrifice when it comes to services referencing container specific types. Property Injection To enable annotated property injection, we must execute the following line before we start requesting services from the container. container.EnableAnnotatedPropertyInjection(); The container now only try to inject dependencies for properties that is annotated with the InjectAttribute . The container will throw an InvalidOperationException if the annotated property dependency is unable to be resolved. public class FooWithAnnotatedProperyDependency : IFoo { [Inject] public IBar Bar { get; set; } } Given that we have a registration for the IBar dependency, it will be injected into the Bar property. container.Register IFoo, FooWithAnnotatedProperyDependency (); container.Register IBar, Bar (); var instance = (FooWithAnnotatedProperyDependency)container.GetInstance IFoo (); Assert.IsNotNull(instance.Bar); If we have multiple registrations of the same interface, we can also use the InjectAttribute to specify the service to be injected. public class FooWithNamedAnnotatedProperyDependency : IFoo { [Inject(\"AnotherBar\")] public IBar Bar { get; set; } } The container will inject the service that matches the specified service name. container.Register IFoo, FooWithNamedAnnotatedProperyDependency (); container.Register IBar, Bar (\"SomeBar\"); container.Register IBar, AnotherBar (\"AnotherBar\"); var instance = (FooWithNamedAnnotatedProperyDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(instance.Bar, typeof(AnotherBar)); Constructor Injection To enable annotated constructor injection, we must execute the following line before we start requesting services from the container. container.EnableAnnotatedConstructorInjection(); LightInject does consider all constructor parameters to be required dependencies and will try to satisfy all dependencies regardless of being annotated with the InjectAttribute . We can however use the InjectAttribute to specify the named service to be injected. public class FooWithNamedAnnotatedDependency : IFoo { public FooWithNamedAnnotatedDependency([Inject(ServiceName=\"AnotherBar\")]IBar bar) { Bar = bar; } public IBar Bar { get; private set; } } The container will inject the service that matches the specified service name. container.Register IFoo, FooWithNamedAnnotatedDependency (); container.Register IBar, Bar (\"SomeBar\"); container.Register IBar, AnotherBar (\"AnotherBar\"); var instance = (FooWithNamedAnnotatedDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));","title":"Annotation"},{"location":"annotation/#annotation","text":"LightInject supports annotation of properties and constructor parameters through an extension LightInject. PM Install-Package LightInject.Annotation By using the InjectAttribute we can be more explicit about the services that gets injected into properties and constructor dependencies. Note: As opposed to all other types within LightInject , the InjectAttribute is marked with the public access modifier so that is can be used outside the assembly that contains the service container. This creates a dependency from our services to the assembly containing the attribute, but we still don't need to reference any of the specific types in LightInject making this an affordable sacrifice when it comes to services referencing container specific types.","title":"Annotation"},{"location":"annotation/#property-injection","text":"To enable annotated property injection, we must execute the following line before we start requesting services from the container. container.EnableAnnotatedPropertyInjection(); The container now only try to inject dependencies for properties that is annotated with the InjectAttribute . The container will throw an InvalidOperationException if the annotated property dependency is unable to be resolved. public class FooWithAnnotatedProperyDependency : IFoo { [Inject] public IBar Bar { get; set; } } Given that we have a registration for the IBar dependency, it will be injected into the Bar property. container.Register IFoo, FooWithAnnotatedProperyDependency (); container.Register IBar, Bar (); var instance = (FooWithAnnotatedProperyDependency)container.GetInstance IFoo (); Assert.IsNotNull(instance.Bar); If we have multiple registrations of the same interface, we can also use the InjectAttribute to specify the service to be injected. public class FooWithNamedAnnotatedProperyDependency : IFoo { [Inject(\"AnotherBar\")] public IBar Bar { get; set; } } The container will inject the service that matches the specified service name. container.Register IFoo, FooWithNamedAnnotatedProperyDependency (); container.Register IBar, Bar (\"SomeBar\"); container.Register IBar, AnotherBar (\"AnotherBar\"); var instance = (FooWithNamedAnnotatedProperyDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));","title":"Property Injection"},{"location":"annotation/#constructor-injection","text":"To enable annotated constructor injection, we must execute the following line before we start requesting services from the container. container.EnableAnnotatedConstructorInjection(); LightInject does consider all constructor parameters to be required dependencies and will try to satisfy all dependencies regardless of being annotated with the InjectAttribute . We can however use the InjectAttribute to specify the named service to be injected. public class FooWithNamedAnnotatedDependency : IFoo { public FooWithNamedAnnotatedDependency([Inject(ServiceName=\"AnotherBar\")]IBar bar) { Bar = bar; } public IBar Bar { get; private set; } } The container will inject the service that matches the specified service name. container.Register IFoo, FooWithNamedAnnotatedDependency (); container.Register IBar, Bar (\"SomeBar\"); container.Register IBar, AnotherBar (\"AnotherBar\"); var instance = (FooWithNamedAnnotatedDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(instance.Bar, typeof(AnotherBar));","title":"Constructor Injection"},{"location":"aspnetcoreunittesting/","text":"AspNetCore Unit Testing Disclaimer: No Visual Studio 2017 was ever started during the writing of this post. This post is going to show how to unit test controllers in AspNetCore. We are going to do everything using nothing but the dotnet cli and VS Code. Let's start off by creating a new Web API application. dotnet new webapi That's going to set up a minimal Web API application containing a ValuesController To simplify the example we just return a single string value Next we are going to implement a service that we will inject into the ValuesController public interface IService { string GetValue(); } public class Service : IService { public string GetValue() { return Hello world ; } } Next step is to inject our service into the ValueController [Route( api/[controller] )] public class ValueController : Controller { private readonly IService _service; public ValueController(IService service) = _service = service; // GET api/values [HttpGet] public string Get() { return _service.GetValue(); } } Finally we need to register our service in the Startup class. public void ConfigureServices(IServiceCollection services) { services.AddSingleton IService,Service (); services.AddMvc(); } We are now all set and ready for some unit testing. Unit Testing To test our controller we will create a test project dotnet new xunit We will test our controller using the TestServer from the Microsoft.AspNetCore.TestHost package dotnet add package Microsoft.AspNetCore.TestHost Let's create our first test public class ControllerTests { [Fact] public async Task ShouldGetValue() { using (var testServer = CreateTestServer()) { var client = testServer.CreateClient(); var value = await client.GetStringAsync( api/value ); Assert.Equal( Hello world , value); } } private TestServer CreateTestServer() { var builder = new WebHostBuilder() .UseStartup Startup (); return new TestServer(builder); } } Configurable Server Let's imagine that we want to test our controller using a mock implementation of IService . We need to provide a way to override the default container registration before the server is started. The first step here is to add the ConfigureAdditionalServices method to the Startup class. public void ConfigureServices(IServiceCollection services) { services.AddSingleton IService,Service (); services.AddMvc(); ConfigureAdditionalServices(services); } protected virtual void ConfigureAdditionalServices(IServiceCollection services) { } The ConfigureAdditionalServices method gets called after all other services are registered giving us a chance to modify the configuration. We can now simply inherit from the Startup class and make it configurable. public class ConfigurableStartup : Startup { private readonly Action IServiceCollection configureAction; public ConfigurableStartup(IConfiguration configuration, Action IServiceCollection configureAction) : base(configuration) = this.configureAction = configureAction; protected override void ConfigureAdditionalServices(IServiceCollection services) { configureAction(services); } } While we could mock services right here in this class, we will make it more versatile by just injecting the configureAtion delegate allowing this class to be used in different scenarios. public class ConfigurableServer : TestServer { public ConfigurableServer(Action IServiceCollection configureAction = null) : base(CreateBuilder(configureAction)) { } private static IWebHostBuilder CreateBuilder(Action IServiceCollection configureAction) { if (configureAction == null) { configureAction = (sc) = {}; } var builder = new WebHostBuilder() .ConfigureServices(sc = sc.AddSingleton Action IServiceCollection (configureAction)) .UseStartup ConfigurableStartup (); return builder; } } Now this might need a little explanation. First we optionally pass inn the configureAction delegate and passes that delegate to the CreateBuilder method that creates the IWebHostBuilder instance that is again passed to the base constructor. The IWebHostBuilder has this ConfigureServices method that can be used to register services that is required by the startup class itself. In this case the ConfigurableStartup class takes the configureAction delegate as a constructor argument and we simply register the delegate as a singleton. Mocking With our new ConfigurableServer in place we can start to do some pretty interesting things with regards to mocking services inside our server. But first, let's install Moq dotnet add package moq We can now use the configureAction passed to the ConfigurableServer to replace the originally registered service. public async Task ShouldGetMockValue() { var serviceMock = new Mock IService (); serviceMock.Setup(m = m.GetValue()).Returns( Hello mockworld ); var serviceDescriptor = new ServiceDescriptor(typeof(IService), serviceMock.Object); using (var testServer = new ConfigurableServer(sc = sc.Replace(serviceDescriptor))) { var client = testServer.CreateClient(); var value = await client.GetStringAsync( api/value ); Assert.Equal( Hello mockworld , value); } } Want to comment? File an issue here :)","title":"AspNetCore unit testing"},{"location":"aspnetcoreunittesting/#aspnetcore-unit-testing","text":"Disclaimer: No Visual Studio 2017 was ever started during the writing of this post. This post is going to show how to unit test controllers in AspNetCore. We are going to do everything using nothing but the dotnet cli and VS Code. Let's start off by creating a new Web API application. dotnet new webapi That's going to set up a minimal Web API application containing a ValuesController To simplify the example we just return a single string value Next we are going to implement a service that we will inject into the ValuesController public interface IService { string GetValue(); } public class Service : IService { public string GetValue() { return Hello world ; } } Next step is to inject our service into the ValueController [Route( api/[controller] )] public class ValueController : Controller { private readonly IService _service; public ValueController(IService service) = _service = service; // GET api/values [HttpGet] public string Get() { return _service.GetValue(); } } Finally we need to register our service in the Startup class. public void ConfigureServices(IServiceCollection services) { services.AddSingleton IService,Service (); services.AddMvc(); } We are now all set and ready for some unit testing.","title":"AspNetCore Unit Testing"},{"location":"aspnetcoreunittesting/#unit-testing","text":"To test our controller we will create a test project dotnet new xunit We will test our controller using the TestServer from the Microsoft.AspNetCore.TestHost package dotnet add package Microsoft.AspNetCore.TestHost Let's create our first test public class ControllerTests { [Fact] public async Task ShouldGetValue() { using (var testServer = CreateTestServer()) { var client = testServer.CreateClient(); var value = await client.GetStringAsync( api/value ); Assert.Equal( Hello world , value); } } private TestServer CreateTestServer() { var builder = new WebHostBuilder() .UseStartup Startup (); return new TestServer(builder); } }","title":"Unit Testing"},{"location":"aspnetcoreunittesting/#configurable-server","text":"Let's imagine that we want to test our controller using a mock implementation of IService . We need to provide a way to override the default container registration before the server is started. The first step here is to add the ConfigureAdditionalServices method to the Startup class. public void ConfigureServices(IServiceCollection services) { services.AddSingleton IService,Service (); services.AddMvc(); ConfigureAdditionalServices(services); } protected virtual void ConfigureAdditionalServices(IServiceCollection services) { } The ConfigureAdditionalServices method gets called after all other services are registered giving us a chance to modify the configuration. We can now simply inherit from the Startup class and make it configurable. public class ConfigurableStartup : Startup { private readonly Action IServiceCollection configureAction; public ConfigurableStartup(IConfiguration configuration, Action IServiceCollection configureAction) : base(configuration) = this.configureAction = configureAction; protected override void ConfigureAdditionalServices(IServiceCollection services) { configureAction(services); } } While we could mock services right here in this class, we will make it more versatile by just injecting the configureAtion delegate allowing this class to be used in different scenarios. public class ConfigurableServer : TestServer { public ConfigurableServer(Action IServiceCollection configureAction = null) : base(CreateBuilder(configureAction)) { } private static IWebHostBuilder CreateBuilder(Action IServiceCollection configureAction) { if (configureAction == null) { configureAction = (sc) = {}; } var builder = new WebHostBuilder() .ConfigureServices(sc = sc.AddSingleton Action IServiceCollection (configureAction)) .UseStartup ConfigurableStartup (); return builder; } } Now this might need a little explanation. First we optionally pass inn the configureAction delegate and passes that delegate to the CreateBuilder method that creates the IWebHostBuilder instance that is again passed to the base constructor. The IWebHostBuilder has this ConfigureServices method that can be used to register services that is required by the startup class itself. In this case the ConfigurableStartup class takes the configureAction delegate as a constructor argument and we simply register the delegate as a singleton.","title":"Configurable Server"},{"location":"aspnetcoreunittesting/#mocking","text":"With our new ConfigurableServer in place we can start to do some pretty interesting things with regards to mocking services inside our server. But first, let's install Moq dotnet add package moq We can now use the configureAction passed to the ConfigurableServer to replace the originally registered service. public async Task ShouldGetMockValue() { var serviceMock = new Mock IService (); serviceMock.Setup(m = m.GetValue()).Returns( Hello mockworld ); var serviceDescriptor = new ServiceDescriptor(typeof(IService), serviceMock.Object); using (var testServer = new ConfigurableServer(sc = sc.Replace(serviceDescriptor))) { var client = testServer.CreateClient(); var value = await client.GetStringAsync( api/value ); Assert.Equal( Hello mockworld , value); } } Want to comment? File an issue here :)","title":"Mocking"},{"location":"autofactory/","text":"AutoFactory LightInject.AutoFactory enables automatic implementation of factory interfaces. Installing LightInject.AutoFactory provides two distribution models via NuGet Binary PM Install-Package LightInject.AutoFactory This adds a reference to the LightInject.AutoFactory.dll in the target project. Source PM Install-Package LightInject.AutoFactory.Source This will install a single file, LightInject.AutoFactory.cs in the target project. Factory The following interface represents a factory class used to resolve IFoo instances. public interface IFoo {} public class Foo : IFoo {} public interface IFooFactory { IFoo GetFoo(); } Instead of having to manually implement the IFooFactory interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented. You can enable this functionality by calling EnableAutoFactories on the container. container.Register IFoo, Foo (); container.EnableAutoFactories(); container.RegisterAutoFactory IFooFactory (); var factory = container.GetInstance IFooFactory (); var foo = factory.GetFoo(); Parameters public interface IFoo {} public class Foo : IFoo { public Foo(int value) {} } public interface IFooFactory { IFoo GetFoo(int value); } Runtime arguments can now be passed to the factory method. container.Register int, IFoo ((factory, value) = new Foo(value)); container.EnableAutoFactories(); container.RegisterAutoFactory IFooFactory (); var factory = container.GetInstance IFooFactory (); var foo = factory.GetFoo(42); Named Services public interface IFoo {} public class Foo : IFoo {} public class AnotherFoo : IFoo {} public interface IFooFactory { IFoo GetFoo(); IFoo GetAnotherFoo(); } The name of the factory method is used to identify named services. container.Register IFoo, Foo (); container.Register IFoo, Foo (\"AnotherFoo\"); container.EnableAutoFactories(); container.RegisterAutoFactory IFooFactory (); var factory = container.GetInstance IFooFactory (); var foo = factory.GetFoo(); var anotherFoo = factory.GetAnotherFoo(); Open Generics public interface IFoo T {} public class Foo T : IFoo T {} public interface IFooFactory { IFoo T GetFoo T (); } The generic type arguments from the factory method are used to create the service instance. container.Register(typeof(IFoo ), typeof(Foo )); container.EnableAutoFactories(); container.RegisterAutoFactory IFooFactory (); var factory = container.GetInstance IFooFactory (); var foo = factory.GetFoo int ();","title":"AutoFactory"},{"location":"autofactory/#autofactory","text":"LightInject.AutoFactory enables automatic implementation of factory interfaces.","title":"AutoFactory"},{"location":"autofactory/#installing","text":"LightInject.AutoFactory provides two distribution models via NuGet","title":"Installing"},{"location":"autofactory/#binary","text":"PM Install-Package LightInject.AutoFactory This adds a reference to the LightInject.AutoFactory.dll in the target project.","title":"Binary"},{"location":"autofactory/#source","text":"PM Install-Package LightInject.AutoFactory.Source This will install a single file, LightInject.AutoFactory.cs in the target project.","title":"Source"},{"location":"autofactory/#factory","text":"The following interface represents a factory class used to resolve IFoo instances. public interface IFoo {} public class Foo : IFoo {} public interface IFooFactory { IFoo GetFoo(); } Instead of having to manually implement the IFooFactory interface, we can just register the factory and resolve the instance through a factory that has been automatically implemented. You can enable this functionality by calling EnableAutoFactories on the container. container.Register IFoo, Foo (); container.EnableAutoFactories(); container.RegisterAutoFactory IFooFactory (); var factory = container.GetInstance IFooFactory (); var foo = factory.GetFoo();","title":"Factory"},{"location":"autofactory/#parameters","text":"public interface IFoo {} public class Foo : IFoo { public Foo(int value) {} } public interface IFooFactory { IFoo GetFoo(int value); } Runtime arguments can now be passed to the factory method. container.Register int, IFoo ((factory, value) = new Foo(value)); container.EnableAutoFactories(); container.RegisterAutoFactory IFooFactory (); var factory = container.GetInstance IFooFactory (); var foo = factory.GetFoo(42);","title":"Parameters"},{"location":"autofactory/#named-services","text":"public interface IFoo {} public class Foo : IFoo {} public class AnotherFoo : IFoo {} public interface IFooFactory { IFoo GetFoo(); IFoo GetAnotherFoo(); } The name of the factory method is used to identify named services. container.Register IFoo, Foo (); container.Register IFoo, Foo (\"AnotherFoo\"); container.EnableAutoFactories(); container.RegisterAutoFactory IFooFactory (); var factory = container.GetInstance IFooFactory (); var foo = factory.GetFoo(); var anotherFoo = factory.GetAnotherFoo();","title":"Named Services"},{"location":"autofactory/#open-generics","text":"public interface IFoo T {} public class Foo T : IFoo T {} public interface IFooFactory { IFoo T GetFoo T (); } The generic type arguments from the factory method are used to create the service instance. container.Register(typeof(IFoo ), typeof(Foo )); container.EnableAutoFactories(); container.RegisterAutoFactory IFooFactory (); var factory = container.GetInstance IFooFactory (); var foo = factory.GetFoo int ();","title":"Open Generics"},{"location":"designpatterns/","text":"Design Patterns LightInject has built-in support for the Decorator pattern and the Composite pattern. Decorator Pattern A decorator is a class that implements the same interface as the type it is decorating and takes the target instance as a constructor argument. public class FooDecorator : IFoo { public FooDecorator(IFoo foo) { } } Decorators are applied using the Decorate method. container.Register IFoo, Foo (); container.Decorate(typeof(IFoo), typeof(FooDecorator)); var instance = container.GetInstance IFoo (); Assert.IsInstanceOfType(instance, typeof(FooDecorator)); Decorators can be nested and they are applied in the same sequence as they are registered. container.Register IFoo, Foo (); container.Decorate(typeof(IFoo), typeof(FooDecorator)); container.Decorate(typeof(IFoo), typeof(AnotherFooDecorator)); var instance = container.GetInstance IFoo (); Assert.IsInstanceOfType(instance, typeof(AnotherFooDecorator)); If we have multiple services implementing the same interface, we can apply the decorator to implementations matching the given predicate. container.Register IFoo, Foo (); container.Register IFoo, AnotherFoo (\"AnotherFoo\"); container.Decorate(typeof(IFoo), typeof(FooDecorator), service = service.ServiceName == \"AnotherFoo\"); var instance = container.GetInstance IFoo (); var decoratedInstance = container.GetInstance IFoo (\"AnotherFoo\"); Assert.IsInstanceOfType(instance, typeof(Foo)); Assert.IsInstanceOfType(decoratedInstance, typeof(FooDecorator)); Decorators can have their own dependencies in addition to the target instance it is decorating. public class FooDecoratorWithDependency : IFoo { public FooDecoratorWithDependency(IFoo foo, IBar bar) { Foo = foo; Bar = bar; } public IFoo Foo { get; private set; } public IBar Bar { get; private set; } } The dependencies of the decorator can be implicitly resolved. container.Register IFoo, Foo (); container.Register IBar, Bar (); container.Decorate(typeof(IFoo), typeof(FooDecoratorWithDependency)); var instance = (FooDecoratorWithDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(instance.Foo, typeof(IFoo)); Assert.IsInstanceOfType(instance.Bar, typeof(IBar)); By using a function factory, we can explicitly specify the depenendecies of the decorator. container.Register IFoo, Foo (); container.Register IBar, Bar (); container.Decorate IFoo ((serviceFactory, target) = new FooDecoratorWithDependency(target, serviceFactory.GetInstance IBar ())); var instance = (FooDecoratorWithDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(instance.Foo, typeof(IFoo)); Assert.IsInstanceOfType(instance.Bar, typeof(IBar)); Note: The target instance is available through the function delegate so that we can pass it to the constructor of the decorator. Decorators can also be applied to open generic types. container.Register(typeof(IFoo ), typeof(Foo )); container.Decorate(typeof(IFoo ), typeof(FooDecorator )); var instance = container.GetInstance IFoo int (); Assert.IsInstanceOfType(instance, typeof(FooDecorator int )); Lazy Decorators A lazy decorator is a decorator that creates its target only when and if one of its methods are invoked. public class LazyFooDecorator : IFoo { private Lazy IFoo lazyFoo; public LazyFooDecorator(Lazy IFoo lazyFoo) { this.lazyFoo = lazyFoo; } public void Execute() { lazyFoo.Value.Execute; } } This decorator then postpones the creation of the target IFoo instance until the Execute method is invoked. Since LightInject has native support for Lazy T this becomes very easy to configure. container.Register(typeof(IFoo), typeof(Foo)); container.Decorate(typeof(IFoo), typeof(LazyFooDecorator)); var instance = container.GetInstance IFoo (); Assert.IsInstanceOfType(instance, typeof(LazyFooDecorator)); Composite Pattern The composite pattern is a simple pattern that lets a class implement an interface and then delegates invocation of methods to a set other classes implementing the same interface. public class FooWithEnumerableIFooDependency : IFoo { public IEnumerable IFoo FooList { get; private set; } public FooWithEnumerableIFooDependency(IEnumerable IFoo fooList) { FooList = fooList; } } While this looks like a recursive dependency, LightInject detects this and removes the FooWithEnumerableIFooDependency from the IEnumerable IFoo beeing injected. container.Register(typeof(IFoo), typeof(Foo), \"Foo\"); container.Register(typeof(IFoo), typeof(AnotherFoo), \"AnotherFoo\"); container.Register(typeof(IFoo), typeof(FooWithEnumerableIFooDependency)); var instance = (FooWithEnumerableIFooDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(instance.FooList.First(), typeof(Foo)); Assert.IsInstanceOfType(instance.FooList.Last(), typeof(AnotherFoo));","title":"Patterns"},{"location":"designpatterns/#design-patterns","text":"LightInject has built-in support for the Decorator pattern and the Composite pattern.","title":"Design Patterns"},{"location":"designpatterns/#decorator-pattern","text":"A decorator is a class that implements the same interface as the type it is decorating and takes the target instance as a constructor argument. public class FooDecorator : IFoo { public FooDecorator(IFoo foo) { } } Decorators are applied using the Decorate method. container.Register IFoo, Foo (); container.Decorate(typeof(IFoo), typeof(FooDecorator)); var instance = container.GetInstance IFoo (); Assert.IsInstanceOfType(instance, typeof(FooDecorator)); Decorators can be nested and they are applied in the same sequence as they are registered. container.Register IFoo, Foo (); container.Decorate(typeof(IFoo), typeof(FooDecorator)); container.Decorate(typeof(IFoo), typeof(AnotherFooDecorator)); var instance = container.GetInstance IFoo (); Assert.IsInstanceOfType(instance, typeof(AnotherFooDecorator)); If we have multiple services implementing the same interface, we can apply the decorator to implementations matching the given predicate. container.Register IFoo, Foo (); container.Register IFoo, AnotherFoo (\"AnotherFoo\"); container.Decorate(typeof(IFoo), typeof(FooDecorator), service = service.ServiceName == \"AnotherFoo\"); var instance = container.GetInstance IFoo (); var decoratedInstance = container.GetInstance IFoo (\"AnotherFoo\"); Assert.IsInstanceOfType(instance, typeof(Foo)); Assert.IsInstanceOfType(decoratedInstance, typeof(FooDecorator)); Decorators can have their own dependencies in addition to the target instance it is decorating. public class FooDecoratorWithDependency : IFoo { public FooDecoratorWithDependency(IFoo foo, IBar bar) { Foo = foo; Bar = bar; } public IFoo Foo { get; private set; } public IBar Bar { get; private set; } } The dependencies of the decorator can be implicitly resolved. container.Register IFoo, Foo (); container.Register IBar, Bar (); container.Decorate(typeof(IFoo), typeof(FooDecoratorWithDependency)); var instance = (FooDecoratorWithDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(instance.Foo, typeof(IFoo)); Assert.IsInstanceOfType(instance.Bar, typeof(IBar)); By using a function factory, we can explicitly specify the depenendecies of the decorator. container.Register IFoo, Foo (); container.Register IBar, Bar (); container.Decorate IFoo ((serviceFactory, target) = new FooDecoratorWithDependency(target, serviceFactory.GetInstance IBar ())); var instance = (FooDecoratorWithDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(instance.Foo, typeof(IFoo)); Assert.IsInstanceOfType(instance.Bar, typeof(IBar)); Note: The target instance is available through the function delegate so that we can pass it to the constructor of the decorator. Decorators can also be applied to open generic types. container.Register(typeof(IFoo ), typeof(Foo )); container.Decorate(typeof(IFoo ), typeof(FooDecorator )); var instance = container.GetInstance IFoo int (); Assert.IsInstanceOfType(instance, typeof(FooDecorator int ));","title":"Decorator Pattern"},{"location":"designpatterns/#lazy-decorators","text":"A lazy decorator is a decorator that creates its target only when and if one of its methods are invoked. public class LazyFooDecorator : IFoo { private Lazy IFoo lazyFoo; public LazyFooDecorator(Lazy IFoo lazyFoo) { this.lazyFoo = lazyFoo; } public void Execute() { lazyFoo.Value.Execute; } } This decorator then postpones the creation of the target IFoo instance until the Execute method is invoked. Since LightInject has native support for Lazy T this becomes very easy to configure. container.Register(typeof(IFoo), typeof(Foo)); container.Decorate(typeof(IFoo), typeof(LazyFooDecorator)); var instance = container.GetInstance IFoo (); Assert.IsInstanceOfType(instance, typeof(LazyFooDecorator));","title":"Lazy Decorators"},{"location":"designpatterns/#composite-pattern","text":"The composite pattern is a simple pattern that lets a class implement an interface and then delegates invocation of methods to a set other classes implementing the same interface. public class FooWithEnumerableIFooDependency : IFoo { public IEnumerable IFoo FooList { get; private set; } public FooWithEnumerableIFooDependency(IEnumerable IFoo fooList) { FooList = fooList; } } While this looks like a recursive dependency, LightInject detects this and removes the FooWithEnumerableIFooDependency from the IEnumerable IFoo beeing injected. container.Register(typeof(IFoo), typeof(Foo), \"Foo\"); container.Register(typeof(IFoo), typeof(AnotherFoo), \"AnotherFoo\"); container.Register(typeof(IFoo), typeof(FooWithEnumerableIFooDependency)); var instance = (FooWithEnumerableIFooDependency)container.GetInstance IFoo (); Assert.IsInstanceOfType(instance.FooList.First(), typeof(Foo)); Assert.IsInstanceOfType(instance.FooList.Last(), typeof(AnotherFoo));","title":"Composite Pattern"},{"location":"interception/","text":"Interception LightInject supports Aspect Oriented Programming through proxy-based method interceptors. Installing LightInject.Interception provides two distribution models via NuGet Binary PM Install-Package LightInject.Interception This adds a reference to the LightInject.Interception.dll in the target project. Source PM Install-Package LightInject.Interception.Source This will install a single file (LightInject.Interception.cs) into the current project. Interceptors An interceptor sits between the call site and the target instance and intercepts method calls. public class SampleInterceptor : IInterceptor { public object Invoke(IInvocationInfo invocationInfo) { // Perform logic before invoking the target method var returnValue = invocationInfo.Proceed(); // Perform logic after invoking the target method return returnValue; } } The IInvocationInfo instance passed into the Invoke method contains information about the method being intercepted. The Proceed method calls down the chain of interceptors and ultimately the actual target instance. Asynchronous Interceptors When intercepting asynchronous methods we need to be able to await the target method. This can be done by inheriting from the abstract AsyncInterceptor class that does the heavy lifting with invoking the asynchronous wrapper methods. The AsyncInterceptor class is a decorator that wraps around another IInterceptor . public class SampleAsyncInterceptor : AsyncInterceptor { public SampleAsyncInterceptor(IInterceptor targetInterceptor) : base(targetInterceptor) { } protected override async Task InvokeAsync(IInvocationInfo invocationInfo) { InterceptedTaskMethod = true; // Before method invocation await base.InvokeAsync(invocationInfo); // After method invocation } protected override async Task T InvokeAsync T (IInvocationInfo invocationInfo) { InterceptedTaskOfTMethod = true; // Before method invocation var value = await base.InvokeAsync T (invocationInfo); // After method invocation return value; } } Note: Do not call invocationInfo.Proceed() directly when inheriting from the AsyncInterceptor class. We can now create a new instance of the SampleAsyncInterceptor class like this: var asyncInterceptor = new SampleAsyncInterceptor(new SampleInterceptor()); Another option is to register our IInterceptor with the container and use the Decorate method to apply the SampleAsyncInterceptor as a decorator. container.Register IInterceptor, SampleInterceptor (); container.Decorate IInterceptor, SampleAsyncInterceptor (); container.Intercept(sr = sr.ServiceType == typeof(IFoo), factory = factory.GetInstance IInterceptor ()); Note: Only synchronous methods are passed down to the decorated IInterceptor Single Interceptor This example shows how to configure the service container with a single interceptor to handle all method calls. container.Register IFoo, Foo (); container.Intercept(sr = sr.ServiceType == typeof(IFoo), sf = new SampleInterceptor()); var instance = container.GetInstance IFoo (); The instance returned is a proxy object that forwards method calls to the SampleInterceptor class. The first parameter of the Intercept method is a selector function used to select the services that should have this interceptor applied. The second parameter is a function delegate that used to create an IInterceptor instance. Note: Proxy types are lazy in the sense that they will not create the target instance or any interceptors until the first method call is made. Dependencies Interceptors might also have dependencies and by resolving the interceptor through the container, those dependencies can be injected into the interceptor itself. public class SampleInterceptor : IInterceptor { private IBar bar; public SampleInterceptor(IBar bar) { this.bar = bar; } public object Invoke(IInvocationInfo invocationInfo) // Perform logic using the injected dependency before invoking the target method return invovationInfo.Proceed(); // Perform logic using the injected dependency after invoking the target method } } The following example shows how to configure the container so that the SampleInterceptor instance is resolved through the container. container.Register IFoo, Foo () container.Register IBar, Bar (); container.Register IInterceptor, SampleInterceptor (); container.Intercept(sr = sr.ServiceType == typeof(IFoo), sf = sf.GetInstance IInterceptor ()); Note: When injecting depndencies into an interceptor we must make sure that the injected dependency is NOT intercepted by the same interceptor as this would cause a StackOverFlowException . Multiple Interceptors Interceptors can be set up to handle a lot of cross cutting concerns such as logging, caching, null check and so on. According to the Single Responsibility Principle , we can separate the combined logic into a set of interceptor that each only does \"one\" thing. We can do this by using another overload of the Intercept method that allows us to set up a ProxyDefinition instance that gives us more control over the proxy type that is being created. container.Intercept(sr = sr.ServiceType == typeof(IFoo), (sf,pd) = DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(new FirstInterceptor()); proxyDefinition.Implement(new SecondInterceptor()); } Note: The interceptors are invoked in the same order as they are registered with the Implement method. Method Selectors Method selectors are used to select the methods that should be intercepted by an interceptor. The following example shows how to set up the container so that only calls method A is passed to the interceptor. container.Intercept(sr = sr.ServiceType == typeof(IFoo), (sf, pd) = DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() = new SampleInterceptor(), m = m.Name == \"SomeMethodName\"); } Methods that does not match the method selector predicate will NOT be intercepted and method calls will be passed directly down to the target instance. If we omit the method selector, LightInject will intercept all methods from the target type and any additional interface, except methods that are inherited from System.Object . Equals(Object) GetHashCode GetType ToString If we choose to use a method selector, these methods will also be intercepted if they match the predicate in the method selector. proxyDefinition.Implement(() = new SampleInterceptor(), m = m.IsDeclaredBy object ()); We can also use a method selector with the Intercept method that allows easy interception of any method without implementing an IInterceptor . container.Intercept(m = m.Name == \"SomeMethodName\", invocationInfo = invocationInfo.Proceed()); Extension Methods LightInject provides a set of extension method that simplifies method selector predicates. IsPropertySetter - Returns true if the method represents a property setter, otherwise false . IsPropertyGetter - Returns true if the method represents a property getter, otherwise false . GetProperty - Returns the property for which the target method either represents the property getter or the property setter. Chaining Interceptors As already seen in the example with multiple interceptors, we can chain interceptors together. We can also combine this with method selectors that will affect the call sequence from the call site down to the actual target instance. Consider an interface with three methods. public interface IFoo { void A(); void B(); void C(); } The following example shows how we can control the call sequence for each method. container.Intercept(sr = sr.ServiceType == typeof(IFoo), (sf, pd) = DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() = new FirstInterceptor(), m = m.Name == \"A\"); proxyDefinition.Implement(() = new SecondInterceptor(), m = m.Name == \"B\"); proxyDefinition.Implement(() = new ThirdInterceptor(), m = m.Name == \"A\" || m.Name == \"B\" || m.Name == \"C\"); } Method A call sequence FirstInterceptor - ThirdInterceptor - Target Method B call sequence SecondInterceptor - ThirdInterceptor - Target Method C call sequence ThirdInterceptor - Target Implementing additional interfaces Another powerful feature of proxy objects is the ability to implement additional interfaces that is not implemented by the target type. The Intercept method has an overload that lets us specify a set of interfaces to be implemented by the proxy type. container.Intercept(sr = sr.ServiceType == typeof(IFoo), new []{ typeof(IBar) }, (sf, pd) = DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() = new BarInterceptor(), m = m.IsDeclaredBy IBar ()); } When implementing additional interfaces we must make sure that all methods are intercepted by either one or a combined set of interceptors. This is because we are now dealing with methods that does not exist in the target type and we must do all implementation through interceptors. IProxy /// summary /// Implemented by all proxy types. /// /summary public interface IProxy { /// summary /// Gets the proxy target. /// /summary object Target { get; } } We can get to the underlying target instance through the IProxy interface container.Register IFoo, Foo (); container.Intercept(sr = sr.ServiceType == typeof(IFoo), sf = new SampleInterceptor()); var instance = container.GetInstance IFoo (); var actualTarget = ((IProxy)instance).Target; This One of the things to be aware of when working with proxy based interception is that it all relies on method calls being made through the proxy. Method calls that are made directly to the target instance will NOT be intercepted. public interface IFoo { void A(); } public class Foo : IFoo { public void A() {} private void B() { //Calls the target (this) directly and interceptors are not invoked. this.A(); } } Another scenario is when the proxy instance itself is leaking its target. public interface IFoo { IFoo A(); } public class Foo { public IFoo A() { return this; } } LightInject will take care of this scenario and detect that we are about to return this from a method and replace the return value with the proxy instance instead. Other scenarios such as event handlers or passing \"this\" to another method is NOT taken care of by LightInject as it is not possible without modifying the code in the target type itself. Class Proxies Starting from version 1.0.0.4, LightInject.Interception can be used to intercept classes with virtual members. public class Foo { public virtual void A() { } } Any member that is marked as virtual can be intercepted. var container = new ServiceContainer(); container.Register Foo (); container.Intercept(sr = sr.ServiceType == typeof(Foo), factory = new SampleInterceptor()); Class proxies are implemented internally by subclassing the target type and overriding virtual members to support interception.","title":"Interception"},{"location":"interception/#interception","text":"LightInject supports Aspect Oriented Programming through proxy-based method interceptors.","title":"Interception"},{"location":"interception/#installing","text":"LightInject.Interception provides two distribution models via NuGet","title":"Installing"},{"location":"interception/#binary","text":"PM Install-Package LightInject.Interception This adds a reference to the LightInject.Interception.dll in the target project.","title":"Binary"},{"location":"interception/#source","text":"PM Install-Package LightInject.Interception.Source This will install a single file (LightInject.Interception.cs) into the current project.","title":"Source"},{"location":"interception/#interceptors","text":"An interceptor sits between the call site and the target instance and intercepts method calls. public class SampleInterceptor : IInterceptor { public object Invoke(IInvocationInfo invocationInfo) { // Perform logic before invoking the target method var returnValue = invocationInfo.Proceed(); // Perform logic after invoking the target method return returnValue; } } The IInvocationInfo instance passed into the Invoke method contains information about the method being intercepted. The Proceed method calls down the chain of interceptors and ultimately the actual target instance.","title":"Interceptors"},{"location":"interception/#asynchronous-interceptors","text":"When intercepting asynchronous methods we need to be able to await the target method. This can be done by inheriting from the abstract AsyncInterceptor class that does the heavy lifting with invoking the asynchronous wrapper methods. The AsyncInterceptor class is a decorator that wraps around another IInterceptor . public class SampleAsyncInterceptor : AsyncInterceptor { public SampleAsyncInterceptor(IInterceptor targetInterceptor) : base(targetInterceptor) { } protected override async Task InvokeAsync(IInvocationInfo invocationInfo) { InterceptedTaskMethod = true; // Before method invocation await base.InvokeAsync(invocationInfo); // After method invocation } protected override async Task T InvokeAsync T (IInvocationInfo invocationInfo) { InterceptedTaskOfTMethod = true; // Before method invocation var value = await base.InvokeAsync T (invocationInfo); // After method invocation return value; } } Note: Do not call invocationInfo.Proceed() directly when inheriting from the AsyncInterceptor class. We can now create a new instance of the SampleAsyncInterceptor class like this: var asyncInterceptor = new SampleAsyncInterceptor(new SampleInterceptor()); Another option is to register our IInterceptor with the container and use the Decorate method to apply the SampleAsyncInterceptor as a decorator. container.Register IInterceptor, SampleInterceptor (); container.Decorate IInterceptor, SampleAsyncInterceptor (); container.Intercept(sr = sr.ServiceType == typeof(IFoo), factory = factory.GetInstance IInterceptor ()); Note: Only synchronous methods are passed down to the decorated IInterceptor","title":"Asynchronous Interceptors"},{"location":"interception/#single-interceptor","text":"This example shows how to configure the service container with a single interceptor to handle all method calls. container.Register IFoo, Foo (); container.Intercept(sr = sr.ServiceType == typeof(IFoo), sf = new SampleInterceptor()); var instance = container.GetInstance IFoo (); The instance returned is a proxy object that forwards method calls to the SampleInterceptor class. The first parameter of the Intercept method is a selector function used to select the services that should have this interceptor applied. The second parameter is a function delegate that used to create an IInterceptor instance. Note: Proxy types are lazy in the sense that they will not create the target instance or any interceptors until the first method call is made.","title":"Single Interceptor"},{"location":"interception/#dependencies","text":"Interceptors might also have dependencies and by resolving the interceptor through the container, those dependencies can be injected into the interceptor itself. public class SampleInterceptor : IInterceptor { private IBar bar; public SampleInterceptor(IBar bar) { this.bar = bar; } public object Invoke(IInvocationInfo invocationInfo) // Perform logic using the injected dependency before invoking the target method return invovationInfo.Proceed(); // Perform logic using the injected dependency after invoking the target method } } The following example shows how to configure the container so that the SampleInterceptor instance is resolved through the container. container.Register IFoo, Foo () container.Register IBar, Bar (); container.Register IInterceptor, SampleInterceptor (); container.Intercept(sr = sr.ServiceType == typeof(IFoo), sf = sf.GetInstance IInterceptor ()); Note: When injecting depndencies into an interceptor we must make sure that the injected dependency is NOT intercepted by the same interceptor as this would cause a StackOverFlowException .","title":"Dependencies"},{"location":"interception/#multiple-interceptors","text":"Interceptors can be set up to handle a lot of cross cutting concerns such as logging, caching, null check and so on. According to the Single Responsibility Principle , we can separate the combined logic into a set of interceptor that each only does \"one\" thing. We can do this by using another overload of the Intercept method that allows us to set up a ProxyDefinition instance that gives us more control over the proxy type that is being created. container.Intercept(sr = sr.ServiceType == typeof(IFoo), (sf,pd) = DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(new FirstInterceptor()); proxyDefinition.Implement(new SecondInterceptor()); } Note: The interceptors are invoked in the same order as they are registered with the Implement method.","title":"Multiple Interceptors"},{"location":"interception/#method-selectors","text":"Method selectors are used to select the methods that should be intercepted by an interceptor. The following example shows how to set up the container so that only calls method A is passed to the interceptor. container.Intercept(sr = sr.ServiceType == typeof(IFoo), (sf, pd) = DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() = new SampleInterceptor(), m = m.Name == \"SomeMethodName\"); } Methods that does not match the method selector predicate will NOT be intercepted and method calls will be passed directly down to the target instance. If we omit the method selector, LightInject will intercept all methods from the target type and any additional interface, except methods that are inherited from System.Object . Equals(Object) GetHashCode GetType ToString If we choose to use a method selector, these methods will also be intercepted if they match the predicate in the method selector. proxyDefinition.Implement(() = new SampleInterceptor(), m = m.IsDeclaredBy object ()); We can also use a method selector with the Intercept method that allows easy interception of any method without implementing an IInterceptor . container.Intercept(m = m.Name == \"SomeMethodName\", invocationInfo = invocationInfo.Proceed());","title":"Method Selectors"},{"location":"interception/#extension-methods","text":"LightInject provides a set of extension method that simplifies method selector predicates. IsPropertySetter - Returns true if the method represents a property setter, otherwise false . IsPropertyGetter - Returns true if the method represents a property getter, otherwise false . GetProperty - Returns the property for which the target method either represents the property getter or the property setter.","title":"Extension Methods"},{"location":"interception/#chaining-interceptors","text":"As already seen in the example with multiple interceptors, we can chain interceptors together. We can also combine this with method selectors that will affect the call sequence from the call site down to the actual target instance. Consider an interface with three methods. public interface IFoo { void A(); void B(); void C(); } The following example shows how we can control the call sequence for each method. container.Intercept(sr = sr.ServiceType == typeof(IFoo), (sf, pd) = DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() = new FirstInterceptor(), m = m.Name == \"A\"); proxyDefinition.Implement(() = new SecondInterceptor(), m = m.Name == \"B\"); proxyDefinition.Implement(() = new ThirdInterceptor(), m = m.Name == \"A\" || m.Name == \"B\" || m.Name == \"C\"); } Method A call sequence FirstInterceptor - ThirdInterceptor - Target Method B call sequence SecondInterceptor - ThirdInterceptor - Target Method C call sequence ThirdInterceptor - Target","title":"Chaining Interceptors"},{"location":"interception/#implementing-additional-interfaces","text":"Another powerful feature of proxy objects is the ability to implement additional interfaces that is not implemented by the target type. The Intercept method has an overload that lets us specify a set of interfaces to be implemented by the proxy type. container.Intercept(sr = sr.ServiceType == typeof(IFoo), new []{ typeof(IBar) }, (sf, pd) = DefineProxyType(pd)); private void DefineProxyType(ProxyDefinition proxyDefinition) { proxyDefinition.Implement(() = new BarInterceptor(), m = m.IsDeclaredBy IBar ()); } When implementing additional interfaces we must make sure that all methods are intercepted by either one or a combined set of interceptors. This is because we are now dealing with methods that does not exist in the target type and we must do all implementation through interceptors.","title":"Implementing additional interfaces"},{"location":"interception/#iproxy","text":"/// summary /// Implemented by all proxy types. /// /summary public interface IProxy { /// summary /// Gets the proxy target. /// /summary object Target { get; } } We can get to the underlying target instance through the IProxy interface container.Register IFoo, Foo (); container.Intercept(sr = sr.ServiceType == typeof(IFoo), sf = new SampleInterceptor()); var instance = container.GetInstance IFoo (); var actualTarget = ((IProxy)instance).Target;","title":"IProxy"},{"location":"interception/#this","text":"One of the things to be aware of when working with proxy based interception is that it all relies on method calls being made through the proxy. Method calls that are made directly to the target instance will NOT be intercepted. public interface IFoo { void A(); } public class Foo : IFoo { public void A() {} private void B() { //Calls the target (this) directly and interceptors are not invoked. this.A(); } } Another scenario is when the proxy instance itself is leaking its target. public interface IFoo { IFoo A(); } public class Foo { public IFoo A() { return this; } } LightInject will take care of this scenario and detect that we are about to return this from a method and replace the return value with the proxy instance instead. Other scenarios such as event handlers or passing \"this\" to another method is NOT taken care of by LightInject as it is not possible without modifying the code in the target type itself.","title":"This"},{"location":"interception/#class-proxies","text":"Starting from version 1.0.0.4, LightInject.Interception can be used to intercept classes with virtual members. public class Foo { public virtual void A() { } } Any member that is marked as virtual can be intercepted. var container = new ServiceContainer(); container.Register Foo (); container.Intercept(sr = sr.ServiceType == typeof(Foo), factory = new SampleInterceptor()); Class proxies are implemented internally by subclassing the target type and overriding virtual members to support interception.","title":"Class Proxies"},{"location":"licence/","text":"The MIT License (MIT) Copyright (c) 2014 bernhard.richter@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Licence"},{"location":"licence/#the-mit-license-mit","text":"Copyright (c) 2014 bernhard.richter@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"The MIT License (MIT)"},{"location":"lightmock/","text":"LightMock LightMock is a simple mocking library that can be used on platforms that does not allow dynamic code generation. Installing PM Install-Package LightMock This adds a reference to the LightMock in the target project. The LightMock library is a a portable class library that makes it possible to use this across all platforms including iOS and Android. Creating a mock object Even though the mock objects are created manually, they can be reused in many scenarios. As an an example we will use this simple interface. public interface IFoo { void Execute(string value); string Execute(); } The mock object implementing this interface looks like this public class FooMock : IFoo { private readonly IInvocationContext IFoo context; public FooMock(IInvocationContext IFoo context) { this.context = context; } public void Execute(string value) { context.Invoke(f = f.Execute(value)); } public string Execute() { return context.Invoke(f = f.Execute()); } } Note: Only mocked methods needs to be implemented. Other methods that does not get invoked during testing can just throw a NotImplementedException. Assertions The Assert method is used to verify that the given method has been executed the expected number of times using the expected arguments. //Arrange var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); //Act fooMock.Execute(\"SomeValue\"); //Assert mockContext.Assert(f = f.Execute(\"SomeValue\")); Note: Not specifying the expected number of invocations, means at least once. If we don't care about the actual argument value, we can use a special class called The . var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); fooMock.Execute(\"SomeValue\"); mockContext.Assert(f = f.Execute(The string .IsAnyValue), Invoked.Once); We call also use this class to perform custom verification. var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); fooMock.Execute(\"SomeValue\"); mockContext.Assert(f = f.Execute(The string .Is(s = s.StartsWith(\"Some\"))), Invoked.Once); Arrangements We can use arrangements to add behavior to the mock object. For instance we can set up the mock object to return a value. var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); mockContext.Arrange(f = f.Execute()).Returns(\"SomeValue\"); var result = fooMock.Execute(); Assert.AreEqual(\"SomeValue\", result); Throw an exception var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); mockContext.Arrange(f = f.Execute(\"SomeValue\")).Throws InvalidOperationException (); fooMock.Execute(\"SomeValue\"); Throw an exception using a exception factory. var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); mockContext.Arrange(f = f.Execute(\"SomeValue\")).Throws(() = new InvalidOperationException()); fooMock.Execute(\"SomeValue\"); Execute a callback var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); string callBackResult = null; mockContext.Arrange(f = f.Execute(The string .IsAnyValue)) .Callback string (s = callBackResult = s); fooMock.Execute(\"SomeValue\"); Assert.AreEqual(\"SomeValue\", callBackResult);","title":"LightMock"},{"location":"lightmock/#lightmock","text":"LightMock is a simple mocking library that can be used on platforms that does not allow dynamic code generation.","title":"LightMock"},{"location":"lightmock/#installing","text":"PM Install-Package LightMock This adds a reference to the LightMock in the target project. The LightMock library is a a portable class library that makes it possible to use this across all platforms including iOS and Android.","title":"Installing"},{"location":"lightmock/#creating-a-mock-object","text":"Even though the mock objects are created manually, they can be reused in many scenarios. As an an example we will use this simple interface. public interface IFoo { void Execute(string value); string Execute(); } The mock object implementing this interface looks like this public class FooMock : IFoo { private readonly IInvocationContext IFoo context; public FooMock(IInvocationContext IFoo context) { this.context = context; } public void Execute(string value) { context.Invoke(f = f.Execute(value)); } public string Execute() { return context.Invoke(f = f.Execute()); } } Note: Only mocked methods needs to be implemented. Other methods that does not get invoked during testing can just throw a NotImplementedException.","title":"Creating a mock object"},{"location":"lightmock/#assertions","text":"The Assert method is used to verify that the given method has been executed the expected number of times using the expected arguments. //Arrange var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); //Act fooMock.Execute(\"SomeValue\"); //Assert mockContext.Assert(f = f.Execute(\"SomeValue\")); Note: Not specifying the expected number of invocations, means at least once. If we don't care about the actual argument value, we can use a special class called The . var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); fooMock.Execute(\"SomeValue\"); mockContext.Assert(f = f.Execute(The string .IsAnyValue), Invoked.Once); We call also use this class to perform custom verification. var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); fooMock.Execute(\"SomeValue\"); mockContext.Assert(f = f.Execute(The string .Is(s = s.StartsWith(\"Some\"))), Invoked.Once);","title":"Assertions"},{"location":"lightmock/#arrangements","text":"We can use arrangements to add behavior to the mock object. For instance we can set up the mock object to return a value. var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); mockContext.Arrange(f = f.Execute()).Returns(\"SomeValue\"); var result = fooMock.Execute(); Assert.AreEqual(\"SomeValue\", result); Throw an exception var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); mockContext.Arrange(f = f.Execute(\"SomeValue\")).Throws InvalidOperationException (); fooMock.Execute(\"SomeValue\"); Throw an exception using a exception factory. var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); mockContext.Arrange(f = f.Execute(\"SomeValue\")).Throws(() = new InvalidOperationException()); fooMock.Execute(\"SomeValue\"); Execute a callback var mockContext = new MockContext IFoo (); var fooMock = new FooMock(mockContext); string callBackResult = null; mockContext.Arrange(f = f.Execute(The string .IsAnyValue)) .Callback string (s = callBackResult = s); fooMock.Execute(\"SomeValue\"); Assert.AreEqual(\"SomeValue\", callBackResult);","title":"Arrangements"},{"location":"microsoft.aspnetcore.hosting/","text":"LightInject.Microsoft.AspNetCore.Hosting Enables LightInject to be used as the service container in AspNetCore applications Installing PackageReference Include= LightInject.Microsoft.AspNetCore.Hosting Version= version / Usage Enabling LightInject is as simple as calling the UseLightInject method that extends the IWebHostBuilder . The following sample shows how to do this in a simple web application. public class Program { public static void Main(string[] args) { CreateWebHostBuilder(args).Build().Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args) = WebHost.CreateDefaultBuilder(args) .UseLightInject() .UseStartup Startup (); } Typically in LightInject , we register services in a composition root public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register IFoo, Foo (); } } public interface IFoo {} public class Foo : IFoo {} By declaring a method named ConfigureContainer we can get access to the IServiceContainer that we in this example use to register our composition root. public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } // Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) { } // Use this method to add services directly to LightInject // Important: This method must exist in order to replace the default provider. public void ConfigureContainer(IServiceContainer container) { container.RegisterFrom CompositionRoot (); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IHostingEnvironment env) { } } Note: Services registered in the ConfigureServices method will also be registered with LightInject Controllers By default, controllers are not actually created by LightInject . They are created by the ASP.NET infrastructure and uses LightInject to resolve its dependencies. To enable LightInject to create the controller instances, we need to add the following line. services.AddMvc().AddControllersAsServices(); Test Services We can register test/mock services to be used when testing our controllers. public void ShouldResolveMockedService() { var builder = new WebHostBuilder() .UseLightInject() .ConfigureTestContainer IServiceContainer (c = c.RegisterTransient IFoo, FooMock ()) .UseStartup TestStartup (); using (var webHost = builder.Build()) { var foo = webHost.Services.GetRequiredService IFoo (); Assert.IsType FooMock (foo); } } public class FooMock : IFoo { }","title":"AspNetCore"},{"location":"microsoft.aspnetcore.hosting/#lightinjectmicrosoftaspnetcorehosting","text":"Enables LightInject to be used as the service container in AspNetCore applications","title":"LightInject.Microsoft.AspNetCore.Hosting"},{"location":"microsoft.aspnetcore.hosting/#installing","text":"PackageReference Include= LightInject.Microsoft.AspNetCore.Hosting Version= version /","title":"Installing"},{"location":"microsoft.aspnetcore.hosting/#usage","text":"Enabling LightInject is as simple as calling the UseLightInject method that extends the IWebHostBuilder . The following sample shows how to do this in a simple web application. public class Program { public static void Main(string[] args) { CreateWebHostBuilder(args).Build().Run(); } public static IWebHostBuilder CreateWebHostBuilder(string[] args) = WebHost.CreateDefaultBuilder(args) .UseLightInject() .UseStartup Startup (); } Typically in LightInject , we register services in a composition root public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register IFoo, Foo (); } } public interface IFoo {} public class Foo : IFoo {} By declaring a method named ConfigureContainer we can get access to the IServiceContainer that we in this example use to register our composition root. public class Startup { public Startup(IConfiguration configuration) { Configuration = configuration; } public IConfiguration Configuration { get; } // Use this method to add services to the container. public void ConfigureServices(IServiceCollection services) { } // Use this method to add services directly to LightInject // Important: This method must exist in order to replace the default provider. public void ConfigureContainer(IServiceContainer container) { container.RegisterFrom CompositionRoot (); } // This method gets called by the runtime. Use this method to configure the HTTP request pipeline. public void Configure(IApplicationBuilder app, IHostingEnvironment env) { } } Note: Services registered in the ConfigureServices method will also be registered with LightInject","title":"Usage"},{"location":"microsoft.aspnetcore.hosting/#controllers","text":"By default, controllers are not actually created by LightInject . They are created by the ASP.NET infrastructure and uses LightInject to resolve its dependencies. To enable LightInject to create the controller instances, we need to add the following line. services.AddMvc().AddControllersAsServices();","title":"Controllers"},{"location":"microsoft.aspnetcore.hosting/#test-services","text":"We can register test/mock services to be used when testing our controllers. public void ShouldResolveMockedService() { var builder = new WebHostBuilder() .UseLightInject() .ConfigureTestContainer IServiceContainer (c = c.RegisterTransient IFoo, FooMock ()) .UseStartup TestStartup (); using (var webHost = builder.Build()) { var foo = webHost.Services.GetRequiredService IFoo (); Assert.IsType FooMock (foo); } } public class FooMock : IFoo { }","title":"Test Services"},{"location":"microsoft.dependencyinjection/","text":"LightInject.Microsoft.DependencyInjection Implements the Microsoft.Extensions.DependencyInjection.Abstractions and makes it possible to create an IServiceProvider that is 100% compatible with the Microsoft.Extensions.DependencyInjection.Specification.Tests . Note: This package is NOT meant to be used directly with AspNetCore applications. If the target application is an AspNetCore application, use the LightInject.Microsoft.AspNetCore.Hosting package instead. Installing dotnet add package LightInject.Microsoft.DependencyInjection Usage var services = new ServiceCollection(); services.AddTransient Foo (); var provider = services.CreateLightInjectServiceProvider(); It is also possible to create an IServiceProvider directly from an IServiceContainer instance. var container = new ServiceContainer(Options.Default.WithMicrosoftSettings); var provider = container.CreateServiceProvider(); Note: Make sure that the Options.Default.WithMicrosoftSettings is passed in as options when creating the container. This makes the provider compliant with the default provider from Microsoft.","title":"Microsoft DI"},{"location":"microsoft.dependencyinjection/#lightinjectmicrosoftdependencyinjection","text":"Implements the Microsoft.Extensions.DependencyInjection.Abstractions and makes it possible to create an IServiceProvider that is 100% compatible with the Microsoft.Extensions.DependencyInjection.Specification.Tests . Note: This package is NOT meant to be used directly with AspNetCore applications. If the target application is an AspNetCore application, use the LightInject.Microsoft.AspNetCore.Hosting package instead.","title":"LightInject.Microsoft.DependencyInjection"},{"location":"microsoft.dependencyinjection/#installing","text":"dotnet add package LightInject.Microsoft.DependencyInjection","title":"Installing"},{"location":"microsoft.dependencyinjection/#usage","text":"var services = new ServiceCollection(); services.AddTransient Foo (); var provider = services.CreateLightInjectServiceProvider(); It is also possible to create an IServiceProvider directly from an IServiceContainer instance. var container = new ServiceContainer(Options.Default.WithMicrosoftSettings); var provider = container.CreateServiceProvider(); Note: Make sure that the Options.Default.WithMicrosoftSettings is passed in as options when creating the container. This makes the provider compliant with the default provider from Microsoft.","title":"Usage"},{"location":"mvc/","text":"MVC LightInject.Mvc provides an integration that enables dependency injection in ASP.NET MVC applications. Installing LightInject.Mvc provides two distribution models via NuGet Binary PM Install-Package LightInject.Mvc This adds a reference to the LightInject.Mvc.dll in the target project. Source PM Install-Package LightInject.Mvc.Source This will install a single file (LightInject.Mvc.cs) into the current project. Initializing protected void Application_Start() { var container = new ServiceContainer(); container.RegisterControllers(); //register other services container.EnableMvc() } Services All services that implements IDisposable, must be registered with the PerScopeLifetime to ensure that they are properly disposed when the web request ends. container.Register IFoo, Foo (new PerScopeLifetime()); Controllers are also disposable services and LightInject provides the RegisterControllers method that registers all controllers from a given assembly with the PerRequestLifetime . container.RegisterControllers(typeof(MyMvcApplication).Assembly); FilterAttribute Although filter attributes are instantiated by the MFC infrastructure, LightInject is still able to inject dependencies into properties. public class FooFilterAttribute : ActionFilterAttribute { public IFoo Foo { get; set; } }","title":"Mvc"},{"location":"mvc/#mvc","text":"LightInject.Mvc provides an integration that enables dependency injection in ASP.NET MVC applications.","title":"MVC"},{"location":"mvc/#installing","text":"LightInject.Mvc provides two distribution models via NuGet","title":"Installing"},{"location":"mvc/#binary","text":"PM Install-Package LightInject.Mvc This adds a reference to the LightInject.Mvc.dll in the target project.","title":"Binary"},{"location":"mvc/#source","text":"PM Install-Package LightInject.Mvc.Source This will install a single file (LightInject.Mvc.cs) into the current project.","title":"Source"},{"location":"mvc/#initializing","text":"protected void Application_Start() { var container = new ServiceContainer(); container.RegisterControllers(); //register other services container.EnableMvc() }","title":"Initializing"},{"location":"mvc/#services","text":"All services that implements IDisposable, must be registered with the PerScopeLifetime to ensure that they are properly disposed when the web request ends. container.Register IFoo, Foo (new PerScopeLifetime()); Controllers are also disposable services and LightInject provides the RegisterControllers method that registers all controllers from a given assembly with the PerRequestLifetime . container.RegisterControllers(typeof(MyMvcApplication).Assembly);","title":"Services"},{"location":"mvc/#filterattribute","text":"Although filter attributes are instantiated by the MFC infrastructure, LightInject is still able to inject dependencies into properties. public class FooFilterAttribute : ActionFilterAttribute { public IFoo Foo { get; set; } }","title":"FilterAttribute"},{"location":"nancy/","text":"Nancy LightInject.Nancy provides an integration that enables LightInject to be used as the IoC container in the Nancy web framework. Installing PM Install-Package LightInject.Nancy This adds a reference to the LightInject.Nancy.dll in the target project. Dependencies public interface IFoo {} public class Foo : IFoo {} public class SampleModule : NancyModule { public SampleModule(IFoo foo) { Get[\"/\"] = parameters = \"Hello World\"; } } Configuring additional services/dependencies is done by implementing the ICompositionRoot interface. public class CompositionRoot : ICompositionRoot { void ICompositionRoot.Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register IFoo, Foo (); } } Note: LightInject will look for an ICompositionRoot implementation in the same assembly as the requested service. Custom Bootstrapper If we need to use an existing container instance or perform some other configuration, this can be done by inheriting from the LightInjectNancyBootstrapper class. public class Bootstrapper : LightInjectNancyBootstrapper { protected override IServiceContainer GetServiceContainer() { // Alteratively provide an existing container instance. return base.GetServiceContainer(); } } Lifetime Services registered with the PerScopeLifetime are scoped per web request while services registered with the PerContainerLifetime are as scoped per application. NancyContext By injecting a Func NancyContext delegate we can get access to the NancyContext even outside of Nancy modules. public class Foo { private readonly Func NancyContext getNancyContext; public Foo(Func NancyContext getNancyContext) { this.getNancyContext = getNancyContext; } public void DoSomething() { var nancyContext = getNancyContext(); } }","title":"Nancy"},{"location":"nancy/#nancy","text":"LightInject.Nancy provides an integration that enables LightInject to be used as the IoC container in the Nancy web framework.","title":"Nancy"},{"location":"nancy/#installing","text":"PM Install-Package LightInject.Nancy This adds a reference to the LightInject.Nancy.dll in the target project.","title":"Installing"},{"location":"nancy/#dependencies","text":"public interface IFoo {} public class Foo : IFoo {} public class SampleModule : NancyModule { public SampleModule(IFoo foo) { Get[\"/\"] = parameters = \"Hello World\"; } } Configuring additional services/dependencies is done by implementing the ICompositionRoot interface. public class CompositionRoot : ICompositionRoot { void ICompositionRoot.Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register IFoo, Foo (); } } Note: LightInject will look for an ICompositionRoot implementation in the same assembly as the requested service.","title":"Dependencies"},{"location":"nancy/#custom-bootstrapper","text":"If we need to use an existing container instance or perform some other configuration, this can be done by inheriting from the LightInjectNancyBootstrapper class. public class Bootstrapper : LightInjectNancyBootstrapper { protected override IServiceContainer GetServiceContainer() { // Alteratively provide an existing container instance. return base.GetServiceContainer(); } }","title":"Custom Bootstrapper"},{"location":"nancy/#lifetime","text":"Services registered with the PerScopeLifetime are scoped per web request while services registered with the PerContainerLifetime are as scoped per application.","title":"Lifetime"},{"location":"nancy/#nancycontext","text":"By injecting a Func NancyContext delegate we can get access to the NancyContext even outside of Nancy modules. public class Foo { private readonly Func NancyContext getNancyContext; public Foo(Func NancyContext getNancyContext) { this.getNancyContext = getNancyContext; } public void DoSomething() { var nancyContext = getNancyContext(); } }","title":"NancyContext"},{"location":"signalr/","text":"SignalR LightInject.Signal provides an integration that enables dependency injection in SignalR hub implementations. Installing LightInject.SignalR provides two distribution models via NuGet Binary PM Install-Package LightInject.SignalR This adds a reference to the LightInject.SignalR.dll in the target project. Source PM Install-Package LightInject.SignalR.Source This will install a single file ( LightInject.SignalR.cs ) into the current project. Initializing The following example shows how to enable support for SignalR in an OWIN startup class. public class Startup { public void Configuration(IAppBuilder app) { var serviceContainer = new ServiceContainer(); serviceContainer.RegisterHubs(); ..register other services app.MapSignalR(serviceContainer.EnableSignalR()); } } Services Services that implements IDisposable must be registered with the with the PerScopeLifetime or the PerRequestLifetime to ensure that they are properly disposed when the Hub is disposed.","title":"SignalR"},{"location":"signalr/#signalr","text":"LightInject.Signal provides an integration that enables dependency injection in SignalR hub implementations.","title":"SignalR"},{"location":"signalr/#installing","text":"LightInject.SignalR provides two distribution models via NuGet","title":"Installing"},{"location":"signalr/#binary","text":"PM Install-Package LightInject.SignalR This adds a reference to the LightInject.SignalR.dll in the target project.","title":"Binary"},{"location":"signalr/#source","text":"PM Install-Package LightInject.SignalR.Source This will install a single file ( LightInject.SignalR.cs ) into the current project.","title":"Source"},{"location":"signalr/#initializing","text":"The following example shows how to enable support for SignalR in an OWIN startup class. public class Startup { public void Configuration(IAppBuilder app) { var serviceContainer = new ServiceContainer(); serviceContainer.RegisterHubs(); ..register other services app.MapSignalR(serviceContainer.EnableSignalR()); } }","title":"Initializing"},{"location":"signalr/#services","text":"Services that implements IDisposable must be registered with the with the PerScopeLifetime or the PerRequestLifetime to ensure that they are properly disposed when the Hub is disposed.","title":"Services"},{"location":"transactions/","text":"Transaction Management In this example we will be looking into how to deal with connections and transactions in a Web application. We will also discuss how to implement automatic rollback for integration tests. Our testing framework will be xUnit and together with LightInject this will hopefully turn into a very smooth testing experience. Commands and Queries There are many ways to manage the interaction with the database and in this application we are going to implement something that has come to be known as the Command-Query pattern. The basic idea here is that we have one interface ( IQueryHandler ) for everything that comes out of the database and another interface ( ICommandHandler )for everything that goes into the database. The fact that we are dealing with the same set of interfaces for all interaction with the database means that we can very easily add features through the use of decorators. I am not going to cover everything with regards to command and queries here, but we will look into the interfaces we need to implement in order to shuffle data back and forth to the database. Queries The following interface represents a class that can handle a query and return some kind of result. public interface IQueryHandler in TQuery, TResult where TQuery : IQuery TResult { Task TResult HandleAsync(TQuery query); } You might wonder about the IQuery TResult generic contraint. This is just an interface to give type inference a helping hand as we move on to the next interface. The IQueryExecutor represents a class that can execute any query. public interface IQueryExecutor { Task TResult ExecuteAsync TResult (IQuery TResult query); } This is where the IQuery TResult generic contraint comes into play. Without the contraint we would have to specify the type of result when calling the ExecuteAsync method. var result = queryExecutor.ExecuteAsync SomeResultType (somequery); With the query class \"implementing\" the IQuery TResult interface we can instead do this var result = queryExecutor.ExecuteAsync(somequery); Commands The following interface represents a class that can handle a command where the command can be any class. public interface ICommandHandler in TCommand { Task HandleAsync(TCommand command); } Will be seeing examples of both queries and commands throughout this example. Why not an ORM? The best answer I can give you is that I have already been there and felt the pain that eventually comes sneaking upon you. A little at first and then more and more as things gets more complicated. In fact, I have actually written an inhouse ORM back in the days and writing a Linq provider for instance, certainly represents the Mount Everest of programming. Not because Linq is so hard, but because you have to deal with all the mismatches between the relational model and the object model. ORM's tries to free you from understanding SQL and it is such a failed abstraction. Eventually at some point, you find yourself in a situation where you are trying to come up with a Linq expression that generates the SQL you've already written. Bottom line, bite the bullet and learn SQL. Customers The first task is to create a query handler that can retrieve customers from the database based on their origin (country). The SQL for ths look like this: SELECT CustomerId, CompanyName FROM Customers WHERE Country = @Country; With the SQL in place, we are ready to implement the query handler. public class CustomersQueryHandler : IQueryHandler CustomersQuery, Customer[] { private readonly IDbConnection dbConnection; public CustomersQueryHandler(IDbConnection dbConnection) { this.dbConnection = dbConnection; } public async Task Customer[] HandleAsync(CustomersQuery query) { var result = await dbConnection.QueryAsync CustomerRow (SQL.CustomersByCountry, query); return result.ToArray(); } } Note: Query and command handlers does not dictate that the data is stored in a relational database. It might just as well be stored in a file or another type of database such as a document database. This query handler has just one dependency, the IDbConnection off which Dapper provides the QueryAsync method used to execute the query. The query ( CustomersQuery ) looks like this public class CustomersQuery : IQuery Customer[] { public string Country { get; set; } } Passing data through layers Okay, so we have our application that consists of different layers. Data Access Layer (query and command handlers) Business Layer (services using the data access layer) Public API (typically a REST based API using services from the business layer) Data Access Layer This is where we actually interact with the underlying data store which for most applications even today means a relational database. These databases store relational data and is not very well suited for storing objects and we should treat the database accordingly. Relational databases does not store objects, they store rows of data. This is why we represent the result from Dapper as a set of CustomerRow instances. Business Layer This layer consists of the services that in turn will be using the data access layer. This is also the place to put any kind of business logic related to our services. By mocking the data access layer we can test this functionality without hitting the database. API Layer This is our public API which in this sample application is exposed as a RESTful API using Web Api. Try to keep this layer as thin as possible. It should not deal with any kind of business logic, but it should for instance deal with making sure that we return the correct status codes according to REST best practices. So should each layer have its own representation of the same data? My answer is this: Be pragmatic about this. If the representation looks identical throughout the various layers, you might as well reuse the same class for different layers. Once you need to add JsonIgnore attributes to ensure that database-only properties does not get exposed in the Web API, you might consider another representation. It is also likely that the representations for reading and writing will differ so there is a lot to consider her. There is also a performance penalty involved here since we need to constantly map the \"same\" data between layers. There might also be situations where the service layer just acts as a pass-t through layer and it that case it might be just fine to use the query/command handlers directly in our controllers. Composition Root The composition root is where we register services into the container. serviceRegistry.Register IQueryExecutor, QueryExecutor (new PerContainerLifetime()); serviceRegistry.RegisterQueryHandlers(); // We register the connection that it is disposed when the scope ends. // The scope here is per web request. serviceRegistry.Register(factory = CreateConnection(), new PerScopeLifetime()); We register the IDbConnection with the PerScopeLifetime which means that we get the same connection within a scope. The scope is usually per web request, but it can also be per test method as we will see in a minute. This is actually a nice aspect of the scoping mechanism in LightInject. We tell a service to be per scope without providing any details about how the scope is started or ended. Testing query handlers Before we dive into how to handle transactions, we are going to look at how to test our new query handler. LightInject provides an extension( LightInject.xUnit ) that makes it possible to inject services into test methods. [Theory, Scoped, InjectData] public async Task ShouldGetCustomersFromGermany(IQueryExecutor queryExecutor) { var query = new CustomersQuery {Country = Germany }; var result = await queryExecutor.ExecuteAsync(query); Assert.Equal(11, result.Length); } The Scoped attribute tells LightInject to wrap a scope around this test method. When the test method ends, the scope will end as well and that will in turn cause the IDbConnection to be disposed since that service is registered with the PerScopeLifetime . The InjectData attribute simply tells LightInject to inject method arguments and can be thought off as a more sophisticated version of the InlineData attribute usually seen in xUnit theory based tests. LightInject.xUnit creates a container instance behind the scenes and uses that instance to inject services into the test methods. The default behavior in LightInject is to look for composition roots in the same assembly as the requested service. This is part of the fallback mechanism and means that we don't really need to explicitly configure the container in the test class although it is possible to do so by declaring the following static method. public static void Configure(IServiceContainer container) { container.RegisterFrom CompositionRoot (); } We can also use the InjectData attribute so specify inline data in addition to the service being injected. [Theory, Scoped] [InjectData( France , 11)] [InjectData( Germany , 11)] [InjectData( Norway , 1)] public async Task ShouldGetCustomers(IQueryExecutor queryExecutor, string country, int expectedCount) { var result = await queryExecutor.ExecuteAsync(new CustomersQuery() { Country = country }); Assert.Equal(expectedCount, result.Length); } Transactions We are going to build upon the standard IDbConnection and IDbTransaction interfaces and provide a way to transparently apply transactions to command handlers. Requirements: Transactions should as short lived as possible. Only one transaction per scope (web request) Support sequential and nested execution of command handlers within the same transaction. Allow integration tests to roll back changes when the test ends. This might seem like a tall order and the solution might look a bit controversial, but bare with me on this one and you will see that the implementation is actually quite simple. Inserting data Before we start to think about transactions, we need something that writes to the database. A simple insert should do the trick. public class AddCustomerCommandHandler : ICommandHandler AddCustomerCommand { private readonly IDbConnection dbConnection; public AddCustomerCommandHandler(IDbConnection dbConnection) { this.dbConnection = dbConnection; } public async Task HandleAsync(AddCustomerCommand command) { await dbConnection.ExecuteAsync(SQL.InsertCustomer, command); } } The command handler takes care of executing a simple insert into the Customers table using the ExecuteAsync extension method provided by Dapper . The AddCustomerCommand is just a simple POCO class that contains the data to be inserted. public class AddCustomerCommand { public string CustomerId { get; set; } public string CompanyName { get; set; } } The SQL looks like this: INSERT INTO Customers (CustomerId, CompanyName) VALUES (@CustomerId, @CompanyName) Wrapping command handlers inside a transaction is just a matter of applying a simple decorator. public class TransactionalCommandHandler TCommand : ICommandHandler TCommand { private readonly IDbConnection dbConnection; private readonly ICommandHandler TCommand commandHandler; public TransactionalCommandHandler(IDbConnection dbConnection, ICommandHandler TCommand commandHandler) { this.dbConnection = dbConnection; this.commandHandler = commandHandler; } public async Task HandleAsync(TCommand command) { using (var transaction = dbConnection.BeginTransaction()) { await commandHandler.HandleAsync(command); transaction.Commit(); } } } With a single line of code in the composition root , we can now apply this decorator to all command handlers. serviceRegistry.Decorate(typeof(ICommandHandler ), typeof(TransactionalCommandHandler )); Multiple command handlers Within a single scope (web request), we might have to execute more than one command handler, either sequentially or nested within each other. Since we now have an all-purpose decorator ( TransactionalCommandHandler ) that starts a new transaction before each underlying command handler, we need to make sure that only one transaction exists within the scope (web request). We do this by implementing yet another decorator and this time a decorator for the IDbConnection interface. public class ConnectionDecorator : IDbConnection { private readonly IDbConnection dbConnection; private readonly Lazy TransactionDecorator dbTransaction; public ConnectionDecorator(IDbConnection dbConnection) { this.dbConnection = dbConnection; dbTransaction = new Lazy TransactionDecorator (() = new TransactionDecorator(this, dbConnection.BeginTransaction())); } public void Dispose() { if (dbTransaction.IsValueCreated) { dbTransaction.Value.EndTransaction(); } dbConnection.Dispose(); } public IDbTransaction BeginTransaction() { dbTransaction.Value.IncrementTransactionCount(); return dbTransaction.Value; } public IDbTransaction BeginTransaction(IsolationLevel il) { return BeginTransaction(); } public void Close() { dbConnection.Close(); } public void ChangeDatabase(string databaseName) { dbConnection.ChangeDatabase(databaseName); } public IDbCommand CreateCommand() { return dbConnection.CreateCommand(); } public void Open() { dbConnection.Open(); } public string ConnectionString { get { return dbConnection.ConnectionString; } set { dbConnection.ConnectionString = value; } } public int ConnectionTimeout { get { return dbConnection.ConnectionTimeout; } } public string Database { get { return dbConnection.Database; } } public ConnectionState State { get { return dbConnection.State; } } } Most of the methods and properties here just call into the underlying IDbConnection , except for the Dispose and BeginTransaction methods that we will explain in a minute. But first the code for the TransactionDecorator public class TransactionDecorator : IDbTransaction { private readonly IDbTransaction dbTransaction; private int transactionCount; private int commitCount; public TransactionDecorator(IDbConnection dbConnection, IDbTransaction dbTransaction) { Connection = dbConnection; this.dbTransaction = dbTransaction; } public void IncrementTransactionCount() { transactionCount++; } public void EndTransaction() { if (commitCount == transactionCount) { dbTransaction.Commit(); } else { dbTransaction.Rollback(); } dbTransaction.Dispose(); } public void Dispose() { } public virtual void Commit() { commitCount++; } public void Rollback() { } public IDbConnection Connection { get; } public IsolationLevel IsolationLevel = dbTransaction.IsolationLevel; } Okay, it is time to what is going on here. Hang on! When the BeginTransaction method is executed we create a new IDbTransaction and wraps that transaction inside a TransactionDecorator . This transaction is provided through a Lazy T that makes sure that we only create a single transaction no matter how many times the BeginTransaction method is called. We also increment the \" transactionCount \" which basically reflects the number of calls to the BeginTransaction method. The \" transactionCount \" is then used inside the EndTransaction method to decide if we should perform a commit or a rollback. The rule here is simple. In order for the transaction to be committed, we need the commitCount to be equal to the transactionCount . If they are not equal it means that a BeginTransaction was executed without a commit. In that case we do a rollback. The EndTransaction method is called from the Dispose method inside the the ConnectionDecorator that first checks if we actually have a transaction at all. If so, we execute the EndTransaction method and finally disposes the underlying connection. The connection is as mentioned before disposed when the scope (web request) ends because it is registered with the PerScopeLifetime . Plugging all this goodness into our code is a simple as serviceRegistry.Decorate IDbConnection, ConnectionDecorator (); We can now execute nested command handlers as well as command handlers sequentially and still have them operate within the same transaction that either gets committed or rolled back when the connection is disposed. Automatic rollback Integration tests that writes to the database should perform a rollback when the test ends. This is now just a matter of adding another decorator that simply executes a rollback rather than a commit. public class RollbackCommandHandler TCommand : ICommandHandler TCommand { private readonly IDbConnection dbConnection; private readonly ICommandHandler TCommand commandHandler; public RollbackCommandHandler(IDbConnection dbConnection, ICommandHandler TCommand commandHandler) { this.dbConnection = dbConnection; this.commandHandler = commandHandler; } public async Task HandleAsync(TCommand command) { using (var transaction = dbConnection.BeginTransaction()) { await commandHandler.HandleAsync(command); transaction.Rollback(); } } } This decorator only lives in the test project and we can apply the decorator by implementing a static Configure method in the test class. public static void Configure(IServiceContainer container) { container.RegisterFrom CompositionRoot (); container.Decorate(typeof(ICommandHandler ), typeof(RollbackCommandHandler )); } We can now finally write a test that verifies that a new customer has been written to the database. [Theory, Scoped, InjectData] public async Task ShouldAddCustomer(ICommandExecutor commandExecutor, IQueryExecutor queryExecutor) { await commandExecutor.ExecuteAsync(new AddCustomerCommand {CustomerId = AAPL , CompanyName = Apple Inc }); var newCustomer = await queryExecutor.ExecuteAsync(new CustomerQuery {CustomerId = AAPL }); Assert.Equal( Apple Inc , newCustomer.CompanyName); } Since the transaction is not ended until the test ends, we can still query the database for the newly inserted customer and verify that is was inserted. Testing Controllers Testing the public API in a Web API application means testing the controllers and by using the Microsoft.Owin.Testing package we can create an in-memory server that lets us test our Owin based web application end to end. Lets just quickly take a look at the controller we are going to test. public class CustomersController : ApiController { private readonly IQueryExecutor queryExecutor; public CustomersController(IQueryExecutor queryExecutor) { this.queryExecutor = queryExecutor; } public async Task IHttpActionResult Get(string country) { var customers = await queryExecutor.ExecuteAsync(new CustomersQuery {Country = country}); return Ok(customers); } } A typical test for this controller would look like this. [Fact] public async Task ShouldGetCustomersUsingTestServer() { using (var server = TestServer.Create Startup ()) { HttpClient client = server.HttpClient; HttpResponseMessage response = await client.GetAsync( api/customers?country=Germany ); string content = await response.Content.ReadAsStringAsync(); Customer[] customers = JsonConvert.DeserializeObject Customer[] (content); Assert.Equal(11, customers.Length); } } Let's create an extension method to help us shorten this code a bit. public static class HttpClientExtensions { public static async Task Response TResult GetAsync TResult (this HttpClient client, string requestUri) { var responseMessage = await client.GetAsync(requestUri).ConfigureAwait(false); Response TResult response = new Response TResult () {Message = responseMessage}; if (responseMessage.IsSuccessStatusCode) { var content = await responseMessage.Content.ReadAsStringAsync().ConfigureAwait(false); response.Value = JsonConvert.DeserializeObject TResult (content); } return response; } } This extension method returns the response as a Response T that contains the HttpResponseMessage and the typed result object. This means that we can do asserts on the actual result in addition to data related to the request such as the HttpStatusCode . [Fact] public async Task ShouldGetCustomersUsingExtensionMethod() { using (var server = TestServer.Create Startup ()) { HttpClient client = server.HttpClient; var response = await client.GetAsync Customer[] ( api/customers?country=Germany ); Assert.Equal(11, response.Value.Length); } } The nice thing about the TestServer is that it allows us to pass the Startup class to be used for the test. This means that we can pass a startup class that might be specific to the test. The startup class for this application looks like this. public class Startup { public Startup() { Container = new ServiceContainer(); } public void Configuration(IAppBuilder app) { var config = new HttpConfiguration(); Configure(Container); ConfigureMediaFormatter(config); ConfigureHttpRoutes(config); Container.RegisterApiControllers(); Container.EnableWebApi(config); app.UseWebApi(config); } private static void ConfigureMediaFormatter(HttpConfiguration configuration) { configuration.Formatters.Clear(); configuration.Formatters.Add(new JsonMediaTypeFormatter()); } private static void ConfigureHttpRoutes(HttpConfiguration config) { config.Routes.MapHttpRoute( name: API Default , routeTemplate: api/{controller}/{id} , defaults: new { id = RouteParameter.Optional }); } public virtual void Configure(IServiceContainer serviceContainer) { serviceContainer.RegisterFrom CompositionRoot (); } public IServiceContainer Container { get; } } The thing to notice here is that we have a virtual Configure method that makes it possible to inherit from this class in a test project and override the way we configure the container. We also expose the container used by Web Api so that we can get access to it in an inherited startup class. The next class is a base class for testing controllers that makes it possible to specify the startup class type as a generic argument to the class itself. public abstract class ControllerTestBase TStartup where TStartup : Startup, new() { public static void Configure(IServiceContainer container) { var startup = new TStartup(); container.Register(factory = TestServer.Create(builder = startup.Configuration(builder)), new PerScopeLifetime()); container.Register(CreateHttpClient); } private static HttpClient CreateHttpClient(IServiceFactory container) { var testServer = container.GetInstance TestServer (); var httpClient = new HttpClient(testServer.Handler); httpClient.BaseAddress = testServer.BaseAddress; return httpClient; } } This base class now makes it possible to specify the startup class and it also allows us to inject the HttpClient instance. public class ControllerTests : ControllerTestBase Startup { [Theory, Scoped, InjectData] public async Task ShouldGetCustomersUsingInjectedClient(HttpClient client) { var response = await client.GetAsync Customer[] ( api/customers?country=Germany ); Assert.Equal(11, response.Value.Length); } } Being good REST citizens, we should also make sure that we return the correct status code along with the content. Say now that we want to test that the service returns 204-NoContent if no customers are found for the given country. We could do this by making sure that we have the appropriate test data in the database or we could mock the IQueryExecutor and have it return an empty list without even touching the database. By extending the HttpClient we can really simplify the way to mock services used in the test. public class TestClient : HttpClient { private readonly IServiceRegistry serviceRegistry; public TestClient(IServiceRegistry serviceRegistry, HttpMessageHandler handler) : base(handler) { this.serviceRegistry = serviceRegistry; } public Mock TService Mock TService () where TService:class { var mock = new Mock TService (); serviceRegistry.Override(registration = registration.ServiceType == typeof(TService), (factory, registration) = CreateMockRegistration(mock)); return mock; } private static ServiceRegistration CreateMockRegistration TService (Mock TService mock) where TService:class { return new ServiceRegistration() {ServiceType = typeof(TService), Value = mock.Object }; } } This class basically replaces the existing IQueryExecutor registration with a mock instance and makes it possible to mock services very easily. [Theory, Scoped, InjectData] public async Task ShouldReturnNoContent(TestClient client) { var mock = client.Mock IQueryExecutor (); mock.Setup(m = m.ExecuteAsync(It.IsAny IQuery Customer[] ())).ReturnsAsync(new Customer[] {}); var response = await client.GetAsync Customer[] ( api/customers?country=Germany ); Assert.Equal(HttpStatusCode.NoContent, response.Message.StatusCode); }","title":"Transactions and Testing"},{"location":"transactions/#transaction-management","text":"In this example we will be looking into how to deal with connections and transactions in a Web application. We will also discuss how to implement automatic rollback for integration tests. Our testing framework will be xUnit and together with LightInject this will hopefully turn into a very smooth testing experience.","title":"Transaction Management"},{"location":"transactions/#commands-and-queries","text":"There are many ways to manage the interaction with the database and in this application we are going to implement something that has come to be known as the Command-Query pattern. The basic idea here is that we have one interface ( IQueryHandler ) for everything that comes out of the database and another interface ( ICommandHandler )for everything that goes into the database. The fact that we are dealing with the same set of interfaces for all interaction with the database means that we can very easily add features through the use of decorators. I am not going to cover everything with regards to command and queries here, but we will look into the interfaces we need to implement in order to shuffle data back and forth to the database.","title":"Commands and Queries"},{"location":"transactions/#queries","text":"The following interface represents a class that can handle a query and return some kind of result. public interface IQueryHandler in TQuery, TResult where TQuery : IQuery TResult { Task TResult HandleAsync(TQuery query); } You might wonder about the IQuery TResult generic contraint. This is just an interface to give type inference a helping hand as we move on to the next interface. The IQueryExecutor represents a class that can execute any query. public interface IQueryExecutor { Task TResult ExecuteAsync TResult (IQuery TResult query); } This is where the IQuery TResult generic contraint comes into play. Without the contraint we would have to specify the type of result when calling the ExecuteAsync method. var result = queryExecutor.ExecuteAsync SomeResultType (somequery); With the query class \"implementing\" the IQuery TResult interface we can instead do this var result = queryExecutor.ExecuteAsync(somequery);","title":"Queries"},{"location":"transactions/#commands","text":"The following interface represents a class that can handle a command where the command can be any class. public interface ICommandHandler in TCommand { Task HandleAsync(TCommand command); } Will be seeing examples of both queries and commands throughout this example.","title":"Commands"},{"location":"transactions/#why-not-an-orm","text":"The best answer I can give you is that I have already been there and felt the pain that eventually comes sneaking upon you. A little at first and then more and more as things gets more complicated. In fact, I have actually written an inhouse ORM back in the days and writing a Linq provider for instance, certainly represents the Mount Everest of programming. Not because Linq is so hard, but because you have to deal with all the mismatches between the relational model and the object model. ORM's tries to free you from understanding SQL and it is such a failed abstraction. Eventually at some point, you find yourself in a situation where you are trying to come up with a Linq expression that generates the SQL you've already written. Bottom line, bite the bullet and learn SQL.","title":"Why not an ORM?"},{"location":"transactions/#customers","text":"The first task is to create a query handler that can retrieve customers from the database based on their origin (country). The SQL for ths look like this: SELECT CustomerId, CompanyName FROM Customers WHERE Country = @Country; With the SQL in place, we are ready to implement the query handler. public class CustomersQueryHandler : IQueryHandler CustomersQuery, Customer[] { private readonly IDbConnection dbConnection; public CustomersQueryHandler(IDbConnection dbConnection) { this.dbConnection = dbConnection; } public async Task Customer[] HandleAsync(CustomersQuery query) { var result = await dbConnection.QueryAsync CustomerRow (SQL.CustomersByCountry, query); return result.ToArray(); } } Note: Query and command handlers does not dictate that the data is stored in a relational database. It might just as well be stored in a file or another type of database such as a document database. This query handler has just one dependency, the IDbConnection off which Dapper provides the QueryAsync method used to execute the query. The query ( CustomersQuery ) looks like this public class CustomersQuery : IQuery Customer[] { public string Country { get; set; } }","title":"Customers"},{"location":"transactions/#passing-data-through-layers","text":"Okay, so we have our application that consists of different layers. Data Access Layer (query and command handlers) Business Layer (services using the data access layer) Public API (typically a REST based API using services from the business layer)","title":"Passing data through layers"},{"location":"transactions/#data-access-layer","text":"This is where we actually interact with the underlying data store which for most applications even today means a relational database. These databases store relational data and is not very well suited for storing objects and we should treat the database accordingly. Relational databases does not store objects, they store rows of data. This is why we represent the result from Dapper as a set of CustomerRow instances.","title":"Data Access Layer"},{"location":"transactions/#business-layer","text":"This layer consists of the services that in turn will be using the data access layer. This is also the place to put any kind of business logic related to our services. By mocking the data access layer we can test this functionality without hitting the database.","title":"Business Layer"},{"location":"transactions/#api-layer","text":"This is our public API which in this sample application is exposed as a RESTful API using Web Api. Try to keep this layer as thin as possible. It should not deal with any kind of business logic, but it should for instance deal with making sure that we return the correct status codes according to REST best practices. So should each layer have its own representation of the same data? My answer is this: Be pragmatic about this. If the representation looks identical throughout the various layers, you might as well reuse the same class for different layers. Once you need to add JsonIgnore attributes to ensure that database-only properties does not get exposed in the Web API, you might consider another representation. It is also likely that the representations for reading and writing will differ so there is a lot to consider her. There is also a performance penalty involved here since we need to constantly map the \"same\" data between layers. There might also be situations where the service layer just acts as a pass-t through layer and it that case it might be just fine to use the query/command handlers directly in our controllers.","title":"API Layer"},{"location":"transactions/#composition-root","text":"The composition root is where we register services into the container. serviceRegistry.Register IQueryExecutor, QueryExecutor (new PerContainerLifetime()); serviceRegistry.RegisterQueryHandlers(); // We register the connection that it is disposed when the scope ends. // The scope here is per web request. serviceRegistry.Register(factory = CreateConnection(), new PerScopeLifetime()); We register the IDbConnection with the PerScopeLifetime which means that we get the same connection within a scope. The scope is usually per web request, but it can also be per test method as we will see in a minute. This is actually a nice aspect of the scoping mechanism in LightInject. We tell a service to be per scope without providing any details about how the scope is started or ended.","title":"Composition Root"},{"location":"transactions/#testing-query-handlers","text":"Before we dive into how to handle transactions, we are going to look at how to test our new query handler. LightInject provides an extension( LightInject.xUnit ) that makes it possible to inject services into test methods. [Theory, Scoped, InjectData] public async Task ShouldGetCustomersFromGermany(IQueryExecutor queryExecutor) { var query = new CustomersQuery {Country = Germany }; var result = await queryExecutor.ExecuteAsync(query); Assert.Equal(11, result.Length); } The Scoped attribute tells LightInject to wrap a scope around this test method. When the test method ends, the scope will end as well and that will in turn cause the IDbConnection to be disposed since that service is registered with the PerScopeLifetime . The InjectData attribute simply tells LightInject to inject method arguments and can be thought off as a more sophisticated version of the InlineData attribute usually seen in xUnit theory based tests. LightInject.xUnit creates a container instance behind the scenes and uses that instance to inject services into the test methods. The default behavior in LightInject is to look for composition roots in the same assembly as the requested service. This is part of the fallback mechanism and means that we don't really need to explicitly configure the container in the test class although it is possible to do so by declaring the following static method. public static void Configure(IServiceContainer container) { container.RegisterFrom CompositionRoot (); } We can also use the InjectData attribute so specify inline data in addition to the service being injected. [Theory, Scoped] [InjectData( France , 11)] [InjectData( Germany , 11)] [InjectData( Norway , 1)] public async Task ShouldGetCustomers(IQueryExecutor queryExecutor, string country, int expectedCount) { var result = await queryExecutor.ExecuteAsync(new CustomersQuery() { Country = country }); Assert.Equal(expectedCount, result.Length); }","title":"Testing query handlers"},{"location":"transactions/#transactions","text":"We are going to build upon the standard IDbConnection and IDbTransaction interfaces and provide a way to transparently apply transactions to command handlers. Requirements: Transactions should as short lived as possible. Only one transaction per scope (web request) Support sequential and nested execution of command handlers within the same transaction. Allow integration tests to roll back changes when the test ends. This might seem like a tall order and the solution might look a bit controversial, but bare with me on this one and you will see that the implementation is actually quite simple.","title":"Transactions"},{"location":"transactions/#inserting-data","text":"Before we start to think about transactions, we need something that writes to the database. A simple insert should do the trick. public class AddCustomerCommandHandler : ICommandHandler AddCustomerCommand { private readonly IDbConnection dbConnection; public AddCustomerCommandHandler(IDbConnection dbConnection) { this.dbConnection = dbConnection; } public async Task HandleAsync(AddCustomerCommand command) { await dbConnection.ExecuteAsync(SQL.InsertCustomer, command); } } The command handler takes care of executing a simple insert into the Customers table using the ExecuteAsync extension method provided by Dapper . The AddCustomerCommand is just a simple POCO class that contains the data to be inserted. public class AddCustomerCommand { public string CustomerId { get; set; } public string CompanyName { get; set; } } The SQL looks like this: INSERT INTO Customers (CustomerId, CompanyName) VALUES (@CustomerId, @CompanyName) Wrapping command handlers inside a transaction is just a matter of applying a simple decorator. public class TransactionalCommandHandler TCommand : ICommandHandler TCommand { private readonly IDbConnection dbConnection; private readonly ICommandHandler TCommand commandHandler; public TransactionalCommandHandler(IDbConnection dbConnection, ICommandHandler TCommand commandHandler) { this.dbConnection = dbConnection; this.commandHandler = commandHandler; } public async Task HandleAsync(TCommand command) { using (var transaction = dbConnection.BeginTransaction()) { await commandHandler.HandleAsync(command); transaction.Commit(); } } } With a single line of code in the composition root , we can now apply this decorator to all command handlers. serviceRegistry.Decorate(typeof(ICommandHandler ), typeof(TransactionalCommandHandler ));","title":"Inserting data"},{"location":"transactions/#multiple-command-handlers","text":"Within a single scope (web request), we might have to execute more than one command handler, either sequentially or nested within each other. Since we now have an all-purpose decorator ( TransactionalCommandHandler ) that starts a new transaction before each underlying command handler, we need to make sure that only one transaction exists within the scope (web request). We do this by implementing yet another decorator and this time a decorator for the IDbConnection interface. public class ConnectionDecorator : IDbConnection { private readonly IDbConnection dbConnection; private readonly Lazy TransactionDecorator dbTransaction; public ConnectionDecorator(IDbConnection dbConnection) { this.dbConnection = dbConnection; dbTransaction = new Lazy TransactionDecorator (() = new TransactionDecorator(this, dbConnection.BeginTransaction())); } public void Dispose() { if (dbTransaction.IsValueCreated) { dbTransaction.Value.EndTransaction(); } dbConnection.Dispose(); } public IDbTransaction BeginTransaction() { dbTransaction.Value.IncrementTransactionCount(); return dbTransaction.Value; } public IDbTransaction BeginTransaction(IsolationLevel il) { return BeginTransaction(); } public void Close() { dbConnection.Close(); } public void ChangeDatabase(string databaseName) { dbConnection.ChangeDatabase(databaseName); } public IDbCommand CreateCommand() { return dbConnection.CreateCommand(); } public void Open() { dbConnection.Open(); } public string ConnectionString { get { return dbConnection.ConnectionString; } set { dbConnection.ConnectionString = value; } } public int ConnectionTimeout { get { return dbConnection.ConnectionTimeout; } } public string Database { get { return dbConnection.Database; } } public ConnectionState State { get { return dbConnection.State; } } } Most of the methods and properties here just call into the underlying IDbConnection , except for the Dispose and BeginTransaction methods that we will explain in a minute. But first the code for the TransactionDecorator public class TransactionDecorator : IDbTransaction { private readonly IDbTransaction dbTransaction; private int transactionCount; private int commitCount; public TransactionDecorator(IDbConnection dbConnection, IDbTransaction dbTransaction) { Connection = dbConnection; this.dbTransaction = dbTransaction; } public void IncrementTransactionCount() { transactionCount++; } public void EndTransaction() { if (commitCount == transactionCount) { dbTransaction.Commit(); } else { dbTransaction.Rollback(); } dbTransaction.Dispose(); } public void Dispose() { } public virtual void Commit() { commitCount++; } public void Rollback() { } public IDbConnection Connection { get; } public IsolationLevel IsolationLevel = dbTransaction.IsolationLevel; } Okay, it is time to what is going on here. Hang on! When the BeginTransaction method is executed we create a new IDbTransaction and wraps that transaction inside a TransactionDecorator . This transaction is provided through a Lazy T that makes sure that we only create a single transaction no matter how many times the BeginTransaction method is called. We also increment the \" transactionCount \" which basically reflects the number of calls to the BeginTransaction method. The \" transactionCount \" is then used inside the EndTransaction method to decide if we should perform a commit or a rollback. The rule here is simple. In order for the transaction to be committed, we need the commitCount to be equal to the transactionCount . If they are not equal it means that a BeginTransaction was executed without a commit. In that case we do a rollback. The EndTransaction method is called from the Dispose method inside the the ConnectionDecorator that first checks if we actually have a transaction at all. If so, we execute the EndTransaction method and finally disposes the underlying connection. The connection is as mentioned before disposed when the scope (web request) ends because it is registered with the PerScopeLifetime . Plugging all this goodness into our code is a simple as serviceRegistry.Decorate IDbConnection, ConnectionDecorator (); We can now execute nested command handlers as well as command handlers sequentially and still have them operate within the same transaction that either gets committed or rolled back when the connection is disposed.","title":"Multiple command handlers"},{"location":"transactions/#automatic-rollback","text":"Integration tests that writes to the database should perform a rollback when the test ends. This is now just a matter of adding another decorator that simply executes a rollback rather than a commit. public class RollbackCommandHandler TCommand : ICommandHandler TCommand { private readonly IDbConnection dbConnection; private readonly ICommandHandler TCommand commandHandler; public RollbackCommandHandler(IDbConnection dbConnection, ICommandHandler TCommand commandHandler) { this.dbConnection = dbConnection; this.commandHandler = commandHandler; } public async Task HandleAsync(TCommand command) { using (var transaction = dbConnection.BeginTransaction()) { await commandHandler.HandleAsync(command); transaction.Rollback(); } } } This decorator only lives in the test project and we can apply the decorator by implementing a static Configure method in the test class. public static void Configure(IServiceContainer container) { container.RegisterFrom CompositionRoot (); container.Decorate(typeof(ICommandHandler ), typeof(RollbackCommandHandler )); } We can now finally write a test that verifies that a new customer has been written to the database. [Theory, Scoped, InjectData] public async Task ShouldAddCustomer(ICommandExecutor commandExecutor, IQueryExecutor queryExecutor) { await commandExecutor.ExecuteAsync(new AddCustomerCommand {CustomerId = AAPL , CompanyName = Apple Inc }); var newCustomer = await queryExecutor.ExecuteAsync(new CustomerQuery {CustomerId = AAPL }); Assert.Equal( Apple Inc , newCustomer.CompanyName); } Since the transaction is not ended until the test ends, we can still query the database for the newly inserted customer and verify that is was inserted.","title":"Automatic rollback"},{"location":"transactions/#testing-controllers","text":"Testing the public API in a Web API application means testing the controllers and by using the Microsoft.Owin.Testing package we can create an in-memory server that lets us test our Owin based web application end to end. Lets just quickly take a look at the controller we are going to test. public class CustomersController : ApiController { private readonly IQueryExecutor queryExecutor; public CustomersController(IQueryExecutor queryExecutor) { this.queryExecutor = queryExecutor; } public async Task IHttpActionResult Get(string country) { var customers = await queryExecutor.ExecuteAsync(new CustomersQuery {Country = country}); return Ok(customers); } } A typical test for this controller would look like this. [Fact] public async Task ShouldGetCustomersUsingTestServer() { using (var server = TestServer.Create Startup ()) { HttpClient client = server.HttpClient; HttpResponseMessage response = await client.GetAsync( api/customers?country=Germany ); string content = await response.Content.ReadAsStringAsync(); Customer[] customers = JsonConvert.DeserializeObject Customer[] (content); Assert.Equal(11, customers.Length); } } Let's create an extension method to help us shorten this code a bit. public static class HttpClientExtensions { public static async Task Response TResult GetAsync TResult (this HttpClient client, string requestUri) { var responseMessage = await client.GetAsync(requestUri).ConfigureAwait(false); Response TResult response = new Response TResult () {Message = responseMessage}; if (responseMessage.IsSuccessStatusCode) { var content = await responseMessage.Content.ReadAsStringAsync().ConfigureAwait(false); response.Value = JsonConvert.DeserializeObject TResult (content); } return response; } } This extension method returns the response as a Response T that contains the HttpResponseMessage and the typed result object. This means that we can do asserts on the actual result in addition to data related to the request such as the HttpStatusCode . [Fact] public async Task ShouldGetCustomersUsingExtensionMethod() { using (var server = TestServer.Create Startup ()) { HttpClient client = server.HttpClient; var response = await client.GetAsync Customer[] ( api/customers?country=Germany ); Assert.Equal(11, response.Value.Length); } } The nice thing about the TestServer is that it allows us to pass the Startup class to be used for the test. This means that we can pass a startup class that might be specific to the test. The startup class for this application looks like this. public class Startup { public Startup() { Container = new ServiceContainer(); } public void Configuration(IAppBuilder app) { var config = new HttpConfiguration(); Configure(Container); ConfigureMediaFormatter(config); ConfigureHttpRoutes(config); Container.RegisterApiControllers(); Container.EnableWebApi(config); app.UseWebApi(config); } private static void ConfigureMediaFormatter(HttpConfiguration configuration) { configuration.Formatters.Clear(); configuration.Formatters.Add(new JsonMediaTypeFormatter()); } private static void ConfigureHttpRoutes(HttpConfiguration config) { config.Routes.MapHttpRoute( name: API Default , routeTemplate: api/{controller}/{id} , defaults: new { id = RouteParameter.Optional }); } public virtual void Configure(IServiceContainer serviceContainer) { serviceContainer.RegisterFrom CompositionRoot (); } public IServiceContainer Container { get; } } The thing to notice here is that we have a virtual Configure method that makes it possible to inherit from this class in a test project and override the way we configure the container. We also expose the container used by Web Api so that we can get access to it in an inherited startup class. The next class is a base class for testing controllers that makes it possible to specify the startup class type as a generic argument to the class itself. public abstract class ControllerTestBase TStartup where TStartup : Startup, new() { public static void Configure(IServiceContainer container) { var startup = new TStartup(); container.Register(factory = TestServer.Create(builder = startup.Configuration(builder)), new PerScopeLifetime()); container.Register(CreateHttpClient); } private static HttpClient CreateHttpClient(IServiceFactory container) { var testServer = container.GetInstance TestServer (); var httpClient = new HttpClient(testServer.Handler); httpClient.BaseAddress = testServer.BaseAddress; return httpClient; } } This base class now makes it possible to specify the startup class and it also allows us to inject the HttpClient instance. public class ControllerTests : ControllerTestBase Startup { [Theory, Scoped, InjectData] public async Task ShouldGetCustomersUsingInjectedClient(HttpClient client) { var response = await client.GetAsync Customer[] ( api/customers?country=Germany ); Assert.Equal(11, response.Value.Length); } } Being good REST citizens, we should also make sure that we return the correct status code along with the content. Say now that we want to test that the service returns 204-NoContent if no customers are found for the given country. We could do this by making sure that we have the appropriate test data in the database or we could mock the IQueryExecutor and have it return an empty list without even touching the database. By extending the HttpClient we can really simplify the way to mock services used in the test. public class TestClient : HttpClient { private readonly IServiceRegistry serviceRegistry; public TestClient(IServiceRegistry serviceRegistry, HttpMessageHandler handler) : base(handler) { this.serviceRegistry = serviceRegistry; } public Mock TService Mock TService () where TService:class { var mock = new Mock TService (); serviceRegistry.Override(registration = registration.ServiceType == typeof(TService), (factory, registration) = CreateMockRegistration(mock)); return mock; } private static ServiceRegistration CreateMockRegistration TService (Mock TService mock) where TService:class { return new ServiceRegistration() {ServiceType = typeof(TService), Value = mock.Object }; } } This class basically replaces the existing IQueryExecutor registration with a mock instance and makes it possible to mock services very easily. [Theory, Scoped, InjectData] public async Task ShouldReturnNoContent(TestClient client) { var mock = client.Mock IQueryExecutor (); mock.Setup(m = m.ExecuteAsync(It.IsAny IQuery Customer[] ())).ReturnsAsync(new Customer[] {}); var response = await client.GetAsync Customer[] ( api/customers?country=Germany ); Assert.Equal(HttpStatusCode.NoContent, response.Message.StatusCode); }","title":"Testing Controllers"},{"location":"wcf/","text":"WCF LightInject.Wcf provides an integration that enables dependency injection in WCF applications. Installing PM Install-Package LightInject.Wcf This adds a reference to the LightInject.Wcf.dll in the target project. Getting started LightInject.Wcf aims to provide a zero config approach to developing WCF services in addition to support both constructor and property injection for WCF service implementations. Note: If a Web site is precompiled for deployment, content provided by a VirtualPathProvider instance is not compiled, and no VirtualPathProviderinstances are used by the precompiled site. The easiest way to create a new WCF application is to start with a new empty web application and then install the LightInject.Wcf package. Our first service might look something like this: [ServiceContract] public interface IService { [OperationContract] int GetValue(int value); } public class Service : IService { public int GetValue(int value) { return value; } } The only thing we need to do is to create an ICompositionRoot implementation that registers our services and potentially its dependencies. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register IService, Service (); } } That's it. No XML config, no .svc files, just press F5 to run the application. Given that our service is defined in the SampleWcfApplication namespace, the service will be available at http://localhost:xxxxx/SampleWcfApplication.IService.svc Named Services If we want to identify our service by something else than the full type name of the service interface, we need to register the service using a name. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register IService, Service (\"MyService\"); } } Now we need one additional class to bootstrap the container so that the service is registered with the correct name before the service is invoked. [assembly: System.Web.PreApplicationStartMethod(typeof(SampleWcfApplication.Startup), \"Initialize\")] namespace SampleWcfApplication { using LightInject; using LightInject.Wcf; public class Startup { public static void Initialize() { var container = new ServiceContainer(); container.RegisterFrom CompositionRoot (); LightInjectServiceHostFactory.Container = container; } } } Behaviors While it still is possible to configure endpoint and service behaviors using XML, LightInject.Wcf allows for IEndpointBehavior and IServiceBehavior implementations to be registered with the container so that they can be applied to the service. public class SampleServiceBehavior : IServiceBehavior { public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) { } public void AddBindingParameters( ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection ServiceEndpoint endpoints, BindingParameterCollection bindingParameters) { } public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) { } } public class SampleEndpointBehavior : IEndpointBehavior { public void Validate(ServiceEndpoint endpoint) { } public void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters) { } public void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher) { } public void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime) { } } In order to configure these endpoints we can simply register them with the container. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register IService, Service (); serviceRegistry.Register IServiceBehavior, SampleServiceBehavior (); serviceRegistry.Register IEndpointBehavior, SampleEndpointBehavior (); } }","title":"WCF"},{"location":"wcf/#wcf","text":"LightInject.Wcf provides an integration that enables dependency injection in WCF applications.","title":"WCF"},{"location":"wcf/#installing","text":"PM Install-Package LightInject.Wcf This adds a reference to the LightInject.Wcf.dll in the target project.","title":"Installing"},{"location":"wcf/#getting-started","text":"LightInject.Wcf aims to provide a zero config approach to developing WCF services in addition to support both constructor and property injection for WCF service implementations. Note: If a Web site is precompiled for deployment, content provided by a VirtualPathProvider instance is not compiled, and no VirtualPathProviderinstances are used by the precompiled site. The easiest way to create a new WCF application is to start with a new empty web application and then install the LightInject.Wcf package. Our first service might look something like this: [ServiceContract] public interface IService { [OperationContract] int GetValue(int value); } public class Service : IService { public int GetValue(int value) { return value; } } The only thing we need to do is to create an ICompositionRoot implementation that registers our services and potentially its dependencies. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register IService, Service (); } } That's it. No XML config, no .svc files, just press F5 to run the application. Given that our service is defined in the SampleWcfApplication namespace, the service will be available at http://localhost:xxxxx/SampleWcfApplication.IService.svc","title":"Getting started"},{"location":"wcf/#named-services","text":"If we want to identify our service by something else than the full type name of the service interface, we need to register the service using a name. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register IService, Service (\"MyService\"); } } Now we need one additional class to bootstrap the container so that the service is registered with the correct name before the service is invoked. [assembly: System.Web.PreApplicationStartMethod(typeof(SampleWcfApplication.Startup), \"Initialize\")] namespace SampleWcfApplication { using LightInject; using LightInject.Wcf; public class Startup { public static void Initialize() { var container = new ServiceContainer(); container.RegisterFrom CompositionRoot (); LightInjectServiceHostFactory.Container = container; } } }","title":"Named Services"},{"location":"wcf/#behaviors","text":"While it still is possible to configure endpoint and service behaviors using XML, LightInject.Wcf allows for IEndpointBehavior and IServiceBehavior implementations to be registered with the container so that they can be applied to the service. public class SampleServiceBehavior : IServiceBehavior { public void Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) { } public void AddBindingParameters( ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection ServiceEndpoint endpoints, BindingParameterCollection bindingParameters) { } public void ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase) { } } public class SampleEndpointBehavior : IEndpointBehavior { public void Validate(ServiceEndpoint endpoint) { } public void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters) { } public void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher) { } public void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime) { } } In order to configure these endpoints we can simply register them with the container. public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register IService, Service (); serviceRegistry.Register IServiceBehavior, SampleServiceBehavior (); serviceRegistry.Register IEndpointBehavior, SampleEndpointBehavior (); } }","title":"Behaviors"},{"location":"web/","text":"Web Enables LightInject to be used in a web application and provides support for PerWebRequest scoped service instances. Installing LightInject.Web provides two distribution models via NuGet Binary PM Install-Package LightInject.Web This adds a reference to the LightInject.Web.dll in the target project. Source PM Install-Package LightInject.Web.Source This will install a single file (LightInject.Web.cs) into the current project. The following example shows how to enable LightInject in the Application_Start event. protected void Application_Start() { var container = new ServiceContainer(); container.EnablePerWebRequestScope(); container.Register IFoo, Foo (new PerScopeLifetime()); } A service registered with PerScopeLifetime is scoped per web request and is disposed at the end of the request if it implements IDisposable .","title":"Web"},{"location":"web/#web","text":"Enables LightInject to be used in a web application and provides support for PerWebRequest scoped service instances.","title":"Web"},{"location":"web/#installing","text":"LightInject.Web provides two distribution models via NuGet","title":"Installing"},{"location":"web/#binary","text":"PM Install-Package LightInject.Web This adds a reference to the LightInject.Web.dll in the target project.","title":"Binary"},{"location":"web/#source","text":"PM Install-Package LightInject.Web.Source This will install a single file (LightInject.Web.cs) into the current project. The following example shows how to enable LightInject in the Application_Start event. protected void Application_Start() { var container = new ServiceContainer(); container.EnablePerWebRequestScope(); container.Register IFoo, Foo (new PerScopeLifetime()); } A service registered with PerScopeLifetime is scoped per web request and is disposed at the end of the request if it implements IDisposable .","title":"Source"},{"location":"webapi/","text":"Web API LightInject.WebApi provides an integration that enables dependency injection in Web API applications. Installing LightInject.WebApi provides two distribution models via NuGet Binary PM Install-Package LightInject.WebApi This adds a reference to the LightInject.WebApi.dll in the target project. Source PM Install-Package LightInject.WebApi.Source This will install a single file, LightInject.WebApi.cs in the target project. Initializing protected void Application_Start() { var container = new ServiceContainer(); container.RegisterApiControllers(); //register other services container.EnablePerWebRequestScope(); container.EnableWebApi(GlobalConfiguration.Configuration) } Note: EnablePerWebRequestScope is only required for hosting within ASP.Net FilterAttribute Although filter attributes are instantiated by the MFC infrastructure, LightInject is still able to inject dependencies into properties. public class FooFilterAttribute : ActionFilterAttribute { public IFoo Foo { get; set; } } Owin Selfhosting This example shows how to do Web API self hosting using OWIN. Step 1 Create a standard console application and run the following command from the package manager console. PM Install-Package Microsoft.AspNet.WebApi.OwinSelfHost Step 2 Add a OWIN startup class. public class Startup { public void Configuration(IAppBuilder app) { // Configure Web API for self-host. var config = new HttpConfiguration(); config.Routes.MapHttpRoute( name: DefaultApi , routeTemplate: api/{controller}/{id} , defaults: new { id = RouteParameter.Optional }); app.UseWebApi(config); } } ``` ### Step 3 ### Add a controller ```csharp public class ValuesController : ApiController { public IEnumerable string Get() { return new string[] { value1 , value2 }; } } Step 4 Modify the Main method to start the OWIN host. class Program { static void Main(string[] args) { // Start OWIN host using (WebApp.Start Startup ( http://localhost:9000/ )) { Console.ReadLine(); } Console.ReadLine(); } } Press F5 to run the application and browse to http://localhost:9000/api/values . Step 5 PM Install-Package LightInject.WebApi Modify the Startup class to enable LightInject to be used as the dependency resolver. public class Startup { public void Configuration(IAppBuilder app) { // Configure Web API for self-host. var config = new HttpConfiguration(); var container = new ServiceContainer(); container.RegisterApiControllers(); container.EnableWebApi(config); config.Routes.MapHttpRoute( name: DefaultApi , routeTemplate: api/{controller}/{id} , defaults: new { id = RouteParameter.Optional }); app.UseWebApi(config); } } Note: LightInject.Web can be uninstalled as it is not used in the self host scenario. Scoping Scopes are handled by Web API itself and services registered with the PerScopeLifetime or PerRequestLifetime are disposed when the web request ends. HttpRequestMessage The current HttpRequestMessage is available to us in the controllers as it is exposed through the Request property. To make the HttpRequestMessage available to other services we need to make some minor changes The following code will be included as part of the next version of LightInject.WebApi. The first thing we need is a handler that can keep track of the current HttpRequestMessage . internal class HttpRequestMessageHandler : DelegatingHandler { private LogicalThreadStorage HttpRequestMessageStorage messageStorage = new LogicalThreadStorage HttpRequestMessageStorage (() = new HttpRequestMessageStorage()); protected override Task HttpResponseMessage SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) { messageStorage.Value.Message = request; return base.SendAsync(request, cancellationToken); } public HttpRequestMessage GetCurrentMessage() { return messageStorage.Value.Message; } } The HttpRequestMessageStorage class is simply a \"holder\" class for the actual HttpRequestMessage . public class HttpRequestMessageStorage { public HttpRequestMessage Message { get; set; } } Next we modify the Startup class to support injection of a Func HttpRequestMessage . public class Startup { public void Configuration(IAppBuilder app) { // Configure Web API for self-host. var config = new HttpConfiguration(); var container = new ServiceContainer(); container.RegisterApiControllers(); container.EnableWebApi(config); container.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider(); var handler = new HttpRequestMessageHandler(); config.MessageHandlers.Insert(0, handler); container.Register Func HttpRequestMessage (factory = () = handler.GetCurrentMessage()); config.Routes.MapHttpRoute( name: DefaultApi , routeTemplate: api/{controller}/{id} , defaults: new { id = RouteParameter.Optional }); app.UseWebApi(config); } } Now, if we need access to the current HttpRequestMessage , we can just inject a function delegate. public class Foo { public Foo(Func HttpRequestMessage getCurrentRequestMessage) { var currentMessage = getCurrentRequestMessage(); } }","title":"Web Api"},{"location":"webapi/#web-api","text":"LightInject.WebApi provides an integration that enables dependency injection in Web API applications.","title":"Web API"},{"location":"webapi/#installing","text":"LightInject.WebApi provides two distribution models via NuGet","title":"Installing"},{"location":"webapi/#binary","text":"PM Install-Package LightInject.WebApi This adds a reference to the LightInject.WebApi.dll in the target project.","title":"Binary"},{"location":"webapi/#source","text":"PM Install-Package LightInject.WebApi.Source This will install a single file, LightInject.WebApi.cs in the target project.","title":"Source"},{"location":"webapi/#initializing","text":"protected void Application_Start() { var container = new ServiceContainer(); container.RegisterApiControllers(); //register other services container.EnablePerWebRequestScope(); container.EnableWebApi(GlobalConfiguration.Configuration) } Note: EnablePerWebRequestScope is only required for hosting within ASP.Net","title":"Initializing"},{"location":"webapi/#filterattribute","text":"Although filter attributes are instantiated by the MFC infrastructure, LightInject is still able to inject dependencies into properties. public class FooFilterAttribute : ActionFilterAttribute { public IFoo Foo { get; set; } }","title":"FilterAttribute"},{"location":"webapi/#owin-selfhosting","text":"This example shows how to do Web API self hosting using OWIN.","title":"Owin Selfhosting"},{"location":"webapi/#step-1","text":"Create a standard console application and run the following command from the package manager console. PM Install-Package Microsoft.AspNet.WebApi.OwinSelfHost","title":"Step 1"},{"location":"webapi/#step-2","text":"Add a OWIN startup class. public class Startup { public void Configuration(IAppBuilder app) { // Configure Web API for self-host. var config = new HttpConfiguration(); config.Routes.MapHttpRoute( name: DefaultApi , routeTemplate: api/{controller}/{id} , defaults: new { id = RouteParameter.Optional }); app.UseWebApi(config); } } ``` ### Step 3 ### Add a controller ```csharp public class ValuesController : ApiController { public IEnumerable string Get() { return new string[] { value1 , value2 }; } }","title":"Step 2"},{"location":"webapi/#step-4","text":"Modify the Main method to start the OWIN host. class Program { static void Main(string[] args) { // Start OWIN host using (WebApp.Start Startup ( http://localhost:9000/ )) { Console.ReadLine(); } Console.ReadLine(); } } Press F5 to run the application and browse to http://localhost:9000/api/values .","title":"Step 4"},{"location":"webapi/#step-5","text":"PM Install-Package LightInject.WebApi Modify the Startup class to enable LightInject to be used as the dependency resolver. public class Startup { public void Configuration(IAppBuilder app) { // Configure Web API for self-host. var config = new HttpConfiguration(); var container = new ServiceContainer(); container.RegisterApiControllers(); container.EnableWebApi(config); config.Routes.MapHttpRoute( name: DefaultApi , routeTemplate: api/{controller}/{id} , defaults: new { id = RouteParameter.Optional }); app.UseWebApi(config); } } Note: LightInject.Web can be uninstalled as it is not used in the self host scenario.","title":"Step 5"},{"location":"webapi/#scoping","text":"Scopes are handled by Web API itself and services registered with the PerScopeLifetime or PerRequestLifetime are disposed when the web request ends.","title":"Scoping"},{"location":"webapi/#httprequestmessage","text":"The current HttpRequestMessage is available to us in the controllers as it is exposed through the Request property. To make the HttpRequestMessage available to other services we need to make some minor changes The following code will be included as part of the next version of LightInject.WebApi. The first thing we need is a handler that can keep track of the current HttpRequestMessage . internal class HttpRequestMessageHandler : DelegatingHandler { private LogicalThreadStorage HttpRequestMessageStorage messageStorage = new LogicalThreadStorage HttpRequestMessageStorage (() = new HttpRequestMessageStorage()); protected override Task HttpResponseMessage SendAsync(HttpRequestMessage request, CancellationToken cancellationToken) { messageStorage.Value.Message = request; return base.SendAsync(request, cancellationToken); } public HttpRequestMessage GetCurrentMessage() { return messageStorage.Value.Message; } } The HttpRequestMessageStorage class is simply a \"holder\" class for the actual HttpRequestMessage . public class HttpRequestMessageStorage { public HttpRequestMessage Message { get; set; } } Next we modify the Startup class to support injection of a Func HttpRequestMessage . public class Startup { public void Configuration(IAppBuilder app) { // Configure Web API for self-host. var config = new HttpConfiguration(); var container = new ServiceContainer(); container.RegisterApiControllers(); container.EnableWebApi(config); container.ScopeManagerProvider = new PerLogicalCallContextScopeManagerProvider(); var handler = new HttpRequestMessageHandler(); config.MessageHandlers.Insert(0, handler); container.Register Func HttpRequestMessage (factory = () = handler.GetCurrentMessage()); config.Routes.MapHttpRoute( name: DefaultApi , routeTemplate: api/{controller}/{id} , defaults: new { id = RouteParameter.Optional }); app.UseWebApi(config); } } Now, if we need access to the current HttpRequestMessage , we can just inject a function delegate. public class Foo { public Foo(Func HttpRequestMessage getCurrentRequestMessage) { var currentMessage = getCurrentRequestMessage(); } }","title":"HttpRequestMessage"},{"location":"webapirequestlogging/","text":"Web Api Request Logging This post is going to show you how to use LightInject to enable logging in a Web Api application. We are going to look into how to preserve contextual information associated with the incoming request so that this information can be used for logging purposes. All this goodness is going to end up in a simple console application that shows how all the pieces fit together. Logging Since logging is a cross cutting concern and is to be found scattered all around in our application, it makes sense to create an abstraction so that we don't create a direct dependency on a particular logging framework. This abstraction is something that we should own rather than relying on third part abstraction such as Common Logging . Believe me, that is going to cause us nothing but pain as we would have to deal with different versions of a third party abstraction. Own you own abstraction! We start of with a simple interface that is going to be used for logging. public interface ILog { void Info(string message); void Debug(string message); void Error(string message, Exception exception = null); } This is the interface that we will be injection into controllers, services or any other class that requires logging. The actual implementation of this interface looks like this public class Log : ILog { private readonly Action string logDebug; private readonly Action string, Exception logError; private readonly Action string logInfo; public Log(Action string logInfo, Action string logDebug, Action string, Exception logError) { this.logInfo = logInfo; this.logDebug = logDebug; this.logError = logError; } public void Info(string message) { logInfo(message); } public void Debug(string message) { logDebug(message); } public void Error(string message, Exception exception = null) { logError(message, exception); } } The Log class is not tied to a specific logging framework and it just takes a set of action delegates that represents the three logging levels supported by our abstraction. To help us create a Log instance, we have this nice little interface. public interface ILogFactory { ILog GetLogger(Type type); } And since we are going to be using Log4Net in this sample application, we have an implementation called Log4NetLogFactory . public class Log4NetLogFactory : ILogFactory { public Log4NetLogFactory() { XmlConfigurator.Configure(); } public ILog GetLogger(Type type) { var logger = LogManager.GetLogger(type); return new Log(logger.Info, logger.Debug, logger.Error); } } Note: This is the ONLY place where we actually reference Log4Net. Composition root This application has two composition roots ( ICompositionRoot ), one that registers the core services ( CompositionRoot )and one that registers services related to Web Api ( WebApiCompositionRoot ). public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register ILogFactory, Log4NetLogFactory (new PerContainerLifetime()); serviceRegistry.Register Type, ILog ((factory, type) = factory.GetInstance ILogFactory ().GetLogger(type)); serviceRegistry.RegisterConstructorDependency( (factory, info) = factory.GetInstance Type, ILog (info.Member.DeclaringType)); } } The first service that we register is the ILogFactory that is responsible for creating an ILog instance based on a given type. Next, we register the ILog service with a factory delegate that calls into the already registered ILogFactory service Finally we tell the container using the RegisterConstructorDependency method that whenever it sees an ILog constructor dependency, it should provide an ILog instance based on the actual class that uses it. public class WebApiCompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.RegisterFrom CompositionRoot (); serviceRegistry.RegisterApiControllers(); } } The WebApiCompositionRoot registers core services in addition services related to Web Api which in this case means the controllers. Controllers This application has just one controller named PingController that is simply going to return the text \"pong\". public class PingController : ApiController { private readonly ILog log; public PingController(ILog log) { this.log = log; } public async Task IHttpActionResult Get() { log.Info( Ping start ); var result = Ok( Pong ); log.Info( Ping end ); return result; } } As we can see we are injecting an ILog instance into the controller. The Startup class for this application looks like this public class Startup { public void Configuration(IAppBuilder app) { var configuration = new HttpConfiguration(); ConfigureHttpRoutes(configuration); ConfigureMediaFormatter(configuration); var container = new ServiceContainer(); container.RegisterFrom WebApiCompositionRoot (); container.EnableWebApi(configuration); app.UseWebApi(configuration); } private static void ConfigureMediaFormatter(HttpConfiguration configuration) { configuration.Formatters.Clear(); configuration.Formatters.Add(new JsonMediaTypeFormatter()); } private static void ConfigureHttpRoutes(HttpConfiguration config) { config.Routes.MapHttpRoute( name: API Default , routeTemplate: api/{controller}/{id} , defaults: new { id = RouteParameter.Optional }); } } We can see all this in action just by running the application and hitting the service. http://localhost:8080/api/ping That should yield the following output in the console 2016-02-11 09:14:28.489 [INFO] 13 WebApiRequestLogging.PingController: Ping start 2016-02-11 09:14:28.603 [INFO] 6 WebApiRequestLogging.PingController: Ping end The Log4Net conversion pattern is like this (app.config) conversionPattern value= %date{yyyy-MM-dd HH:mm:ss.fff} [%level] %thread %logger: %message%newline / Request logging Sometimes it might be useful to log each request and maybe also the duration of the request. We start off with a simple class ( OwinMiddleware ) that logs the duration of the request. public class RequestLoggingMiddleware : OwinMiddleware { private readonly ILog log; public RequestLoggingMiddleware(OwinMiddleware next, ILog log) : base(next) { this.log = log; } public override async Task Invoke(IOwinContext context) { await Measure(context).ConfigureAwait(false);; } private async Task Measure(IOwinContext context) { var stopWath = Stopwatch.StartNew(); await Next.Invoke(context).ConfigureAwait(false); stopWath.Stop(); log.Info($ Request {context.Request.Uri.PathAndQuery} took {stopWath.ElapsedMilliseconds} ms ); } } In addition to this we need to add this new middleware to the Owin pipeline by adding this line to the Startup class. app.Use RequestLoggingMiddleware (container.GetInstance Type, ILog (typeof (RequestLogDecorator))); Note: The reason for using an OwinMiddleware instead of a DelegatingHandler is that the OwinMiddleware is not tied to Web Api in any way and can also be used in other frameworks that build upon the Owin stack. Console output should now be 2016-02-11 13:07:48.466 [INFO] 11 WebApiRequestLogging.RequestLoggingMiddleware: Request /api/ping took 4 ms Request Context In some situations it is useful to be able to associate all log entries with the current web request. This can be used for analyzing the log later in tools such as Splunk making it possible to see all log entries tied to any given request. We could make the IOwinContext available in the container so that it could be injected into any class that requires information about the current request. This would however mean that these classes would have to know about the IOwinContext which might not be the best solution. So let's start off simple by creating a class to hold the request identifier. public class RequestContext { public RequestContext(string id) { Id = id; } public string Id { get; } } Next we create another middleware class to set the request identifier. public class RequestContextMiddleware : OwinMiddleware { private static readonly AsyncLocal RequestContext RequestContextStorage = new AsyncLocal RequestContext (); public RequestContextMiddleware(OwinMiddleware next) : base(next) { } public override async Task Invoke(IOwinContext context) { RequestContextStorage.Value = new RequestContext(Guid.NewGuid().ToString()); await Next.Invoke(context); } public static RequestContext CurrentRequest = RequestContextStorage.Value; } The actual RequestContext uses the AsyncLocal T class to ensure that the context flows across await points. The AsyncLocal T class is sort of the async version of ThreadLocal T . You should NEVER rely on any kind of storage that is tied to a specific thread in an async environment. Then we need to add the RequestContextMiddleware to the Owin pipeline. app.Use RequestContextMiddleware (); We now have way to access the current RequestContext through the CurrentRequest property. Sweet. The only thing missing now is to register a function delegate that represent getting the current RequestContext . serviceRegistry.Register Func RequestContext (factory = (() = RequestContextMiddleware.CurrentRequest), new PerContainerLifetime()); The reason for injection a function delegate rather than just the RequestContext is that it might be used in services such as singletons that outlives the scope of a web request. By injecting the delegate that in turn gives us the RequestContext , we can be sure that it is valid. Decorators The requirement here is that if we are logging outside the context of a web request, such as in a unit test, we should just log without the request identifier, but if we log inside a web request (production or integration tests), we should add the request identifier to the message being logged. This is a perfect example of where we can apply the Decorator Pattern . This allows us to add new functionality to a service without touching the original implementation. Did I hear \"open-closed principle\", anyone? public class RequestLogDecorator : ILog { private readonly ILog log; private readonly Func RequestContext getRequestContext; public RequestLogDecorator(ILog log, Func RequestContext getRequestContext) { this.log = log; this.getRequestInfo = getRequestInfo; } public void Info(string message) { log.Info($ Request id: {getRequestContext().Id} {message} ); } public void Debug(string message) { log.Debug($ Request id: {getRequestContext().Id} {message} ); } public void Error(string message, Exception exception = null) { log.Error($ Request id: {getRequestContext().Id} {message} , exception); } } The decorator simply wraps the original ILog instance and applies the request identifier now returned from the getRequestContext delegate. Don't you just love the new string interpolation features? Note: If you are new to the decorator pattern, you can think of it as a Russian Doll where inside there is an exact identical doll wrapped by an outer doll. Decorators are first-class citizens in LightInject and applying a decorator is just a one-liner in the WepApiCompositionRoot class. serviceRegistry.Decorate ILog, RequestLogDecorator (); Since we only apply the decorator in the WepApiCompositionRoot class it will only be used in the context of a web request. To \"ensure\" that we don't always log on the same thread, we modify the PingController to inlude a delay. public async Task IHttpActionResult Get() { log.Info( Ping start ); //ConfigureAwait(false) to say that we don't care about synchronization context. await Task.Delay(100).ConfigureAwait(false); // We are probably on another thread here var result = Ok( Pong ); log.Info( Ping end ); return result; } Running the application and hitting the service should now yield the following output in the console 2016-02-11 20:40:30.994 [INFO] 12 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping start 2016-02-11 20:40:31.111 [INFO] 6 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping end 2016-02-11 20:40:31.205 [INFO] 6 WebApiRequestLogging.RequestLogDecorator: Request id: 91444099-72ad-488f-99d6-ab201f20531e Request /api/ping took 463 ms As we can see that even if we started and ended the request on two different threads, we still have the same request identifier. Happy logging!!","title":"Web Api Request Logging"},{"location":"webapirequestlogging/#web-api-request-logging","text":"This post is going to show you how to use LightInject to enable logging in a Web Api application. We are going to look into how to preserve contextual information associated with the incoming request so that this information can be used for logging purposes. All this goodness is going to end up in a simple console application that shows how all the pieces fit together.","title":"Web Api Request Logging"},{"location":"webapirequestlogging/#logging","text":"Since logging is a cross cutting concern and is to be found scattered all around in our application, it makes sense to create an abstraction so that we don't create a direct dependency on a particular logging framework. This abstraction is something that we should own rather than relying on third part abstraction such as Common Logging . Believe me, that is going to cause us nothing but pain as we would have to deal with different versions of a third party abstraction. Own you own abstraction! We start of with a simple interface that is going to be used for logging. public interface ILog { void Info(string message); void Debug(string message); void Error(string message, Exception exception = null); } This is the interface that we will be injection into controllers, services or any other class that requires logging. The actual implementation of this interface looks like this public class Log : ILog { private readonly Action string logDebug; private readonly Action string, Exception logError; private readonly Action string logInfo; public Log(Action string logInfo, Action string logDebug, Action string, Exception logError) { this.logInfo = logInfo; this.logDebug = logDebug; this.logError = logError; } public void Info(string message) { logInfo(message); } public void Debug(string message) { logDebug(message); } public void Error(string message, Exception exception = null) { logError(message, exception); } } The Log class is not tied to a specific logging framework and it just takes a set of action delegates that represents the three logging levels supported by our abstraction. To help us create a Log instance, we have this nice little interface. public interface ILogFactory { ILog GetLogger(Type type); } And since we are going to be using Log4Net in this sample application, we have an implementation called Log4NetLogFactory . public class Log4NetLogFactory : ILogFactory { public Log4NetLogFactory() { XmlConfigurator.Configure(); } public ILog GetLogger(Type type) { var logger = LogManager.GetLogger(type); return new Log(logger.Info, logger.Debug, logger.Error); } } Note: This is the ONLY place where we actually reference Log4Net.","title":"Logging"},{"location":"webapirequestlogging/#composition-root","text":"This application has two composition roots ( ICompositionRoot ), one that registers the core services ( CompositionRoot )and one that registers services related to Web Api ( WebApiCompositionRoot ). public class CompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.Register ILogFactory, Log4NetLogFactory (new PerContainerLifetime()); serviceRegistry.Register Type, ILog ((factory, type) = factory.GetInstance ILogFactory ().GetLogger(type)); serviceRegistry.RegisterConstructorDependency( (factory, info) = factory.GetInstance Type, ILog (info.Member.DeclaringType)); } } The first service that we register is the ILogFactory that is responsible for creating an ILog instance based on a given type. Next, we register the ILog service with a factory delegate that calls into the already registered ILogFactory service Finally we tell the container using the RegisterConstructorDependency method that whenever it sees an ILog constructor dependency, it should provide an ILog instance based on the actual class that uses it. public class WebApiCompositionRoot : ICompositionRoot { public void Compose(IServiceRegistry serviceRegistry) { serviceRegistry.RegisterFrom CompositionRoot (); serviceRegistry.RegisterApiControllers(); } } The WebApiCompositionRoot registers core services in addition services related to Web Api which in this case means the controllers.","title":"Composition root"},{"location":"webapirequestlogging/#controllers","text":"This application has just one controller named PingController that is simply going to return the text \"pong\". public class PingController : ApiController { private readonly ILog log; public PingController(ILog log) { this.log = log; } public async Task IHttpActionResult Get() { log.Info( Ping start ); var result = Ok( Pong ); log.Info( Ping end ); return result; } } As we can see we are injecting an ILog instance into the controller. The Startup class for this application looks like this public class Startup { public void Configuration(IAppBuilder app) { var configuration = new HttpConfiguration(); ConfigureHttpRoutes(configuration); ConfigureMediaFormatter(configuration); var container = new ServiceContainer(); container.RegisterFrom WebApiCompositionRoot (); container.EnableWebApi(configuration); app.UseWebApi(configuration); } private static void ConfigureMediaFormatter(HttpConfiguration configuration) { configuration.Formatters.Clear(); configuration.Formatters.Add(new JsonMediaTypeFormatter()); } private static void ConfigureHttpRoutes(HttpConfiguration config) { config.Routes.MapHttpRoute( name: API Default , routeTemplate: api/{controller}/{id} , defaults: new { id = RouteParameter.Optional }); } } We can see all this in action just by running the application and hitting the service. http://localhost:8080/api/ping That should yield the following output in the console 2016-02-11 09:14:28.489 [INFO] 13 WebApiRequestLogging.PingController: Ping start 2016-02-11 09:14:28.603 [INFO] 6 WebApiRequestLogging.PingController: Ping end The Log4Net conversion pattern is like this (app.config) conversionPattern value= %date{yyyy-MM-dd HH:mm:ss.fff} [%level] %thread %logger: %message%newline /","title":"Controllers"},{"location":"webapirequestlogging/#request-logging","text":"Sometimes it might be useful to log each request and maybe also the duration of the request. We start off with a simple class ( OwinMiddleware ) that logs the duration of the request. public class RequestLoggingMiddleware : OwinMiddleware { private readonly ILog log; public RequestLoggingMiddleware(OwinMiddleware next, ILog log) : base(next) { this.log = log; } public override async Task Invoke(IOwinContext context) { await Measure(context).ConfigureAwait(false);; } private async Task Measure(IOwinContext context) { var stopWath = Stopwatch.StartNew(); await Next.Invoke(context).ConfigureAwait(false); stopWath.Stop(); log.Info($ Request {context.Request.Uri.PathAndQuery} took {stopWath.ElapsedMilliseconds} ms ); } } In addition to this we need to add this new middleware to the Owin pipeline by adding this line to the Startup class. app.Use RequestLoggingMiddleware (container.GetInstance Type, ILog (typeof (RequestLogDecorator))); Note: The reason for using an OwinMiddleware instead of a DelegatingHandler is that the OwinMiddleware is not tied to Web Api in any way and can also be used in other frameworks that build upon the Owin stack. Console output should now be 2016-02-11 13:07:48.466 [INFO] 11 WebApiRequestLogging.RequestLoggingMiddleware: Request /api/ping took 4 ms","title":"Request logging"},{"location":"webapirequestlogging/#request-context","text":"In some situations it is useful to be able to associate all log entries with the current web request. This can be used for analyzing the log later in tools such as Splunk making it possible to see all log entries tied to any given request. We could make the IOwinContext available in the container so that it could be injected into any class that requires information about the current request. This would however mean that these classes would have to know about the IOwinContext which might not be the best solution. So let's start off simple by creating a class to hold the request identifier. public class RequestContext { public RequestContext(string id) { Id = id; } public string Id { get; } } Next we create another middleware class to set the request identifier. public class RequestContextMiddleware : OwinMiddleware { private static readonly AsyncLocal RequestContext RequestContextStorage = new AsyncLocal RequestContext (); public RequestContextMiddleware(OwinMiddleware next) : base(next) { } public override async Task Invoke(IOwinContext context) { RequestContextStorage.Value = new RequestContext(Guid.NewGuid().ToString()); await Next.Invoke(context); } public static RequestContext CurrentRequest = RequestContextStorage.Value; } The actual RequestContext uses the AsyncLocal T class to ensure that the context flows across await points. The AsyncLocal T class is sort of the async version of ThreadLocal T . You should NEVER rely on any kind of storage that is tied to a specific thread in an async environment. Then we need to add the RequestContextMiddleware to the Owin pipeline. app.Use RequestContextMiddleware (); We now have way to access the current RequestContext through the CurrentRequest property. Sweet. The only thing missing now is to register a function delegate that represent getting the current RequestContext . serviceRegistry.Register Func RequestContext (factory = (() = RequestContextMiddleware.CurrentRequest), new PerContainerLifetime()); The reason for injection a function delegate rather than just the RequestContext is that it might be used in services such as singletons that outlives the scope of a web request. By injecting the delegate that in turn gives us the RequestContext , we can be sure that it is valid.","title":"Request Context"},{"location":"webapirequestlogging/#decorators","text":"The requirement here is that if we are logging outside the context of a web request, such as in a unit test, we should just log without the request identifier, but if we log inside a web request (production or integration tests), we should add the request identifier to the message being logged. This is a perfect example of where we can apply the Decorator Pattern . This allows us to add new functionality to a service without touching the original implementation. Did I hear \"open-closed principle\", anyone? public class RequestLogDecorator : ILog { private readonly ILog log; private readonly Func RequestContext getRequestContext; public RequestLogDecorator(ILog log, Func RequestContext getRequestContext) { this.log = log; this.getRequestInfo = getRequestInfo; } public void Info(string message) { log.Info($ Request id: {getRequestContext().Id} {message} ); } public void Debug(string message) { log.Debug($ Request id: {getRequestContext().Id} {message} ); } public void Error(string message, Exception exception = null) { log.Error($ Request id: {getRequestContext().Id} {message} , exception); } } The decorator simply wraps the original ILog instance and applies the request identifier now returned from the getRequestContext delegate. Don't you just love the new string interpolation features? Note: If you are new to the decorator pattern, you can think of it as a Russian Doll where inside there is an exact identical doll wrapped by an outer doll. Decorators are first-class citizens in LightInject and applying a decorator is just a one-liner in the WepApiCompositionRoot class. serviceRegistry.Decorate ILog, RequestLogDecorator (); Since we only apply the decorator in the WepApiCompositionRoot class it will only be used in the context of a web request. To \"ensure\" that we don't always log on the same thread, we modify the PingController to inlude a delay. public async Task IHttpActionResult Get() { log.Info( Ping start ); //ConfigureAwait(false) to say that we don't care about synchronization context. await Task.Delay(100).ConfigureAwait(false); // We are probably on another thread here var result = Ok( Pong ); log.Info( Ping end ); return result; } Running the application and hitting the service should now yield the following output in the console 2016-02-11 20:40:30.994 [INFO] 12 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping start 2016-02-11 20:40:31.111 [INFO] 6 WebApiRequestLogging.PingController: Request id: 91444099-72ad-488f-99d6-ab201f20531e Ping end 2016-02-11 20:40:31.205 [INFO] 6 WebApiRequestLogging.RequestLogDecorator: Request id: 91444099-72ad-488f-99d6-ab201f20531e Request /api/ping took 463 ms As we can see that even if we started and ended the request on two different threads, we still have the same request identifier. Happy logging!!","title":"Decorators"},{"location":"xunit/","text":"LightInject.xUnit LightInject.xUnit provides an integration that enables dependency injection in xUnit test methods. Installing LightInject.xUnit provides two distribution models via NuGet Binary PM Install-Package LightInject.xUnit This adds a reference to the LightInject.Xunit.dll in the target project. Source PM Install-Package LightInject.xUnit.Source This will install a single file, LightInject.Xunit.cs in the target project. Injecting services Services from LightInject are injected into methods that are decorated with the InjectData attribute. [Theory, InjectData] public void TestMethod(IFoo foo) { Assert.NotNull(foo); } Configuration LightInject will look for an ICompositionRoot implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root. If such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature. public static void Configure(IServiceContainer container) { container.Register IFoo, Foo (); } This method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed. Scoping (xUnit = 1.9.2) Services registered with the PerScopeLifetime or PerRequestLifetime needs to be resolved within an active Scope to ensure that any services that implements IDisposable are properly disposed. By decorating the test method with the ScopedTheory attribute, a new Scope will be started when the test method starts and it will end when the test method ends. [ScopedTheory, InjectData] public void MethodWithScopedArgument(IFoo foo) { Assert.NotNull(foo); } Scoping (xUnit = 2.0.0) Services registered with the PerScopeLifetime or PerRequestLifetime needs to be resolved within an active Scope to ensure that any services that implements IDisposable are properly disposed. By decorating the test method with the Scoped attribute, a new Scope will be started when the test method starts and it will end when the test method ends. [Theory, Scoped, InjectData] public void MethodWithScopedArgument(IFoo foo) { Assert.NotNull(foo); }","title":"xUnit"},{"location":"xunit/#lightinjectxunit","text":"LightInject.xUnit provides an integration that enables dependency injection in xUnit test methods.","title":"LightInject.xUnit"},{"location":"xunit/#installing","text":"LightInject.xUnit provides two distribution models via NuGet","title":"Installing"},{"location":"xunit/#binary","text":"PM Install-Package LightInject.xUnit This adds a reference to the LightInject.Xunit.dll in the target project.","title":"Binary"},{"location":"xunit/#source","text":"PM Install-Package LightInject.xUnit.Source This will install a single file, LightInject.Xunit.cs in the target project.","title":"Source"},{"location":"xunit/#injecting-services","text":"Services from LightInject are injected into methods that are decorated with the InjectData attribute. [Theory, InjectData] public void TestMethod(IFoo foo) { Assert.NotNull(foo); }","title":"Injecting services"},{"location":"xunit/#configuration","text":"LightInject will look for an ICompositionRoot implementation in the same assembly as the requested service. If it is found, it will be executed and the container gets configured through that composition root. If such an implementation does not exists or that we for some other reason need to configure the container, we can do this by simply implementing a static method in the test class with the following signature. public static void Configure(IServiceContainer container) { container.Register IFoo, Foo (); } This method is executed regardless of other composition roots and allows customized configuration of the container before the test is executed.","title":"Configuration"},{"location":"xunit/#scoping-xunit-192","text":"Services registered with the PerScopeLifetime or PerRequestLifetime needs to be resolved within an active Scope to ensure that any services that implements IDisposable are properly disposed. By decorating the test method with the ScopedTheory attribute, a new Scope will be started when the test method starts and it will end when the test method ends. [ScopedTheory, InjectData] public void MethodWithScopedArgument(IFoo foo) { Assert.NotNull(foo); }","title":"Scoping (xUnit &lt;= 1.9.2)"},{"location":"xunit/#scoping-xunit-200","text":"Services registered with the PerScopeLifetime or PerRequestLifetime needs to be resolved within an active Scope to ensure that any services that implements IDisposable are properly disposed. By decorating the test method with the Scoped attribute, a new Scope will be started when the test method starts and it will end when the test method ends. [Theory, Scoped, InjectData] public void MethodWithScopedArgument(IFoo foo) { Assert.NotNull(foo); }","title":"Scoping (xUnit &gt;= 2.0.0)"}]}